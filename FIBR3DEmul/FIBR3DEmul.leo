<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20220407205046.1"><vh>@settings</vh>
<v t="leo.20220407205046.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20220407205046.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20220407205015.2"><vh>importer</vh></v>
<v t="leo.20220407205631.1"><vh>imported files</vh>
<v t="leo.20220407205631.2"><vh>@path ./</vh>
<v t="leo.20220407205631.31"><vh>@path v-rep_plugin</vh>
<v t="leo.20220407205631.32"><vh>@clean simExtFIBR3D.cpp</vh>
<v t="leo.20220407205631.33"><vh>void LUA_INIT_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.34"><vh>void LUA_CHANGE_MATERIAL_SHAPE_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.35"><vh>void LUA_CHANGE_MATERIAL_COLOR_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.36"><vh>void LUA_CHANGE_MATERIAL_SIZE_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.37"><vh>void LUA_CHANGE_FILAMENT_RESOLUTION_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.38"><vh>void LUA_REMOVE_MATERIAL_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.39"><vh>void LUA_CREATE_MESH_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.40"><vh>void LUA_SET_COLLISION_HANDLES_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.41"><vh>void LUA_ENABLE_COLLISIONS_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.42"><vh>void LUA_CLEANUP_FIBR3D_CONTROL_CALLBACK (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.43"><vh>float v_repExtGetSimulationTimeStep (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.44"><vh>void v_repExtPQGetJointPositions (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.45"><vh>void v_repExtPQSetJointTrajectory (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.46"><vh>void v_repExtPQAdvanceLine (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.47"><vh>void v_repExtPQStopPrinting (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.48"><vh>void v_repExtPQBarMsgCommunication (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.49"><vh>void v_repExtPQBoxMsgCommunication (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.50"><vh>void v_repExtGetHandles (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.51"><vh>bool v_repExtGetJointPositions (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.52"><vh>bool v_repExtGetJointVelocities (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.53"><vh>bool v_repExtSetJointPositions (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.54"><vh>void v_repExtRemoveMaterial (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.55"><vh>void v_repExtCreateMesh (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.56"><vh>void v_repExtBarMsgCommunication (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.57"><vh>void v_repExtBoxMsgCommunication (simExtFIBR3D.cpp)</vh></v>
<v t="leo.20220407205631.58"><vh>void v_repAddDrawingItem (simExtFIBR3D.cpp)</vh></v>
</v>
<v t="leo.20220407205631.59"><vh>@clean simExtFIBR3D.h</vh>
<v t="leo.20220407205631.60"><vh>void v_repExtPQSetJointTrajectory (simExtFIBR3D.h)</vh></v>
</v>
<v t="leo.20220407205631.64"><vh>@path coppelia</vh>
<v t="leo.20220407205631.65"><vh>@path common</vh>
<v t="leo.20220407205631.66"><vh>@clean luaFunctionData.cpp</vh>
<v t="leo.20220407205631.67"><vh>void CLuaFunctionData::getInputDataForFunctionRegistration (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.68"><vh>bool CLuaFunctionData::readDataFromLua (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.69"><vh>bool CLuaFunctionData::readDataFromLua_luaFunctionCall (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.70"><vh>void CLuaFunctionData::pushOutData (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.71"><vh>void CLuaFunctionData::pushOutData_luaFunctionCall (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.72"><vh>void CLuaFunctionData::writeDataToLua (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.73"><vh>void CLuaFunctionData::writeDataToLua_luaFunctionCall (luaFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.74"><vh>void CLuaFunctionData::releaseBuffers_luaFunctionCall (luaFunctionData.cpp)</vh></v>
</v>
<v t="leo.20220407205631.75"><vh>@clean luaFunctionDataItem.cpp</vh>
<v t="leo.20220407205631.76"><vh>bool CLuaFunctionDataItem::isTable (luaFunctionDataItem.cpp)</vh></v>
<v t="leo.20220407205631.77"><vh>int CLuaFunctionDataItem::getType (luaFunctionDataItem.cpp)</vh></v>
<v t="leo.20220407205631.78"><vh>void CLuaFunctionDataItem::setNilTable (luaFunctionDataItem.cpp)</vh></v>
<v t="leo.20220407205631.79"><vh>int CLuaFunctionDataItem::getNilTableSize (luaFunctionDataItem.cpp)</vh></v>
</v>
<v t="leo.20220407205631.80"><vh>@clean scriptFunctionData.cpp</vh>
<v t="leo.20220407205631.81"><vh>bool CScriptFunctionData::readDataFromStack (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.82"><vh>bool CScriptFunctionData::readDataFromStack_scriptFunctionCall (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.83"><vh>void CScriptFunctionData::pushOutData (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.84"><vh>void CScriptFunctionData::pushOutData_scriptFunctionCall (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.85"><vh>void CScriptFunctionData::writeDataToStack (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.86"><vh>void CScriptFunctionData::writeDataToStack_scriptFunctionCall (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.87"><vh>bool CScriptFunctionData::_readData (scriptFunctionData.cpp)</vh></v>
<v t="leo.20220407205631.88"><vh>void CScriptFunctionData::_writeData (scriptFunctionData.cpp)</vh></v>
</v>
<v t="leo.20220407205631.89"><vh>@clean scriptFunctionDataItem.cpp</vh>
<v t="leo.20220407205631.90"><vh>bool CScriptFunctionDataItem::isTable (scriptFunctionDataItem.cpp)</vh></v>
<v t="leo.20220407205631.91"><vh>int CScriptFunctionDataItem::getType (scriptFunctionDataItem.cpp)</vh></v>
<v t="leo.20220407205631.92"><vh>void CScriptFunctionDataItem::setNilTable (scriptFunctionDataItem.cpp)</vh></v>
<v t="leo.20220407205631.93"><vh>int CScriptFunctionDataItem::getNilTableSize (scriptFunctionDataItem.cpp)</vh></v>
</v>
<v t="leo.20220407205631.94"><vh>@clean simLib.cpp</vh>
<v t="leo.20220407205631.95"><vh>void unloadSimLibrary (simLib.cpp)</vh></v>
<v t="leo.20220407205631.96"><vh>int getSimProcAddresses (simLib.cpp)</vh></v>
</v>
<v t="leo.20220407205631.97"><vh>@clean socketInConnection.cpp</vh>
<v t="leo.20220407205631.98"><vh>bool CSocketInConnection::connectToClient (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.99"><vh>char* CSocketInConnection::receiveData(int&amp; dataSize) (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.100"><vh>bool CSocketInConnection::replyToReceivedData (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.101"><vh>bool CSocketInConnection::_sendSimplePacket (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.102"><vh>int CSocketInConnection::_receiveSimplePacket (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.103"><vh>int CSocketInConnection::_getTimeInMs (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.104"><vh>int CSocketInConnection::_getTimeInMs (socketInConnection.cpp)</vh></v>
<v t="leo.20220407205631.105"><vh>int CSocketInConnection::_getTimeDiffInMs (socketInConnection.cpp)</vh></v>
</v>
<v t="leo.20220407205631.106"><vh>@clean socketOutConnection.cpp</vh>
<v t="leo.20220407205631.107"><vh>int CSocketOutConnection::connectToServer (socketOutConnection.cpp)</vh></v>
<v t="leo.20220407205631.108"><vh>bool CSocketOutConnection::sendData (socketOutConnection.cpp)</vh></v>
<v t="leo.20220407205631.109"><vh>char* CSocketOutConnection::receiveReplyData(int&amp; dataSize) (socketOutConnection.cpp)</vh></v>
<v t="leo.20220407205631.110"><vh>bool CSocketOutConnection::_sendSimplePacket (socketOutConnection.cpp)</vh></v>
<v t="leo.20220407205631.111"><vh>int CSocketOutConnection::_receiveSimplePacket (socketOutConnection.cpp)</vh></v>
<v t="leo.20220407205631.112"><vh>int CSocketOutConnection::_getTimeInMs (socketOutConnection.cpp)</vh></v>
<v t="leo.20220407205631.113"><vh>int CSocketOutConnection::_getTimeDiffInMs (socketOutConnection.cpp)</vh></v>
</v>
<v t="leo.20220407205631.114"><vh>@path stack</vh>
<v t="leo.20220407205631.115"><vh>@clean stackArray.cpp</vh>
<v t="leo.20220407205631.116"><vh>void CStackArray::buildOntoStack (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.117"><vh>bool CStackArray::buildFromStack (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.118"><vh>void CStackArray::setCircularRef (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.119"><vh>bool CStackArray::isCircularRef (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.120"><vh>void CStackArray::appendTopStackItem (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.121"><vh>bool CStackArray::isNull (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.122"><vh>bool CStackArray::isBool (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.123"><vh>bool CStackArray::isNumber (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.124"><vh>bool CStackArray::isString (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.125"><vh>bool CStackArray::isArray (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.126"><vh>bool CStackArray::isMap (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.127"><vh>bool CStackArray::getBool (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.128"><vh>float CStackArray::getFloat (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.129"><vh>int CStackArray::getInt (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.130"><vh>const double* CStackArray::getDoublePointer() (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.131"><vh>const int* CStackArray::getIntPointer() (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.132"><vh>bool CStackArray::isNumberArray (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.133"><vh>const std::vector (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.134"><vh>const std::vector (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.135"><vh>const std::vector (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.136"><vh>bool CStackArray::pushNull (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.137"><vh>bool CStackArray::pushBool (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.138"><vh>bool CStackArray::pushFloat (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.139"><vh>bool CStackArray::pushDouble (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.140"><vh>bool CStackArray::pushInt (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.141"><vh>bool CStackArray::pushString (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.142"><vh>bool CStackArray::pushString (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.143"><vh>bool CStackArray::pushArray (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.144"><vh>bool CStackArray::pushMap (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.145"><vh>bool CStackArray::setDoubleArray (stackArray.cpp)</vh></v>
<v t="leo.20220407205631.146"><vh>bool CStackArray::setIntArray (stackArray.cpp)</vh></v>
</v>
<v t="leo.20220407205631.147"><vh>@clean stackBool.cpp</vh>
<v t="leo.20220407205631.148"><vh>bool CStackBool::getValue (stackBool.cpp)</vh></v>
<v t="leo.20220407205631.149"><vh>void CStackBool::setValue (stackBool.cpp)</vh></v>
</v>
<v t="leo.20220407205631.150"><vh>@clean stackMap.cpp</vh>
<v t="leo.20220407205631.151"><vh>void CStackMap::_remove (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.152"><vh>void CStackMap::_remove (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.153"><vh>void CStackMap::_remove (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.154"><vh>void CStackMap::appendTopStackItem (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.155"><vh>void CStackMap::appendTopStackItem (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.156"><vh>void CStackMap::appendTopStackItem (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.157"><vh>bool CStackMap::isKeyPresent (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.158"><vh>bool CStackMap::isKeyPresent (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.159"><vh>bool CStackMap::isKeyPresent (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.160"><vh>bool CStackMap::isNull (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.161"><vh>bool CStackMap::isBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.162"><vh>bool CStackMap::isNumber (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.163"><vh>bool CStackMap::isString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.164"><vh>bool CStackMap::isArray (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.165"><vh>bool CStackMap::isMap (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.166"><vh>bool CStackMap::isNull (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.167"><vh>bool CStackMap::isBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.168"><vh>bool CStackMap::isNumber (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.169"><vh>bool CStackMap::isString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.170"><vh>bool CStackMap::isArray (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.171"><vh>bool CStackMap::isMap (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.172"><vh>bool CStackMap::isNull (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.173"><vh>bool CStackMap::isBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.174"><vh>bool CStackMap::isNumber (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.175"><vh>bool CStackMap::isString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.176"><vh>bool CStackMap::isArray (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.177"><vh>bool CStackMap::isMap (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.178"><vh>bool CStackMap::getBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.179"><vh>float CStackMap::getFloat (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.180"><vh>int CStackMap::getInt (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.181"><vh>bool CStackMap::getBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.182"><vh>float CStackMap::getFloat (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.183"><vh>int CStackMap::getInt (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.184"><vh>bool CStackMap::getBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.185"><vh>float CStackMap::getFloat (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.186"><vh>int CStackMap::getInt (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.187"><vh>bool CStackMap::contains (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.188"><vh>bool CStackMap::contains (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.189"><vh>bool CStackMap::contains (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.190"><vh>void CStackMap::setNull (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.191"><vh>void CStackMap::setBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.192"><vh>void CStackMap::setFloat (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.193"><vh>void CStackMap::setDouble (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.194"><vh>void CStackMap::setInt (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.195"><vh>void CStackMap::setString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.196"><vh>void CStackMap::setString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.197"><vh>void CStackMap::setArray (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.198"><vh>void CStackMap::setMap (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.199"><vh>void CStackMap::setNull (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.200"><vh>void CStackMap::setBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.201"><vh>void CStackMap::setFloat (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.202"><vh>void CStackMap::setDouble (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.203"><vh>void CStackMap::setInt (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.204"><vh>void CStackMap::setString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.205"><vh>void CStackMap::setString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.206"><vh>void CStackMap::setArray (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.207"><vh>void CStackMap::setMap (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.208"><vh>void CStackMap::setNull (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.209"><vh>void CStackMap::setBool (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.210"><vh>void CStackMap::setFloat (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.211"><vh>void CStackMap::setDouble (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.212"><vh>void CStackMap::setInt (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.213"><vh>void CStackMap::setString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.214"><vh>void CStackMap::setString (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.215"><vh>void CStackMap::setArray (stackMap.cpp)</vh></v>
<v t="leo.20220407205631.216"><vh>void CStackMap::setMap (stackMap.cpp)</vh></v>
</v>
<v t="leo.20220407205631.217"><vh>@clean stackNull.cpp</vh></v>
<v t="leo.20220407205632.1"><vh>@clean stackNumber.cpp</vh>
<v t="leo.20220407205632.2"><vh>float CStackNumber::getFloatValue (stackNumber.cpp)</vh></v>
<v t="leo.20220407205632.3"><vh>int CStackNumber::getIntValue (stackNumber.cpp)</vh></v>
<v t="leo.20220407205632.4"><vh>void CStackNumber::setFloatValue (stackNumber.cpp)</vh></v>
<v t="leo.20220407205632.5"><vh>void CStackNumber::setIntValue (stackNumber.cpp)</vh></v>
<v t="leo.20220407205632.6"><vh>void CStackNumber::setLongValue (stackNumber.cpp)</vh></v>
<v t="leo.20220407205632.7"><vh>void CStackNumber::setValue (stackNumber.cpp)</vh></v>
</v>
<v t="leo.20220407205632.8"><vh>@clean stackObject.cpp</vh>
<v t="leo.20220407205632.9"><vh>int CStackObject::getObjectType (stackObject.cpp)</vh></v>
<v t="leo.20220407205632.10"><vh>void CStackObject::buildItemOntoStack (stackObject.cpp)</vh></v>
</v>
<v t="leo.20220407205632.11"><vh>@clean stackString.cpp</vh>
<v t="leo.20220407205632.12"><vh>void CStackString::setValue (stackString.cpp)</vh></v>
</v>
</v>
</v>
<v t="leo.20220407205632.13"><vh>@path include</vh>
<v t="leo.20220407205632.14"><vh>@clean _dirent.h</vh>
<v t="leo.20220407205632.15"><vh>extern "C" { (_dirent.h)</vh>
<v t="leo.20220407205632.16"><vh>const wchar_t (_dirent.h)</vh></v>
<v t="leo.20220407205632.17"><vh>static struct (_dirent.h)</vh></v>
<v t="leo.20220407205632.18"><vh>static int _wclosedir (_dirent.h)</vh></v>
<v t="leo.20220407205632.19"><vh>static void _wrewinddir (_dirent.h)</vh></v>
<v t="leo.20220407205632.20"><vh>static WIN32_FIND_DATAW (_dirent.h)</vh></v>
<v t="leo.20220407205632.21"><vh>static WIN32_FIND_DATAW (_dirent.h)</vh></v>
<v t="leo.20220407205632.22"><vh>static DIR (_dirent.h)</vh></v>
<v t="leo.20220407205632.23"><vh>static struct (_dirent.h)</vh></v>
<v t="leo.20220407205632.24"><vh>static int closedir (_dirent.h)</vh></v>
<v t="leo.20220407205632.25"><vh>static void rewinddir (_dirent.h)</vh></v>
<v t="leo.20220407205632.26"><vh>static int dirent_mbstowcs_s (_dirent.h)</vh></v>
<v t="leo.20220407205632.27"><vh>static int dirent_wcstombs_s (_dirent.h)</vh></v>
<v t="leo.20220407205632.28"><vh>static void dirent_set_errno (_dirent.h)</vh></v>
</v>
</v>
<v t="leo.20220407205632.29"><vh>@clean luaFunctionData.h</vh>
<v t="leo.20220407205632.30"><vh>class CLuaFunctionData</vh></v>
</v>
<v t="leo.20220407205632.31"><vh>@clean luaFunctionDataItem.h</vh>
<v t="leo.20220407205632.32"><vh>class CLuaFunctionDataItem</vh></v>
</v>
<v t="leo.20220407205632.33"><vh>@clean scriptFunctionData.h</vh>
<v t="leo.20220407205632.34"><vh>class CScriptFunctionData</vh></v>
</v>
<v t="leo.20220407205632.35"><vh>@clean scriptFunctionDataItem.h</vh>
<v t="leo.20220407205632.36"><vh>class CScriptFunctionDataItem</vh></v>
</v>
<v t="leo.20220407205632.37"><vh>@clean shared_memory.h</vh>
<v t="leo.20220407205632.38"><vh>typedef struct (shared_memory.h)</vh></v>
<v t="leo.20220407205632.39"><vh>extern "C" { (shared_memory.h)</vh></v>
</v>
<v t="leo.20220407205632.40"><vh>@clean simConst.h</vh></v>
<v t="leo.20220407205632.41"><vh>@clean simLib.h</vh></v>
<v t="leo.20220407205632.42"><vh>@clean simTypes.h</vh></v>
<v t="leo.20220407205632.43"><vh>@clean socketInConnection.h</vh>
<v t="leo.20220407205632.44"><vh>class CSocketInConnection</vh></v>
</v>
<v t="leo.20220407205632.45"><vh>@clean socketOutConnection.h</vh>
<v t="leo.20220407205632.46"><vh>class CSocketOutConnection</vh></v>
</v>
<v t="leo.20220407205632.47"><vh>@path stack</vh>
<v t="leo.20220407205632.48"><vh>@clean stackArray.h</vh>
<v t="leo.20220407205632.49"><vh>class CStackArray</vh></v>
</v>
<v t="leo.20220407205632.50"><vh>@clean stackBool.h</vh>
<v t="leo.20220407205632.51"><vh>class CStackBool</vh></v>
</v>
<v t="leo.20220407205632.52"><vh>@clean stackMap.h</vh>
<v t="leo.20220407205632.53"><vh>class CStackMap</vh></v>
</v>
<v t="leo.20220407205632.54"><vh>@clean stackNull.h</vh>
<v t="leo.20220407205632.55"><vh>class CStackNull</vh></v>
</v>
<v t="leo.20220407205632.56"><vh>@clean stackNumber.h</vh>
<v t="leo.20220407205632.57"><vh>class CStackNumber</vh></v>
</v>
<v t="leo.20220407205632.58"><vh>@clean stackObject.h</vh>
<v t="leo.20220407205632.59"><vh>class CStackObject</vh></v>
</v>
<v t="leo.20220407205632.60"><vh>@clean stackString.h</vh>
<v t="leo.20220407205632.61"><vh>class CStackString</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20220407205632.62"><vh>@path include</vh>
<v t="leo.20220407205632.63"><vh>@clean Extruder.h</vh>
<v t="leo.20220407205632.64"><vh>class Extruder</vh></v>
</v>
<v t="leo.20220407205632.65"><vh>@clean Listener.h</vh>
<v t="leo.20220407205632.66"><vh>class Listener</vh></v>
</v>
<v t="leo.20220407205632.67"><vh>@clean Path.h</vh>
<v t="leo.20220407205632.68"><vh>class Path</vh></v>
</v>
<v t="leo.20220407205632.69"><vh>@clean Printer.h</vh>
<v t="leo.20220407205632.70"><vh>class Printer</vh></v>
</v>
<v t="leo.20220407205632.71"><vh>@clean Server.h</vh>
<v t="leo.20220407205632.72"><vh>class SessionEcho</vh></v>
<v t="leo.20220407205632.73"><vh>class SessionSend</vh></v>
<v t="leo.20220407205632.74"><vh>class Server</vh></v>
<v t="leo.20220407205632.75"><vh>class CommunicationManager</vh></v>
</v>
<v t="leo.20220407205632.76"><vh>@clean Speaker.h</vh>
<v t="leo.20220407205632.77"><vh>class Speaker</vh></v>
</v>
<v t="leo.20220407205632.78"><vh>@clean Trajectory.h</vh>
<v t="leo.20220407205632.79"><vh>class Trajectory</vh></v>
</v>
<v t="leo.20220407205632.80"><vh>@clean VelocityProfile.h</vh>
<v t="leo.20220407205632.81"><vh>class VelocityProfile</vh></v>
</v>
<v t="leo.20220407205632.82"><vh>@clean basic_concurrent_queue.h</vh>
<v t="leo.20220407205632.83"><vh>class BasicConcurrentQueue</vh></v>
<v t="leo.20220407205632.84"><vh>void BasicConcurrentQueue (basic_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.85"><vh>void BasicConcurrentQueue (basic_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.86"><vh>void BasicConcurrentQueue (basic_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.87"><vh>void BasicConcurrentQueue (basic_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.88"><vh>bool BasicConcurrentQueue (basic_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.89"><vh>int BasicConcurrentQueue (basic_concurrent_queue.h)</vh></v>
</v>
<v t="leo.20220407205632.90"><vh>@clean pair_concurrent_queue.h</vh>
<v t="leo.20220407205632.91"><vh>class PairConcurrentQueue</vh></v>
<v t="leo.20220407205632.92"><vh>bool PairConcurrentQueue (pair_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.93"><vh>int PairConcurrentQueue (pair_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.94"><vh>void PairConcurrentQueue (pair_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.95"><vh>void PairConcurrentQueue (pair_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.96"><vh>void PairConcurrentQueue (pair_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.97"><vh>void PairConcurrentQueue (pair_concurrent_queue.h)</vh></v>
</v>
<v t="leo.20220407205632.98"><vh>@clean string_concurrent_queue.h</vh>
<v t="leo.20220407205632.99"><vh>class StringConcurrentQueue</vh></v>
</v>
<v t="leo.20220407205632.100"><vh>@clean vector_concurrent_queue.h</vh>
<v t="leo.20220407205632.101"><vh>class VectorConcurrentQueue</vh></v>
<v t="leo.20220407205632.102"><vh>bool VectorConcurrentQueue (vector_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.103"><vh>int VectorConcurrentQueue (vector_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.104"><vh>void VectorConcurrentQueue (vector_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.105"><vh>void VectorConcurrentQueue (vector_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.106"><vh>void VectorConcurrentQueue (vector_concurrent_queue.h)</vh></v>
<v t="leo.20220407205632.107"><vh>void VectorConcurrentQueue (vector_concurrent_queue.h)</vh></v>
</v>
</v>
<v t="leo.20220407205632.108"><vh>@path spdlog</vh>
<v t="leo.20220407205632.109"><vh>@clean async.h</vh>
<v t="leo.20220407205632.110"><vh>static std::shared_ptr (async.h)</vh></v>
</v>
<v t="leo.20220407205632.111"><vh>@clean async_logger.h</vh>
<v t="leo.20220407205632.112"><vh>class async_logger</vh></v>
</v>
<v t="leo.20220407205632.113"><vh>@clean common.h</vh>
<v t="leo.20220407205632.114"><vh>class spdlog_ex</vh>
<v t="leo.20220407205632.115"><vh>spdlog_ex.const char *what() const SPDLOG_NOEXCEPT override</vh></v>
</v>
</v>
<v t="leo.20220407205632.116"><vh>@clean formatter.h</vh>
<v t="leo.20220407205632.117"><vh>class formatter</vh></v>
</v>
<v t="leo.20220407205632.118"><vh>@clean logger.h</vh>
<v t="leo.20220407205632.119"><vh>class logger</vh></v>
</v>
<v t="leo.20220407205632.120"><vh>@clean spdlog.h</vh>
<v t="leo.20220407205632.121"><vh>static std::shared_ptr (spdlog.h)</vh></v>
</v>
<v t="leo.20220407205632.122"><vh>@clean tweakme.h</vh></v>
<v t="leo.20220407205632.123"><vh>@clean version.h</vh></v>
<v t="leo.20220407205633.1"><vh>@path details</vh>
<v t="leo.20220407205633.2"><vh>@clean async_logger_impl.h</vh></v>
<v t="leo.20220407205633.3"><vh>@clean circular_q.h</vh>
<v t="leo.20220407205633.4"><vh>class circular_q</vh>
<v t="leo.20220407205633.5"><vh>circular_q.void push_back</vh></v>
<v t="leo.20220407205633.6"><vh>circular_q.void pop_front</vh></v>
<v t="leo.20220407205633.7"><vh>circular_q.bool empty</vh></v>
<v t="leo.20220407205633.8"><vh>circular_q.bool full</vh></v>
</v>
</v>
<v t="leo.20220407205633.9"><vh>@clean console_globals.h</vh>
<v t="leo.20220407205633.10"><vh>static std::FILE (console_globals.h)</vh></v>
<v t="leo.20220407205633.11"><vh>static HANDLE (console_globals.h)</vh></v>
<v t="leo.20220407205633.12"><vh>static std::FILE (console_globals.h)</vh></v>
<v t="leo.20220407205633.13"><vh>static HANDLE (console_globals.h)</vh></v>
<v t="leo.20220407205633.14"><vh>static mutex_t (console_globals.h)</vh></v>
<v t="leo.20220407205633.15"><vh>static mutex_t (console_globals.h)</vh></v>
</v>
<v t="leo.20220407205633.16"><vh>@clean file_helper.h</vh>
<v t="leo.20220407205633.17"><vh>class file_helper</vh>
<v t="leo.20220407205633.18"><vh>file_helper.void open</vh></v>
<v t="leo.20220407205633.19"><vh>file_helper.void reopen</vh></v>
<v t="leo.20220407205633.20"><vh>file_helper.void flush</vh></v>
<v t="leo.20220407205633.21"><vh>file_helper.void close</vh></v>
<v t="leo.20220407205633.22"><vh>file_helper.void write</vh></v>
<v t="leo.20220407205633.23"><vh>file_helper.const filename_t</vh></v>
<v t="leo.20220407205633.24"><vh>file_helper.bool file_exists</vh></v>
<v t="leo.20220407205633.25"><vh>file_helper.static std::tuple</vh></v>
</v>
</v>
<v t="leo.20220407205633.26"><vh>@clean fmt_helper.h</vh></v>
<v t="leo.20220407205633.27"><vh>@clean log_msg.h</vh></v>
<v t="leo.20220407205633.28"><vh>@clean logger_impl.h</vh></v>
<v t="leo.20220407205633.29"><vh>@clean mpmc_blocking_q.h</vh>
<v t="leo.20220407205633.30"><vh>class mpmc_blocking_queue</vh>
<v t="leo.20220407205633.31"><vh>mpmc_blocking_queue.void enqueue</vh></v>
<v t="leo.20220407205633.32"><vh>mpmc_blocking_queue.void enqueue_nowait</vh></v>
<v t="leo.20220407205633.33"><vh>mpmc_blocking_queue.bool dequeue_for</vh></v>
<v t="leo.20220407205633.34"><vh>mpmc_blocking_queue.void enqueue</vh></v>
<v t="leo.20220407205633.35"><vh>mpmc_blocking_queue.void enqueue_nowait</vh></v>
<v t="leo.20220407205633.36"><vh>mpmc_blocking_queue.bool dequeue_for</vh></v>
</v>
</v>
<v t="leo.20220407205633.37"><vh>@clean null_mutex.h</vh>
<v t="leo.20220407205633.38"><vh>void lock (null_mutex.h)</vh></v>
<v t="leo.20220407205633.39"><vh>int load (null_mutex.h)</vh></v>
<v t="leo.20220407205633.40"><vh>void store (null_mutex.h)</vh></v>
</v>
<v t="leo.20220407205633.41"><vh>@clean os.h</vh>
<v t="leo.20220407205633.42"><vh>static long (os.h)</vh></v>
<v t="leo.20220407205633.43"><vh>const expr (os.h)</vh></v>
<v t="leo.20220407205633.44"><vh>bool result (os.h)</vh></v>
</v>
<v t="leo.20220407205633.45"><vh>@clean pattern_formatter.h</vh>
<v t="leo.20220407205633.46"><vh>bool enabled (pattern_formatter.h)</vh></v>
<v t="leo.20220407205633.47"><vh>class scoped_pad</vh>
<v t="leo.20220407205633.48"><vh>scoped_pad.void pad_it</vh></v>
</v>
<v t="leo.20220407205633.49"><vh>class flag_formatter</vh></v>
<v t="leo.20220407205633.50"><vh>class name_formatter</vh>
<v t="leo.20220407205633.51"><vh>name_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.52"><vh>class level_formatter</vh>
<v t="leo.20220407205633.53"><vh>level_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.54"><vh>class short_level_formatter</vh>
<v t="leo.20220407205633.55"><vh>short_level_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.56"><vh>static const char *ampm(const tm &amp;t) (pattern_formatter.h)</vh></v>
<v t="leo.20220407205633.57"><vh>int to12h (pattern_formatter.h)</vh></v>
<v t="leo.20220407205633.58"><vh>class a_formatter</vh>
<v t="leo.20220407205633.59"><vh>a_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.60"><vh>class A_formatter</vh>
<v t="leo.20220407205633.61"><vh>A_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.62"><vh>class b_formatter</vh>
<v t="leo.20220407205633.63"><vh>b_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.64"><vh>static const char *full_months[]{ (pattern_formatter.h)</vh></v>
<v t="leo.20220407205633.65"><vh>class B_formatter</vh>
<v t="leo.20220407205633.66"><vh>B_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.67"><vh>class c_formatter</vh>
<v t="leo.20220407205633.68"><vh>c_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.69"><vh>class C_formatter</vh>
<v t="leo.20220407205633.70"><vh>C_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.71"><vh>class D_formatter</vh>
<v t="leo.20220407205633.72"><vh>D_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.73"><vh>class Y_formatter</vh>
<v t="leo.20220407205633.74"><vh>Y_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.75"><vh>class m_formatter</vh>
<v t="leo.20220407205633.76"><vh>m_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.77"><vh>class d_formatter</vh>
<v t="leo.20220407205633.78"><vh>d_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.79"><vh>class H_formatter</vh>
<v t="leo.20220407205633.80"><vh>H_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.81"><vh>class I_formatter</vh>
<v t="leo.20220407205633.82"><vh>I_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.83"><vh>class M_formatter</vh>
<v t="leo.20220407205633.84"><vh>M_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.85"><vh>class S_formatter</vh>
<v t="leo.20220407205633.86"><vh>S_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.87"><vh>class e_formatter</vh>
<v t="leo.20220407205633.88"><vh>e_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.89"><vh>class f_formatter</vh>
<v t="leo.20220407205633.90"><vh>f_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.91"><vh>class F_formatter</vh>
<v t="leo.20220407205633.92"><vh>F_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.93"><vh>class E_formatter</vh>
<v t="leo.20220407205633.94"><vh>E_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.95"><vh>class p_formatter</vh>
<v t="leo.20220407205633.96"><vh>p_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.97"><vh>class r_formatter</vh>
<v t="leo.20220407205633.98"><vh>r_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.99"><vh>class R_formatter</vh>
<v t="leo.20220407205633.100"><vh>R_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.101"><vh>class T_formatter</vh>
<v t="leo.20220407205633.102"><vh>T_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.103"><vh>class z_formatter</vh>
<v t="leo.20220407205633.104"><vh>z_formatter.void format</vh></v>
<v t="leo.20220407205633.105"><vh>z_formatter.int get_cached_offset</vh></v>
</v>
<v t="leo.20220407205633.106"><vh>class t_formatter</vh>
<v t="leo.20220407205633.107"><vh>t_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.108"><vh>class pid_formatter</vh>
<v t="leo.20220407205633.109"><vh>pid_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.110"><vh>class i_formatter</vh>
<v t="leo.20220407205633.111"><vh>i_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.112"><vh>class v_formatter</vh>
<v t="leo.20220407205633.113"><vh>v_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.114"><vh>class ch_formatter</vh>
<v t="leo.20220407205633.115"><vh>ch_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.116"><vh>class aggregate_formatter</vh>
<v t="leo.20220407205633.117"><vh>aggregate_formatter.void add_ch</vh></v>
<v t="leo.20220407205633.118"><vh>aggregate_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.119"><vh>class color_start_formatter</vh>
<v t="leo.20220407205633.120"><vh>color_start_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.121"><vh>class color_stop_formatter</vh>
<v t="leo.20220407205633.122"><vh>color_stop_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.123"><vh>class source_location_formatter</vh>
<v t="leo.20220407205633.124"><vh>source_location_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.125"><vh>class source_filename_formatter</vh>
<v t="leo.20220407205633.126"><vh>source_filename_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.127"><vh>class source_linenum_formatter</vh>
<v t="leo.20220407205633.128"><vh>source_linenum_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.129"><vh>class full_formatter</vh>
<v t="leo.20220407205633.130"><vh>full_formatter.void format</vh></v>
</v>
<v t="leo.20220407205633.131"><vh>class pattern_formatter</vh>
<v t="leo.20220407205633.132"><vh>pattern_formatter.void format</vh></v>
<v t="leo.20220407205633.133"><vh>pattern_formatter.void handle_flag_</vh></v>
<v t="leo.20220407205633.134"><vh>pattern_formatter.void compile_pattern_</vh></v>
</v>
</v>
<v t="leo.20220407205633.135"><vh>@clean periodic_worker.h</vh>
<v t="leo.20220407205633.136"><vh>class periodic_worker</vh></v>
</v>
<v t="leo.20220407205633.137"><vh>@clean registry.h</vh>
<v t="leo.20220407205633.138"><vh>class registry</vh>
<v t="leo.20220407205633.139"><vh>registry.register _logger</vh></v>
<v t="leo.20220407205633.140"><vh>registry.void initialize_logger</vh></v>
<v t="leo.20220407205633.141"><vh>registry.void set_default_logger</vh></v>
<v t="leo.20220407205633.142"><vh>registry.void set_tp</vh></v>
<v t="leo.20220407205633.143"><vh>registry.void set_formatter</vh></v>
<v t="leo.20220407205633.144"><vh>registry.void set_level</vh></v>
<v t="leo.20220407205633.145"><vh>registry.void flush_on</vh></v>
<v t="leo.20220407205633.146"><vh>registry.void flush_every</vh></v>
<v t="leo.20220407205633.147"><vh>registry.void set_error_handler</vh></v>
<v t="leo.20220407205633.148"><vh>registry.void apply_all</vh></v>
<v t="leo.20220407205633.149"><vh>registry.void flush_all</vh></v>
<v t="leo.20220407205633.150"><vh>registry.void drop</vh></v>
<v t="leo.20220407205633.151"><vh>registry.void drop_all</vh></v>
<v t="leo.20220407205633.152"><vh>registry.void shutdown</vh></v>
<v t="leo.20220407205633.153"><vh>registry.void set_automatic_registration</vh></v>
<v t="leo.20220407205633.154"><vh>registry.static registry</vh></v>
<v t="leo.20220407205633.155"><vh>registry.void throw_if_exists_</vh></v>
<v t="leo.20220407205633.156"><vh>registry.register _logger_</vh></v>
</v>
</v>
<v t="leo.20220407205633.157"><vh>@clean thread_pool.h</vh>
<v t="leo.20220407205633.158"><vh>class thread_pool</vh>
<v t="leo.20220407205633.159"><vh>thread_pool.void post_log</vh></v>
<v t="leo.20220407205633.160"><vh>thread_pool.void post_flush</vh></v>
<v t="leo.20220407205633.161"><vh>thread_pool.void post_async_msg_</vh></v>
<v t="leo.20220407205633.162"><vh>thread_pool.void worker_loop_</vh></v>
<v t="leo.20220407205633.163"><vh>thread_pool.bool process_next_msg_</vh></v>
</v>
</v>
</v>
<v t="leo.20220407205633.164"><vh>@path fmt</vh>
<v t="leo.20220407205633.165"><vh>@clean bin_to_hex.h</vh>
<v t="leo.20220407205633.166"><vh>class bytes_range</vh></v>
<v t="leo.20220407205633.167"><vh>auto parse (bin_to_hex.h)</vh></v>
<v t="leo.20220407205633.168"><vh>auto format (bin_to_hex.h)</vh></v>
</v>
<v t="leo.20220407205633.169"><vh>@clean fmt.h</vh></v>
<v t="leo.20220407205633.170"><vh>@clean ostr.h</vh></v>
<v t="leo.20220407205633.171"><vh>@path bundled</vh>
<v t="leo.20220407205633.172"><vh>@clean colors.h</vh></v>
<v t="leo.20220407205633.173"><vh>@clean core.h</vh>
<v t="leo.20220407205633.174"><vh>typedef typename (core.h)</vh></v>
<v t="leo.20220407205633.175"><vh>class basic_string_view</vh>
<v t="leo.20220407205633.176"><vh>basic_string_view.int compare</vh></v>
</v>
<v t="leo.20220407205633.177"><vh>class basic_buffer</vh>
<v t="leo.20220407205633.178"><vh>basic_buffer.void set</vh></v>
<v t="leo.20220407205633.179"><vh>basic_buffer.void resize</vh></v>
<v t="leo.20220407205633.180"><vh>basic_buffer.void reserve</vh></v>
<v t="leo.20220407205633.181"><vh>basic_buffer.void push_back</vh></v>
</v>
<v t="leo.20220407205633.182"><vh>class container_buffer</vh>
<v t="leo.20220407205633.183"><vh>container_buffer.void grow</vh></v>
</v>
<v t="leo.20220407205633.184"><vh>int _type (core.h)</vh></v>
<v t="leo.20220407205633.185"><vh>class value</vh>
<v t="leo.20220407205633.186"><vh>value.static _assert</vh>
<v t="leo.20220407205633.187"><vh>value.static _assert</vh></v>
</v>
<v t="leo.20220407205633.188"><vh>value.const named_arg_base</vh></v>
<v t="leo.20220407205633.189"><vh>value.void format_custom_arg</vh></v>
</v>
<v t="leo.20220407205633.190"><vh>class basic_format_arg</vh>
<v t="leo.20220407205633.191"><vh>class handle</vh></v>
</v>
<v t="leo.20220407205633.192"><vh>class basic_parse_context</vh>
<v t="leo.20220407205633.193"><vh>basic_parse_context.void check_arg_id</vh></v>
</v>
<v t="leo.20220407205633.194"><vh>class arg_map</vh>
<v t="leo.20220407205633.195"><vh>arg_map.void push_back</vh></v>
</v>
<v t="leo.20220407205633.196"><vh>class context_base</vh>
<v t="leo.20220407205633.197"><vh>context_base.int ernal::error_handler</vh></v>
</v>
<v t="leo.20220407205633.198"><vh>class basic_format_context</vh></v>
<v t="leo.20220407205633.199"><vh>typedef basic_format_context (core.h)</vh></v>
<v t="leo.20220407205633.200"><vh>typedef decltype (core.h)</vh></v>
<v t="leo.20220407205633.201"><vh>class format_arg_store</vh></v>
<v t="leo.20220407205633.202"><vh>class basic_format_args</vh>
<v t="leo.20220407205633.203"><vh>basic_format_args.unsigned max_size</vh>
<v t="leo.20220407205633.204"><vh>basic_format_args.signed _types</vh></v>
</v>
</v>
<v t="leo.20220407205633.205"><vh>const String (core.h)</vh></v>
<v t="leo.20220407205633.206"><vh>const Args (core.h)</vh></v>
</v>
<v t="leo.20220407205633.207"><vh>@clean format-inl.h</vh>
<v t="leo.20220407205633.208"><vh>int safe_strerror (format-inl.h)</vh>
<v t="leo.20220407205633.209"><vh>class dispatcher</vh>
<v t="leo.20220407205633.210"><vh>dispatcher.void operator</vh></v>
<v t="leo.20220407205633.211"><vh>dispatcher.int handle</vh></v>
<v t="leo.20220407205633.212"><vh>dispatcher.int handle</vh></v>
<v t="leo.20220407205633.213"><vh>dispatcher.int fallback</vh></v>
<v t="leo.20220407205633.214"><vh>dispatcher.int fallback</vh></v>
<v t="leo.20220407205633.215"><vh>dispatcher.int run</vh></v>
</v>
</v>
<v t="leo.20220407205633.216"><vh>void format_error_code (format-inl.h)</vh></v>
<v t="leo.20220407205633.217"><vh>void report_error (format-inl.h)</vh></v>
<v t="leo.20220407205633.218"><vh>class locale</vh></v>
<v t="leo.20220407205633.219"><vh>int err_code (format-inl.h)</vh></v>
<v t="leo.20220407205633.220"><vh>char _traits (format-inl.h)</vh></v>
<v t="leo.20220407205633.221"><vh>char _traits (format-inl.h)</vh></v>
<v t="leo.20220407205633.222"><vh>const uint32_t (format-inl.h)</vh></v>
<v t="leo.20220407205633.223"><vh>const uint32_t (format-inl.h)</vh></v>
<v t="leo.20220407205633.224"><vh>const uint64_t (format-inl.h)</vh></v>
<v t="leo.20220407205633.225"><vh>const uint64_t (format-inl.h)</vh></v>
<v t="leo.20220407205633.226"><vh>int 16_t (format-inl.h)</vh></v>
<v t="leo.20220407205633.227"><vh>class fp</vh>
<v t="leo.20220407205633.228"><vh>fp.static FMT_CONSTEXPR_DECL</vh></v>
<v t="leo.20220407205633.229"><vh>fp.void normalize</vh></v>
<v t="leo.20220407205633.230"><vh>fp.void compute_boundaries</vh></v>
</v>
<v t="leo.20220407205633.231"><vh>const fp (format-inl.h)</vh></v>
<v t="leo.20220407205633.232"><vh>int digits_to_remove (format-inl.h)</vh></v>
<v t="leo.20220407205633.233"><vh>int precision (format-inl.h)</vh></v>
<v t="leo.20220407205633.234"><vh>int precision (format-inl.h)</vh></v>
<v t="leo.20220407205633.235"><vh>int err_code (format-inl.h)</vh></v>
<v t="leo.20220407205633.236"><vh>int ernal::buffer (format-inl.h)</vh>
<v t="leo.20220407205633.237"><vh>int result (format-inl.h)</vh></v>
</v>
<v t="leo.20220407205633.238"><vh>int ernal::buffer (format-inl.h)</vh></v>
<v t="leo.20220407205633.239"><vh>void basic_fixed_buffer (format-inl.h)</vh></v>
<v t="leo.20220407205633.240"><vh>int error_code (format-inl.h)</vh></v>
<v t="leo.20220407205633.241"><vh>int error_code (format-inl.h)</vh></v>
</v>
<v t="leo.20220407205633.242"><vh>@clean format.h</vh>
<v t="leo.20220407205633.243"><vh>class numeric_limits</vh>
<v t="leo.20220407205633.244"><vh>numeric_limits.bool isinfinity</vh></v>
<v t="leo.20220407205633.245"><vh>numeric_limits.bool isnotanumber</vh></v>
<v t="leo.20220407205633.246"><vh>numeric_limits.bool isnegative</vh></v>
</v>
<v t="leo.20220407205633.247"><vh>class output_range</vh></v>
<v t="leo.20220407205633.248"><vh>class back_insert_range</vh></v>
<v t="leo.20220407205633.249"><vh>class format_error</vh></v>
<v t="leo.20220407205633.250"><vh>void basic_buffer (format.h)</vh></v>
<v t="leo.20220407205633.251"><vh>class u8string_view</vh></v>
<v t="leo.20220407205633.252"><vh>class locale_provider</vh></v>
<v t="leo.20220407205633.253"><vh>class basic_memory_buffer</vh>
<v t="leo.20220407205633.254"><vh>basic_memory_buffer.void deallocate</vh></v>
<v t="leo.20220407205633.255"><vh>basic_memory_buffer.void move</vh></v>
</v>
<v t="leo.20220407205633.256"><vh>void basic_memory_buffer (format.h)</vh></v>
<v t="leo.20220407205633.257"><vh>class basic_fixed_buffer</vh></v>
<v t="leo.20220407205633.258"><vh>class null_terminating_iterator</vh>
<v t="leo.20220407205633.259"><vh>null_terminating_iterator.bool operator</vh></v>
</v>
<v t="leo.20220407205633.260"><vh>class counting_iterator</vh></v>
<v t="leo.20220407205633.261"><vh>class truncating_iterator</vh></v>
<v t="leo.20220407205633.262"><vh>typedef typename (format.h)</vh></v>
<v t="leo.20220407205633.263"><vh>class decimal_formatter</vh>
<v t="leo.20220407205633.264"><vh>decimal_formatter.void write_pair</vh></v>
</v>
<v t="leo.20220407205633.265"><vh>class decimal_formatter_null</vh></v>
<v t="leo.20220407205633.266"><vh>void operator (format.h)</vh></v>
<v t="leo.20220407205633.267"><vh>void operator (format.h)</vh></v>
<v t="leo.20220407205633.268"><vh>bool upper (format.h)</vh></v>
<v t="leo.20220407205633.269"><vh>bool upper (format.h)</vh></v>
<v t="leo.20220407205633.270"><vh>class utf8_to_utf16</vh></v>
<v t="leo.20220407205633.271"><vh>class utf16_to_utf8</vh></v>
<v t="leo.20220407205633.272"><vh>class format_spec</vh></v>
<v t="leo.20220407205633.273"><vh>class fill_spec</vh></v>
<v t="leo.20220407205633.274"><vh>class basic_format_specs</vh></v>
<v t="leo.20220407205633.275"><vh>const basic_format_specs (format.h)</vh></v>
<v t="leo.20220407205633.276"><vh>class int_type_checker</vh></v>
<v t="leo.20220407205633.277"><vh>class float_type_checker</vh></v>
<v t="leo.20220407205633.278"><vh>class char_specs_checker</vh></v>
<v t="leo.20220407205633.279"><vh>class cstring_type_checker</vh></v>
<v t="leo.20220407205633.280"><vh>void arg_map (format.h)</vh></v>
<v t="leo.20220407205633.281"><vh>class arg_formatter_base</vh>
<v t="leo.20220407205633.282"><vh>arg_formatter_base.void write_char</vh></v>
<v t="leo.20220407205633.283"><vh>arg_formatter_base.void write_pointer</vh></v>
<v t="leo.20220407205633.284"><vh>arg_formatter_base.void write</vh></v>
<v t="leo.20220407205633.285"><vh>arg_formatter_base.void write</vh></v>
<v t="leo.20220407205633.286"><vh>arg_formatter_base.char _spec_handler</vh></v>
<v t="leo.20220407205633.287"><vh>arg_formatter_base.int ernal::handle_cstring_type_spec</vh>
<v t="leo.20220407205633.288"><vh>arg_formatter_base.int ernal::check_string_type_spec</vh></v>
</v>
</v>
<v t="leo.20220407205633.289"><vh>const Char (format.h)</vh></v>
<v t="leo.20220407205633.290"><vh>class custom_formatter</vh>
<v t="leo.20220407205633.291"><vh>custom_formatter.bool operator</vh></v>
</v>
<v t="leo.20220407205633.292"><vh>class width_checker</vh></v>
<v t="leo.20220407205633.293"><vh>class precision_checker</vh></v>
<v t="leo.20220407205633.294"><vh>class specs_setter</vh></v>
<v t="leo.20220407205633.295"><vh>class specs_checker</vh></v>
<v t="leo.20220407205633.296"><vh>class specs_handler</vh>
<v t="leo.20220407205633.297"><vh>specs_handler.void on_error</vh></v>
</v>
<v t="leo.20220407205633.298"><vh>class dynamic_specs_handler</vh></v>
<v t="leo.20220407205633.299"><vh>const Char (format.h)</vh></v>
<v t="leo.20220407205633.300"><vh>const char *first, const char *last, char value, const char *&amp;out) { (format.h)</vh></v>
<v t="leo.20220407205633.301"><vh>class format_string_checker</vh></v>
<v t="leo.20220407205633.302"><vh>void handle_dynamic_spec (format.h)</vh></v>
<v t="leo.20220407205633.303"><vh>class arg_formatter</vh></v>
<v t="leo.20220407205633.304"><vh>class system_error</vh></v>
<v t="leo.20220407205633.305"><vh>class basic_writer</vh>
<v t="leo.20220407205633.306"><vh>basic_writer.auto reserve</vh></v>
<v t="leo.20220407205633.307"><vh>basic_writer.void operator</vh></v>
<v t="leo.20220407205633.308"><vh>basic_writer.void write_int</vh></v>
<v t="leo.20220407205633.309"><vh>basic_writer.void write_decimal</vh></v>
<v t="leo.20220407205633.310"><vh>basic_writer.unsigned count_digits</vh></v>
<v t="leo.20220407205633.311"><vh>basic_writer.int _writer</vh></v>
<v t="leo.20220407205633.312"><vh>basic_writer.void operator</vh></v>
<v t="leo.20220407205633.313"><vh>basic_writer.void on_dec</vh></v>
<v t="leo.20220407205633.314"><vh>basic_writer.void operator</vh></v>
<v t="leo.20220407205633.315"><vh>basic_writer.void on_hex</vh></v>
<v t="leo.20220407205633.316"><vh>basic_writer.void operator</vh></v>
<v t="leo.20220407205633.317"><vh>basic_writer.void on_bin</vh></v>
<v t="leo.20220407205633.318"><vh>basic_writer.void on_oct</vh></v>
<v t="leo.20220407205633.319"><vh>basic_writer.void operator</vh></v>
<v t="leo.20220407205633.320"><vh>basic_writer.void on_num</vh></v>
<v t="leo.20220407205633.321"><vh>basic_writer.void on_error</vh></v>
<v t="leo.20220407205633.322"><vh>basic_writer.void write_int</vh>
<v t="leo.20220407205633.323"><vh>basic_writer.int ernal::handle_int_type_spec</vh></v>
<v t="leo.20220407205633.324"><vh>basic_writer.void operator</vh></v>
</v>
<v t="leo.20220407205633.325"><vh>basic_writer.void operator</vh></v>
<v t="leo.20220407205633.326"><vh>basic_writer.void write_double_sprintf</vh>
<v t="leo.20220407205633.327"><vh>basic_writer.void operator</vh></v>
</v>
<v t="leo.20220407205633.328"><vh>basic_writer.void write_str</vh></v>
<v t="leo.20220407205633.329"><vh>basic_writer.void append_float_length</vh></v>
<v t="leo.20220407205633.330"><vh>basic_writer.void write</vh></v>
<v t="leo.20220407205633.331"><vh>basic_writer.void write</vh></v>
<v t="leo.20220407205633.332"><vh>basic_writer.void write</vh></v>
<v t="leo.20220407205633.333"><vh>basic_writer.void write</vh></v>
<v t="leo.20220407205633.334"><vh>basic_writer.void write</vh></v>
<v t="leo.20220407205633.335"><vh>basic_writer.void write</vh></v>
<v t="leo.20220407205633.336"><vh>basic_writer.void write</vh></v>
</v>
<v t="leo.20220407205633.337"><vh>void basic_writer (format.h)</vh></v>
<v t="leo.20220407205633.338"><vh>void basic_writer (format.h)</vh></v>
<v t="leo.20220407205633.339"><vh>void on_general (format.h)</vh></v>
<v t="leo.20220407205633.340"><vh>void on_exp (format.h)</vh></v>
<v t="leo.20220407205633.341"><vh>void on_fixed (format.h)</vh></v>
<v t="leo.20220407205633.342"><vh>void on_hex (format.h)</vh></v>
<v t="leo.20220407205633.343"><vh>void on_error (format.h)</vh></v>
<v t="leo.20220407205633.344"><vh>void basic_writer (format.h)</vh>
<v t="leo.20220407205633.345"><vh>void operator (format.h)</vh></v>
<v t="leo.20220407205633.346"><vh>int ernal::use_grisu (format.h)</vh></v>
</v>
<v t="leo.20220407205633.347"><vh>void basic_writer (format.h)</vh>
<v t="leo.20220407205633.348"><vh>int result (format.h)</vh></v>
</v>
<v t="leo.20220407205633.349"><vh>class windows_error</vh></v>
<v t="leo.20220407205633.350"><vh>class format_int</vh>
<v t="leo.20220407205633.351"><vh>format_int.void format_signed</vh></v>
<v t="leo.20220407205633.352"><vh>format_int.const char *c_str() const {</vh></v>
</v>
<v t="leo.20220407205633.353"><vh>auto type (format.h)</vh></v>
<v t="leo.20220407205633.354"><vh>auto format (format.h)</vh></v>
<v t="leo.20220407205633.355"><vh>class dynamic_formatter</vh>
<v t="leo.20220407205633.356"><vh>dynamic_formatter.void on_align</vh></v>
<v t="leo.20220407205633.357"><vh>dynamic_formatter.auto format</vh>
<v t="leo.20220407205633.358"><vh>dynamic_formatter.int ernal::specs_checker</vh></v>
<v t="leo.20220407205633.359"><vh>dynamic_formatter.typedef output_range</vh></v>
</v>
</v>
<v t="leo.20220407205633.360"><vh>void on_text (format.h)</vh></v>
<v t="leo.20220407205633.361"><vh>void on_arg_id (format.h)</vh></v>
<v t="leo.20220407205633.362"><vh>void on_arg_id (format.h)</vh></v>
<v t="leo.20220407205633.363"><vh>void on_replacement_field (format.h)</vh></v>
<v t="leo.20220407205633.364"><vh>auto format (format.h)</vh></v>
<v t="leo.20220407205633.365"><vh>auto join (format.h)</vh></v>
<v t="leo.20220407205633.366"><vh>auto join (format.h)</vh></v>
<v t="leo.20220407205633.367"><vh>int ernal::buffer (format.h)</vh></v>
<v t="leo.20220407205633.368"><vh>int ernal::wbuffer (format.h)</vh></v>
<v t="leo.20220407205633.369"><vh>const Args (format.h)</vh></v>
<v t="leo.20220407205633.370"><vh>typedef basic_format_args (format.h)</vh></v>
<v t="leo.20220407205633.371"><vh>const Args (format.h)</vh></v>
<v t="leo.20220407205633.372"><vh>const Args (format.h)</vh>
<v t="leo.20220407205633.373"><vh>auto it (format.h)</vh></v>
</v>
<v t="leo.20220407205633.374"><vh>const Args (format.h)</vh></v>
<v t="leo.20220407205633.375"><vh>class udl_formatter</vh></v>
<v t="leo.20220407205633.376"><vh>auto operator (format.h)</vh></v>
</v>
<v t="leo.20220407205633.377"><vh>@clean ostream.h</vh>
<v t="leo.20220407205633.378"><vh>class formatbuf</vh>
<v t="leo.20220407205633.379"><vh>formatbuf.int _type</vh></v>
</v>
<v t="leo.20220407205633.380"><vh>class is_streamable</vh></v>
<v t="leo.20220407205633.381"><vh>void write (ostream.h)</vh></v>
<v t="leo.20220407205633.382"><vh>void format_value (ostream.h)</vh></v>
<v t="leo.20220407205633.383"><vh>auto format (ostream.h)</vh></v>
<v t="leo.20220407205633.384"><vh>const Args (ostream.h)</vh></v>
<v t="leo.20220407205633.385"><vh>const Args (ostream.h)</vh></v>
</v>
<v t="leo.20220407205633.386"><vh>@clean posix.h</vh>
<v t="leo.20220407205633.387"><vh>class basic_cstring_view</vh></v>
<v t="leo.20220407205633.388"><vh>class error_code</vh></v>
<v t="leo.20220407205633.389"><vh>class buffered_file</vh>
<v t="leo.20220407205633.390"><vh>buffered_file.void vprint</vh></v>
</v>
<v t="leo.20220407205633.391"><vh>class file</vh></v>
<v t="leo.20220407205633.392"><vh>class Locale</vh>
<v t="leo.20220407205633.393"><vh>Locale.static locale_t</vh></v>
<v t="leo.20220407205633.394"><vh>Locale.void freelocale</vh></v>
<v t="leo.20220407205633.395"><vh>Locale.double strtod_l</vh></v>
<v t="leo.20220407205633.396"><vh>Locale.double strtod</vh></v>
</v>
</v>
<v t="leo.20220407205633.397"><vh>@clean printf.h</vh>
<v t="leo.20220407205633.398"><vh>bool fits_in_int (printf.h)</vh></v>
<v t="leo.20220407205633.399"><vh>bool fits_in_int (printf.h)</vh></v>
<v t="leo.20220407205633.400"><vh>class printf_precision_handler</vh></v>
<v t="leo.20220407205633.401"><vh>class is_zero_int</vh></v>
<v t="leo.20220407205633.402"><vh>class arg_converter</vh>
<v t="leo.20220407205633.403"><vh>arg_converter.void operator</vh></v>
<v t="leo.20220407205633.404"><vh>arg_converter.typedef typename</vh></v>
</v>
<v t="leo.20220407205633.405"><vh>void convert_arg (printf.h)</vh></v>
<v t="leo.20220407205633.406"><vh>class char_converter</vh></v>
<v t="leo.20220407205633.407"><vh>class printf_width_handler</vh></v>
<v t="leo.20220407205633.408"><vh>class printf_arg_formatter</vh>
<v t="leo.20220407205633.409"><vh>printf_arg_formatter.void write_null_pointer</vh></v>
<v t="leo.20220407205633.410"><vh>printf_arg_formatter.void write_null_pointer</vh></v>
</v>
<v t="leo.20220407205633.411"><vh>auto format (printf.h)</vh></v>
<v t="leo.20220407205633.412"><vh>class basic_printf_context</vh></v>
<v t="leo.20220407205633.413"><vh>void basic_printf_context (printf.h)</vh></v>
<v t="leo.20220407205633.414"><vh>unsigned basic_printf_context (printf.h)</vh></v>
<v t="leo.20220407205633.415"><vh>void basic_printf_context (printf.h)</vh></v>
<v t="leo.20220407205633.416"><vh>void printf (printf.h)</vh></v>
<v t="leo.20220407205633.417"><vh>typedef basic_printf_context (printf.h)</vh></v>
<v t="leo.20220407205633.418"><vh>int ernal::basic_buffer (printf.h)</vh></v>
<v t="leo.20220407205633.419"><vh>auto vargs (printf.h)</vh></v>
<v t="leo.20220407205633.420"><vh>const Args (printf.h)</vh>
<v t="leo.20220407205633.421"><vh>auto vargs (printf.h)</vh></v>
</v>
</v>
<v t="leo.20220407205633.422"><vh>@clean ranges.h</vh>
<v t="leo.20220407205633.423"><vh>void copy (ranges.h)</vh></v>
<v t="leo.20220407205633.424"><vh>void copy (ranges.h)</vh></v>
<v t="leo.20220407205633.425"><vh>void copy (ranges.h)</vh></v>
<v t="leo.20220407205633.426"><vh>class is_like_std_string</vh></v>
<v t="leo.20220407205633.427"><vh>class is_tuple_like_</vh></v>
<v t="leo.20220407205633.428"><vh>static FMT_CONSTEXPR (ranges.h)</vh></v>
<v t="leo.20220407205633.429"><vh>void for_each (ranges.h)</vh></v>
<v t="leo.20220407205633.430"><vh>void for_each (ranges.h)</vh></v>
<v t="leo.20220407205633.431"><vh>static FMT_CONSTEXPR_DECL (ranges.h)</vh></v>
<v t="leo.20220407205633.432"><vh>void operator (ranges.h)</vh></v>
<v t="leo.20220407205633.433"><vh>auto format (ranges.h)</vh></v>
<v t="leo.20220407205633.434"><vh>static FMT_CONSTEXPR_DECL (ranges.h)</vh></v>
<v t="leo.20220407205633.435"><vh>const RangeT (ranges.h)</vh>
<v t="leo.20220407205633.436"><vh>int ernal::format_str_quoted (ranges.h)</vh></v>
</v>
</v>
<v t="leo.20220407205633.437"><vh>@clean time.h</vh>
<v t="leo.20220407205633.438"><vh>bool run (time.h)</vh></v>
<v t="leo.20220407205633.439"><vh>bool handle (time.h)</vh></v>
<v t="leo.20220407205633.440"><vh>bool fallback (time.h)</vh></v>
<v t="leo.20220407205633.441"><vh>bool run (time.h)</vh></v>
<v t="leo.20220407205633.442"><vh>bool handle (time.h)</vh></v>
<v t="leo.20220407205633.443"><vh>bool fallback (time.h)</vh></v>
<v t="leo.20220407205633.444"><vh>const std::tm (time.h)</vh></v>
<v t="leo.20220407205633.445"><vh>const wchar_t (time.h)</vh></v>
<v t="leo.20220407205633.446"><vh>auto parse (time.h)</vh></v>
<v t="leo.20220407205633.447"><vh>auto format (time.h)</vh></v>
</v>
</v>
</v>
<v t="leo.20220407205633.448"><vh>@path sinks</vh>
<v t="leo.20220407205633.449"><vh>@clean android_sink.h</vh>
<v t="leo.20220407205633.450"><vh>class android_sink</vh>
<v t="leo.20220407205633.451"><vh>android_sink.void sink_it_</vh></v>
<v t="leo.20220407205633.452"><vh>android_sink.void flush_</vh></v>
</v>
</v>
<v t="leo.20220407205633.453"><vh>@clean ansicolor_sink.h</vh>
<v t="leo.20220407205633.454"><vh>class ansicolor_sink</vh>
<v t="leo.20220407205633.455"><vh>ansicolor_sink.void set_color</vh></v>
<v t="leo.20220407205633.456"><vh>ansicolor_sink.void log</vh></v>
<v t="leo.20220407205633.457"><vh>ansicolor_sink.void flush</vh></v>
<v t="leo.20220407205633.458"><vh>ansicolor_sink.void set_pattern</vh></v>
<v t="leo.20220407205633.459"><vh>ansicolor_sink.void set_formatter</vh></v>
<v t="leo.20220407205633.460"><vh>ansicolor_sink.void print_ccode_</vh></v>
<v t="leo.20220407205633.461"><vh>ansicolor_sink.void print_range_</vh></v>
</v>
</v>
<v t="leo.20220407205633.462"><vh>@clean base_sink.h</vh>
<v t="leo.20220407205633.463"><vh>class base_sink</vh>
<v t="leo.20220407205633.464"><vh>base_sink.void log</vh></v>
<v t="leo.20220407205633.465"><vh>base_sink.void flush</vh></v>
<v t="leo.20220407205633.466"><vh>base_sink.void set_pattern</vh></v>
<v t="leo.20220407205633.467"><vh>base_sink.void set_formatter</vh></v>
</v>
</v>
<v t="leo.20220407205633.468"><vh>@clean basic_file_sink.h</vh>
<v t="leo.20220407205633.469"><vh>class basic_file_sink</vh>
<v t="leo.20220407205633.470"><vh>basic_file_sink.void sink_it_</vh></v>
<v t="leo.20220407205633.471"><vh>basic_file_sink.void flush_</vh></v>
</v>
</v>
<v t="leo.20220407205633.472"><vh>@clean daily_file_sink.h</vh>
<v t="leo.20220407205633.473"><vh>static filename_t (daily_file_sink.h)</vh></v>
<v t="leo.20220407205633.474"><vh>class daily_file_sink</vh>
<v t="leo.20220407205633.475"><vh>daily_file_sink.void sink_it_</vh></v>
<v t="leo.20220407205633.476"><vh>daily_file_sink.void flush_</vh></v>
</v>
<v t="leo.20220407205633.477"><vh>const std::string (daily_file_sink.h)</vh></v>
<v t="leo.20220407205633.478"><vh>const std::string (daily_file_sink.h)</vh></v>
</v>
<v t="leo.20220407205633.479"><vh>@clean dist_sink.h</vh>
<v t="leo.20220407205633.480"><vh>class dist_sink</vh>
<v t="leo.20220407205633.481"><vh>dist_sink.void add_sink</vh></v>
<v t="leo.20220407205633.482"><vh>dist_sink.void remove_sink</vh></v>
<v t="leo.20220407205633.483"><vh>dist_sink.void set_sinks</vh></v>
<v t="leo.20220407205633.484"><vh>dist_sink.void sink_it_</vh></v>
<v t="leo.20220407205633.485"><vh>dist_sink.void flush_</vh></v>
<v t="leo.20220407205633.486"><vh>dist_sink.void set_pattern_</vh></v>
<v t="leo.20220407205633.487"><vh>dist_sink.void set_formatter_</vh></v>
</v>
</v>
<v t="leo.20220407205634.1"><vh>@clean msvc_sink.h</vh>
<v t="leo.20220407205634.2"><vh>class msvc_sink</vh>
<v t="leo.20220407205634.3"><vh>msvc_sink.void sink_it_</vh></v>
</v>
</v>
<v t="leo.20220407205634.4"><vh>@clean null_sink.h</vh>
<v t="leo.20220407205634.5"><vh>class null_sink</vh></v>
</v>
<v t="leo.20220407205634.6"><vh>@clean ostream_sink.h</vh>
<v t="leo.20220407205634.7"><vh>class ostream_sink</vh>
<v t="leo.20220407205634.8"><vh>ostream_sink.void sink_it_</vh></v>
<v t="leo.20220407205634.9"><vh>ostream_sink.void flush_</vh></v>
</v>
</v>
<v t="leo.20220407205634.10"><vh>@clean rotating_file_sink.h</vh>
<v t="leo.20220407205634.11"><vh>class rotating_file_sink</vh>
<v t="leo.20220407205634.12"><vh>rotating_file_sink.static filename_t</vh></v>
<v t="leo.20220407205634.13"><vh>rotating_file_sink.void sink_it_</vh></v>
<v t="leo.20220407205634.14"><vh>rotating_file_sink.void flush_</vh></v>
<v t="leo.20220407205634.15"><vh>rotating_file_sink.void rotate_</vh></v>
<v t="leo.20220407205634.16"><vh>rotating_file_sink.bool rename_file</vh></v>
</v>
<v t="leo.20220407205634.17"><vh>const std::string (rotating_file_sink.h)</vh></v>
<v t="leo.20220407205634.18"><vh>const std::string (rotating_file_sink.h)</vh></v>
</v>
<v t="leo.20220407205634.19"><vh>@clean sink.h</vh>
<v t="leo.20220407205634.20"><vh>class sink</vh>
<v t="leo.20220407205634.21"><vh>sink.bool should_log</vh></v>
<v t="leo.20220407205634.22"><vh>sink.void set_level</vh></v>
</v>
</v>
<v t="leo.20220407205634.23"><vh>@clean stdout_color_sinks.h</vh></v>
<v t="leo.20220407205634.24"><vh>@clean stdout_sinks.h</vh>
<v t="leo.20220407205634.25"><vh>class stdout_sink</vh>
<v t="leo.20220407205634.26"><vh>stdout_sink.void log</vh></v>
<v t="leo.20220407205634.27"><vh>stdout_sink.void flush</vh></v>
<v t="leo.20220407205634.28"><vh>stdout_sink.void set_pattern</vh></v>
<v t="leo.20220407205634.29"><vh>stdout_sink.void set_formatter</vh></v>
</v>
</v>
<v t="leo.20220407205634.30"><vh>@clean syslog_sink.h</vh>
<v t="leo.20220407205634.31"><vh>class syslog_sink</vh>
<v t="leo.20220407205634.32"><vh>syslog_sink.void sink_it_</vh></v>
<v t="leo.20220407205634.33"><vh>syslog_sink.int syslog_prio_from_level</vh></v>
</v>
<v t="leo.20220407205634.34"><vh>const std::string (syslog_sink.h)</vh></v>
<v t="leo.20220407205634.35"><vh>const std::string (syslog_sink.h)</vh></v>
</v>
<v t="leo.20220407205634.36"><vh>@clean wincolor_sink.h</vh>
<v t="leo.20220407205634.37"><vh>class wincolor_sink</vh>
<v t="leo.20220407205634.38"><vh>wincolor_sink.void set_color</vh></v>
<v t="leo.20220407205634.39"><vh>wincolor_sink.void log</vh></v>
<v t="leo.20220407205634.40"><vh>wincolor_sink.void flush</vh></v>
<v t="leo.20220407205634.41"><vh>wincolor_sink.void set_pattern</vh></v>
<v t="leo.20220407205634.42"><vh>wincolor_sink.void set_formatter</vh></v>
<v t="leo.20220407205634.43"><vh>wincolor_sink.void print_range_</vh></v>
</v>
</v>
</v>
</v>
<v t="leo.20220407205634.44"><vh>@path src</vh>
<v t="leo.20220407205634.45"><vh>@clean Extruder.cpp</vh>
<v t="leo.20220407205634.46"><vh>void Extruder::SetInitialTransformation (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.47"><vh>void Extruder::CalculateWorldPoint (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.48"><vh>void Extruder::CalculateWorldPoint (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.49"><vh>void Extruder::CalculateRealPoint (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.50"><vh>void Extruder::SetFilamentType (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.51"><vh>int Extruder::GetFilamentType (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.52"><vh>void Extruder::SetFilamentColor (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.53"><vh>float * Extruder::GetFilamentColor() (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.54"><vh>void Extruder::SetFilamentSize (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.55"><vh>float Extruder::GetFilamentSize (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.56"><vh>void Extruder::SetFilamentResolution (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.57"><vh>float Extruder::GetFilamentResolution (Extruder.cpp)</vh></v>
<v t="leo.20220407205634.58"><vh>void Extruder::PaintInfo (Extruder.cpp)</vh></v>
</v>
<v t="leo.20220407205634.59"><vh>@clean Listener.cpp</vh>
<v t="leo.20220407205634.60"><vh>void Listener::Deserialize (Listener.cpp)</vh></v>
<v t="leo.20220407205634.61"><vh>void Listener::PushAction (Listener.cpp)</vh></v>
<v t="leo.20220407205634.62"><vh>void Listener::PullCurrentPosition (Listener.cpp)</vh></v>
<v t="leo.20220407205634.63"><vh>void Listener::Interpret (Listener.cpp)</vh></v>
</v>
<v t="leo.20220407205634.64"><vh>@clean Path.cpp</vh>
<v t="leo.20220407205634.65"><vh>void Path::SetLinearPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.66"><vh>void Path::SetArcPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.67"><vh>void Path::SetArcPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.68"><vh>void Path::SetCirclePath (Path.cpp)</vh></v>
<v t="leo.20220407205634.69"><vh>void Path::SetBCPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.70"><vh>double Path::get_path_length (Path.cpp)</vh></v>
<v t="leo.20220407205634.71"><vh>double Path::get_bc_path_length (Path.cpp)</vh></v>
<v t="leo.20220407205634.72"><vh>void Path::GetLinearPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.73"><vh>void Path::GetArcPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.74"><vh>void Path::GetArcPath (Path.cpp)</vh></v>
<v t="leo.20220407205634.75"><vh>void Path::GetBCPath (Path.cpp)</vh></v>
</v>
<v t="leo.20220407205634.76"><vh>@clean Printer.cpp</vh>
<v t="leo.20220407205634.77"><vh>void Printer::set_cur_pos (Printer.cpp)</vh></v>
</v>
<v t="leo.20220407205634.78"><vh>@clean Server.cpp</vh>
<v t="leo.20220407205634.79"><vh>void SessionEcho::start (Server.cpp)</vh></v>
<v t="leo.20220407205634.80"><vh>void SessionEcho::handle_read (Server.cpp)</vh></v>
<v t="leo.20220407205634.81"><vh>void SessionEcho::handle_write (Server.cpp)</vh></v>
<v t="leo.20220407205634.82"><vh>void SessionSend::deliver (Server.cpp)</vh></v>
<v t="leo.20220407205634.83"><vh>void SessionSend::write (Server.cpp)</vh></v>
<v t="leo.20220407205634.84"><vh>void SessionSend::handle_write (Server.cpp)</vh></v>
<v t="leo.20220407205634.85"><vh>void Server::start_accept (Server.cpp)</vh></v>
<v t="leo.20220407205634.86"><vh>void Server::handle_accept_echo (Server.cpp)</vh></v>
<v t="leo.20220407205634.87"><vh>void Server::handle_accept_send (Server.cpp)</vh></v>
<v t="leo.20220407205634.88"><vh>void Server::broadcast (Server.cpp)</vh></v>
<v t="leo.20220407205634.89"><vh>void Server::cancel_sessions (Server.cpp)</vh></v>
<v t="leo.20220407205634.90"><vh>void CommunicationManager::LaunchServer (Server.cpp)</vh></v>
<v t="leo.20220407205634.91"><vh>void CommunicationManager::StopServer (Server.cpp)</vh></v>
</v>
<v t="leo.20220407205634.92"><vh>@clean Speaker.cpp</vh>
<v t="leo.20220407205634.93"><vh>void Speaker::Formulate (Speaker.cpp)</vh></v>
<v t="leo.20220407205634.94"><vh>int Speaker::NumberMessages (Speaker.cpp)</vh></v>
</v>
<v t="leo.20220407205634.95"><vh>@clean Trajectory.cpp</vh>
<v t="leo.20220407205634.96"><vh>void Trajectory::RapidTrajectory (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.97"><vh>void Trajectory::LinearTrajectory (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.98"><vh>void Trajectory::ArcTrajectory (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.99"><vh>void Trajectory::ArcTrajectory (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.100"><vh>void Trajectory::CircleTrajectory (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.101"><vh>void Trajectory::Dwell (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.102"><vh>void Trajectory::GetTrajectory (Trajectory.cpp)</vh></v>
<v t="leo.20220407205634.103"><vh>void Trajectory::vector_split (Trajectory.cpp)</vh></v>
</v>
<v t="leo.20220407205634.104"><vh>@clean VelocityProfile.cpp</vh>
<v t="leo.20220407205634.105"><vh>void VelocityProfile::SetRampProfile (VelocityProfile.cpp)</vh></v>
<v t="leo.20220407205634.106"><vh>void VelocityProfile::SetInterpolationProfile (VelocityProfile.cpp)</vh></v>
<v t="leo.20220407205634.107"><vh>void VelocityProfile::GetProfile (VelocityProfile.cpp)</vh></v>
<v t="leo.20220407205634.108"><vh>bool VelocityProfile::quadroots (VelocityProfile.cpp)</vh></v>
</v>
<v t="leo.20220407205634.109"><vh>@clean string_concurrent_queue.cpp</vh>
<v t="leo.20220407205634.110"><vh>int StringConcurrentQueue::size (string_concurrent_queue.cpp)</vh></v>
<v t="leo.20220407205634.111"><vh>bool StringConcurrentQueue::empty (string_concurrent_queue.cpp)</vh></v>
<v t="leo.20220407205634.112"><vh>void StringConcurrentQueue::clear (string_concurrent_queue.cpp)</vh></v>
<v t="leo.20220407205634.113"><vh>void StringConcurrentQueue::push_front (string_concurrent_queue.cpp)</vh></v>
<v t="leo.20220407205634.114"><vh>void StringConcurrentQueue::push_back (string_concurrent_queue.cpp)</vh></v>
<v t="leo.20220407205634.115"><vh>void StringConcurrentQueue::pop_back (string_concurrent_queue.cpp)</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20220407205015.2">c.recursiveImport(
    dir_ = r'./',
    kind = '@clean', 
    safe_at_file = False,
    theTypes =  ['.cpp', '.h']
)
</t>
<t tx="leo.20220407205046.1"></t>
<t tx="leo.20220407205046.2">QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;'CherryPy', 'pytz', 'mako', 'beautifulsoup4', 'pymysql', 'peewee'
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 20px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20220407205046.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20220407205631.1"></t>
<t tx="leo.20220407205631.100">bool CSocketInConnection::replyToReceivedData(char* data,int dataSize)
{
    if (!_socketConnectWasOk)
        return(false);
    if (dataSize==0)
        return(false);

    // In Following we make sure we don't send too big packets (we might send the data in several packets)
    int packetCount=0;
    int s=dataSize;
    while (s!=0)
    {
        packetCount++;
        if (s&gt;_maxPacketSize-HEADER_LENGTH)
            s-=_maxPacketSize-HEADER_LENGTH;
        else
            s=0;
    }

    s=dataSize;
    int ptr=0;
    while (s!=0)
    {
        packetCount--;
        int sizeToSend=s;
        if (s&gt;_maxPacketSize-HEADER_LENGTH)
            sizeToSend=_maxPacketSize-HEADER_LENGTH;
        s-=sizeToSend;
        if (!_sendSimplePacket(data+ptr,sizeToSend,packetCount))
            return(false);
        ptr+=sizeToSend;
    }
    return(true);
}

std::string CSocketInConnection::getConnectedMachineIP()
{
    if (!_socketConnectWasOk)
        return("NONE (reception line is not open)");
    return(_socketConnectedMachineIP);
}

</t>
<t tx="leo.20220407205631.101">bool CSocketInConnection::_sendSimplePacket(char* packet,int packetLength,unsigned short packetsLeft)
{
    if (packetLength==0)
        return(false);

    // Insert the header:
    unsigned short s=(unsigned short)packetLength;
    char header[HEADER_LENGTH];
    header[0]=_headerByte1;
    header[1]=_headerByte2;
    ((unsigned short*)(header+2))[0]=s;
    ((unsigned short*)(header+2))[1]=packetsLeft;

    std::vector&lt;char&gt; toSend;
    for (int i=0;i&lt;HEADER_LENGTH;i++)
        toSend.push_back(header[i]);
    for (int i=0;i&lt;packetLength;i++)
        toSend.push_back(packet[i]);
    // Send the packet:
    return(send(_socketClient,&amp;toSend[0],packetLength+HEADER_LENGTH,0)==packetLength+HEADER_LENGTH);
}

</t>
<t tx="leo.20220407205631.102">int CSocketInConnection::_receiveSimplePacket(std::vector&lt;char&gt;&amp; packet)
{
    // Returns the number of packets left to read if &gt;=0, -2=error, -1=select time out
    FD_ZERO(&amp;_socketTheSet);
    FD_SET(_socketClient,&amp;_socketTheSet);
#ifdef _WIN32
    int selectResult=select(0,&amp;_socketTheSet,NULL,NULL,NULL); // No timeout!
#endif /* _WIN32 */
#if defined (__linux) || defined (__APPLE__)
    int selectResult=select(_socketClient+1, &amp;_socketTheSet,NULL,NULL,NULL); // No timeout!
#endif /* __linux || __APPLE__ */
    if (selectResult==1)
    {
        //1. Read the header and packet size:
        char headerAndSize[HEADER_LENGTH];
        int totalReceived=0;
        unsigned int startT=_getTimeInMs();
        while(totalReceived!=HEADER_LENGTH)
        {
            int nb=recv(_socketClient,headerAndSize+totalReceived,HEADER_LENGTH-totalReceived,0);
            if (nb&lt;1)
                break;
            totalReceived+=nb;
            if (_getTimeDiffInMs(startT)&gt;3000)
                break;
        }
        // 2. Check if the header is consistent:
        if (totalReceived!=HEADER_LENGTH)
            return(-2); // Error reading
        if ( (headerAndSize[0]!=_headerByte1)||(headerAndSize[1]!=_headerByte2) )
            return(-2); // Error, wrong header
        unsigned short dataLength=((unsigned short*)(headerAndSize+2))[0];
        // 3. Read the data with correct length:
        packet.clear();
        packet.resize(dataLength,0);
        totalReceived=0;
        startT=_getTimeInMs();
        while(totalReceived!=dataLength)
        {
            int nb=recv(_socketClient,&amp;packet[0]+totalReceived,dataLength-totalReceived,0);
            if (nb&lt;1)
                break;
            totalReceived+=nb;
            if (_getTimeDiffInMs(startT)&gt;3000)
                break;
        }
        if (totalReceived!=dataLength)
            return(-2); // wrong size or nothing received
        return(int(((unsigned short*)(headerAndSize+2))[1]));
    }
    if (selectResult==0)
        return(-1);
    return(-2);
}

#ifdef _WIN32
</t>
<t tx="leo.20220407205631.103">unsigned int CSocketInConnection::_getTimeInMs(void)
{
    return(timeGetTime()&amp;0x03ffffff);
}
#endif /* _WIN32 */

#if defined (__linux) || defined (__APPLE__)
</t>
<t tx="leo.20220407205631.104">unsigned int CSocketInConnection::_getTimeInMs(void)
{
    struct timeval tv;
    unsigned int result=0;
    if (gettimeofday(&amp;tv,NULL)==0)
        result=(tv.tv_sec*1000+tv.tv_usec/1000)&amp;0x03ffffff;
    return(result);
}
#endif /* __linux || __APPLE__ */

</t>
<t tx="leo.20220407205631.105">unsigned int CSocketInConnection::_getTimeDiffInMs(unsigned int lastTime)
{
    unsigned int currentTime=_getTimeInMs();
    if (currentTime&lt;lastTime)
        return(currentTime+0x03ffffff-lastTime);
    return(currentTime-lastTime);
}
</t>
<t tx="leo.20220407205631.106">@path ./v-rep_plugin/coppelia/common/
#include "socketOutConnection.h"

#define HEADER_LENGTH 6 // byte1=id1, byte2=id2, byte3+byte4=packetSize, byte5+byte6=packetsLeftToRead

CSocketOutConnection::CSocketOutConnection(const char* theConnectionAddress,int theConnectionPort,unsigned short maxPacketSize/*=250*/,char headerID1/*=59*/,char headerID2/*=57*/)
{
    _socketConnectionAddress=theConnectionAddress;
    _socketConnectionPort=theConnectionPort;
    _socketConn=-1;
    _headerByte1=headerID1;
    _headerByte2=headerID2;
    _maxPacketSize=maxPacketSize;
}

CSocketOutConnection::~CSocketOutConnection()
{
    if (_socketConn!=(SOCKET)-1)
    {
    #ifdef _WIN32
        closesocket(_socketConn);
        WSACleanup();
    #elif defined (__linux) || defined (__APPLE__)
        close(_socketConn);
    #endif
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.107">int CSocketOutConnection::connectToServer()
{ // return 1: success
#ifdef _WIN32
    if (WSAStartup(0x101,&amp;_socketWsaData)!=0)
        return(0);
#endif
    _socketConn=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
    if(_socketConn==INVALID_SOCKET)
    {
#ifdef _WIN32
        WSACleanup();
#endif
        return(0);
    }
    _socketServer.sin_addr.s_addr=inet_addr(_socketConnectionAddress.c_str());

    _socketServer.sin_family=AF_INET;
    _socketServer.sin_port=htons(_socketConnectionPort);
    if(connect(_socketConn,(struct sockaddr*)&amp;_socketServer,sizeof(_socketServer)))
    {
#ifdef _WIN32
        closesocket(_socketConn);
        WSACleanup();
#elif defined (__linux) || defined (__APPLE__)
        close(_socketConn);
#endif
        return(0);
    }
    return(1);
}

</t>
<t tx="leo.20220407205631.108">bool CSocketOutConnection::sendData(const char* data,int dataSize)
{
    if (_socketConn==(SOCKET)-1)
        return(false);

    if (dataSize==0)
        return(false);
    
    // In Following we make sure we don't send too big packets (we might send the data in several packets)
    int packetCount=0;
    int s=dataSize;
    while (s!=0)
    {
        packetCount++;
        if (s&gt;_maxPacketSize-HEADER_LENGTH)
            s-=_maxPacketSize-HEADER_LENGTH;
        else
            s=0;
    }

    s=dataSize;
    int ptr=0;
    while (s!=0)
    {
        packetCount--;
        int sizeToSend=s;
        if (s&gt;_maxPacketSize-HEADER_LENGTH)
            sizeToSend=_maxPacketSize-HEADER_LENGTH;
        s-=sizeToSend;
        if (!_sendSimplePacket(data+ptr,sizeToSend,packetCount))
            return(false);
        ptr+=sizeToSend;
    }
    return(true);
}

</t>
<t tx="leo.20220407205631.109">char* CSocketOutConnection::receiveReplyData(int&amp; dataSize)
{ // Returns the data size if &gt;0, otherwise error
    if (_socketConn==(SOCKET)-1)
    {
        dataSize=-2; // error
        return(NULL);
    }

    std::vector&lt;char&gt; receivedData;
    while (true)
    {
        std::vector&lt;char&gt; inDat;
        int result=_receiveSimplePacket(inDat);
        if (result&lt;0)
        {
            dataSize=0; // error
            return(NULL);
        }
        receivedData.insert(receivedData.end(),inDat.begin(),inDat.end());
        if (result==0)
        { // success
            dataSize=int(receivedData.size());
            char* retBuff=new char[dataSize];
            for (int i=0;i&lt;dataSize;i++)
                retBuff[i]=receivedData[i];
            return(retBuff);
        }
    }
}

</t>
<t tx="leo.20220407205631.110">bool CSocketOutConnection::_sendSimplePacket(const char* packet,int packetLength,unsigned short packetsLeft)
{
    if (packetLength==0)
        return(false);
    // Insert the header:
    unsigned short s=(unsigned short)packetLength;
    char header[HEADER_LENGTH];
    header[0]=_headerByte1;
    header[1]=_headerByte2;
    ((unsigned short*)(header+2))[0]=s;
    ((unsigned short*)(header+2))[1]=packetsLeft;

    std::vector&lt;char&gt; toSend;
    for (int i=0;i&lt;HEADER_LENGTH;i++)
        toSend.push_back(header[i]);
    for (int i=0;i&lt;packetLength;i++)
        toSend.push_back(packet[i]);
    // Send the packet:
    int dl=send(_socketConn,&amp;toSend[0],packetLength+HEADER_LENGTH,0);
    if (dl==packetLength+HEADER_LENGTH)
        return(true);
    return(false);
}

</t>
<t tx="leo.20220407205631.111">int CSocketOutConnection::_receiveSimplePacket(std::vector&lt;char&gt;&amp; packet)
{ // Returns the number of packets left to read if &gt;=0, otherwise error
    //1. Read the header and packet size:
    char headerAndSize[HEADER_LENGTH];
    int totalReceived=0;
    unsigned short startT=_getTimeInMs();
    while(totalReceived!=HEADER_LENGTH)
    {
        int nb=recv(_socketConn,headerAndSize+totalReceived,HEADER_LENGTH-totalReceived,0);
        if (nb&lt;1)
            break;
        totalReceived+=nb;
        if (_getTimeDiffInMs(startT)&gt;3000)
            break;
    }
    // 2. Check if the header is consistent:
    if (totalReceived!=HEADER_LENGTH)
        return(-1); // Error reading
    if ( (headerAndSize[0]!=_headerByte1)||(headerAndSize[1]!=_headerByte2) )
        return(-1); // Error, wrong header
    unsigned short dataLength=((unsigned short*)(headerAndSize+2))[0];
    // 3. Read the data with correct length:
    packet.clear();
    packet.resize(dataLength,0);
    totalReceived=0;
    startT=_getTimeInMs();
    while(totalReceived!=dataLength)
    {
        int nb=recv(_socketConn,&amp;packet[0]+totalReceived,dataLength-totalReceived,0);
        if (nb&lt;1)
            break;
        totalReceived+=nb;
        if (_getTimeDiffInMs(startT)&gt;3000)
            break;
    }
    if (totalReceived!=dataLength)
        return(-1); // wrong size or nothing received
    return(int(((unsigned short*)(headerAndSize+2))[1]));
}

</t>
<t tx="leo.20220407205631.112">int CSocketOutConnection::_getTimeInMs()
{
#ifdef _WIN32
    return(timeGetTime()&amp;0x03ffffff);
#elif defined (__linux) || defined (__APPLE__)
    struct timeval tv;
    unsigned int result=0;
    if (gettimeofday(&amp;tv,NULL)==0)
        result=(tv.tv_sec*1000+tv.tv_usec/1000)&amp;0x03ffffff;
    return(result);
#endif
}

</t>
<t tx="leo.20220407205631.113">int CSocketOutConnection::_getTimeDiffInMs(int lastTime)
{
    int currentTime=_getTimeInMs();
    if (currentTime&lt;lastTime)
        return(currentTime+0x03ffffff-lastTime);
    return(currentTime-lastTime);
}
</t>
<t tx="leo.20220407205631.114"></t>
<t tx="leo.20220407205631.115">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackArray.h"
#include "stackNull.h"
#include "stackNumber.h"
#include "stackBool.h"
#include "stackString.h"
#include "stackMap.h"
#include &lt;sstream&gt;

CStackArray::CStackArray()
{
    _objectType=STACK_ARRAY;
    _circularRef=false;
}

CStackArray::~CStackArray()
{
    for (size_t i=0;i&lt;_objectValues.size();i++)
        delete _objectValues[i];
}

std::string CStackArray::toString() const
{
    if(_circularRef) return "...";
    std::stringstream ss;
    ss &lt;&lt; "{";
    std::string sep = "";
    for(double num : _doubleValues)
    {
        ss &lt;&lt; sep &lt;&lt; num;
        sep = ", ";
    }
    for(CStackObject* obj : _objectValues)
    {
        ss &lt;&lt; sep &lt;&lt; obj-&gt;toString();
        sep = ", ";
    }
    ss &lt;&lt; "}";
    return(ss.str());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.116">void CStackArray::buildOntoStack(int stackId)
{
    simPopStackItem(stackId,0);
    if (_doubleValues.size()&gt;0)
    {
       for (size_t i=0;i&lt;_doubleValues.size();i++)
           simPushDoubleOntoStack(stackId,_doubleValues[i]);
    }
    else if (_objectValues.size()&gt;0)
    {
        for (size_t i=0;i&lt;_objectValues.size();i++)
            CStackObject::buildItemOntoStack(stackId,_objectValues[i]);
    }
}

</t>
<t tx="leo.20220407205631.117">bool CStackArray::buildFromStack(int stackId)
{
    if (_objectValues.size()+_doubleValues.size()+_intValues.size()==0)
    {
        int s=simGetStackSize(stackId);
        // Check first if we have only numbers:
        bool allNumbers=true;
        double dummyD;
        for (int i=0;i&lt;s;i++)
        {
            simMoveStackItemToTop(stackId,0);
            if (1!=simGetStackDoubleValue(stackId,&amp;dummyD))
                allNumbers=false;
        }
        // Now read out the stack:
        if (allNumbers)
        {
            _doubleValues.resize(s);
            for (int i=0;i&lt;s;i++)
            {
                simMoveStackItemToTop(stackId,0);
                simGetStackDoubleValue(stackId,&amp;dummyD);
                _doubleValues[i]=dummyD;
                simPopStackItem(stackId,1);
            }
        }
        else
        {
            for (int i=0;i&lt;s;i++)
            {
                simMoveStackItemToTop(stackId,0);
                appendTopStackItem(stackId);
            }
        }
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.118">void CStackArray::setCircularRef()
{
    _circularRef=true;
}

</t>
<t tx="leo.20220407205631.119">bool CStackArray::isCircularRef()
{
    return(_circularRef);
}

</t>
<t tx="leo.20220407205631.120">void CStackArray::appendTopStackItem(int stackId)
{ // this also clears the item from the stack
    if (_doubleValues.size()+_intValues.size()==0)
        _objectValues.push_back(CStackObject::buildItemFromTopStackPosition(stackId));
}

</t>
<t tx="leo.20220407205631.121">bool CStackArray::isNull(size_t index)
{
    if (index&lt;_objectValues.size())
        return(_objectValues[index]-&gt;getObjectType()==STACK_NULL);
    return(false);
}

</t>
<t tx="leo.20220407205631.122">bool CStackArray::isBool(size_t index)
{
    if (index&lt;_objectValues.size())
        return(_objectValues[index]-&gt;getObjectType()==STACK_BOOL);
    return(false);
}

</t>
<t tx="leo.20220407205631.123">bool CStackArray::isNumber(size_t index)
{
    if (index&lt;_objectValues.size())
        return(_objectValues[index]-&gt;getObjectType()==STACK_NUMBER);
    return(index&lt;_doubleValues.size());
}

</t>
<t tx="leo.20220407205631.124">bool CStackArray::isString(size_t index)
{
    if (index&lt;_objectValues.size())
        return(_objectValues[index]-&gt;getObjectType()==STACK_STRING);
    return(false);
}

</t>
<t tx="leo.20220407205631.125">bool CStackArray::isArray(size_t index,size_t minSize/*=0*/)
{
    if (index&lt;_objectValues.size())
    {
        if (_objectValues[index]-&gt;getObjectType()==STACK_ARRAY)
            return(((CStackArray*)_objectValues[index])-&gt;getSize()&gt;=minSize);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.126">bool CStackArray::isMap(size_t index)
{
    if (index&lt;_objectValues.size())
        return(_objectValues[index]-&gt;getObjectType()==STACK_MAP);
    return(false);
}

</t>
<t tx="leo.20220407205631.127">bool CStackArray::getBool(size_t index)
{
    if ( (index&lt;_objectValues.size())&amp;&amp;(_objectValues[index]-&gt;getObjectType()==STACK_BOOL) )
        return(((CStackBool*)_objectValues[index])-&gt;getValue());
    return(false);
}

</t>
<t tx="leo.20220407205631.128">float CStackArray::getFloat(size_t index)
{
    return((float)getDouble(index));
}

double CStackArray::getDouble(size_t index)
{
    if ( (index&lt;_objectValues.size())&amp;&amp;(_objectValues[index]-&gt;getObjectType()==STACK_NUMBER) )
        return(((CStackNumber*)_objectValues[index])-&gt;getValue());
    if (index&lt;_doubleValues.size())
        return(_doubleValues[index]);
    return(0.0);
}

</t>
<t tx="leo.20220407205631.129">int CStackArray::getInt(size_t index)
{
    if ( (index&lt;_objectValues.size())&amp;&amp;(_objectValues[index]-&gt;getObjectType()==STACK_NUMBER) )
        return((int)((CStackNumber*)_objectValues[index])-&gt;getValue());
    if (index&lt;_doubleValues.size())
        return((int)_doubleValues[index]);
    return(0);
}

</t>
<t tx="leo.20220407205631.130">const double* CStackArray::getDoublePointer()
{
    if (_doubleValues.size()&gt;0)
        return(&amp;_doubleValues[0]);
    return(NULL);
}

</t>
<t tx="leo.20220407205631.131">const int* CStackArray::getIntPointer()
{
    if (_intValues.size()==0)
    {
        for (size_t i=0;i&lt;_doubleValues.size();i++)
            _intValues.push_back(int(_doubleValues[i]));
    }
    if (_intValues.size()&gt;0)
        return(&amp;_intValues[0]);
    return(NULL);
}

std::string CStackArray::getString(size_t index)
{
    if ( (index&lt;_objectValues.size())&amp;&amp;(_objectValues[index]-&gt;getObjectType()==STACK_STRING) )
        return(((CStackString*)_objectValues[index])-&gt;getValue());
    return("");
}

CStackArray* CStackArray::getArray(size_t index)
{
    if ( (index&lt;_objectValues.size())&amp;&amp;(_objectValues[index]-&gt;getObjectType()==STACK_ARRAY) )
        return((CStackArray*)_objectValues[index]);
    return(NULL);
}

CStackMap* CStackArray::getMap(size_t index)
{
    if ( (index&lt;_objectValues.size())&amp;&amp;(_objectValues[index]-&gt;getObjectType()==STACK_MAP) )
        return((CStackMap*)_objectValues[index]);
    return(NULL);
}




</t>
<t tx="leo.20220407205631.132">bool CStackArray::isNumberArray()
{
    return(_objectValues.size()==0);
}

size_t CStackArray::getSize()
{
    if (_objectValues.size()&gt;0)
        return(_objectValues.size());
    return(_doubleValues.size());
}

</t>
<t tx="leo.20220407205631.133">const std::vector&lt;CStackObject*&gt;* CStackArray::getObjects()
{
    return(&amp;_objectValues);
}

</t>
<t tx="leo.20220407205631.134">const std::vector&lt;double&gt;* CStackArray::getDoubles()
{
    return(&amp;_doubleValues);
}

</t>
<t tx="leo.20220407205631.135">const std::vector&lt;int&gt;* CStackArray::getInts()
{
    if (_intValues.size()==0)
    {
        for (size_t i=0;i&lt;_doubleValues.size();i++)
            _intValues.push_back(int(_doubleValues[i]));
    }
    return(&amp;_intValues);
}

</t>
<t tx="leo.20220407205631.136">bool CStackArray::pushNull()
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackNull());
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.137">bool CStackArray::pushBool(bool d)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackBool(d));
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.138">bool CStackArray::pushFloat(float d)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackNumber(double(d)));
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.139">bool CStackArray::pushDouble(double d)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackNumber(d));
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.140">bool CStackArray::pushInt(int d)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackNumber((double)d));
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.141">bool CStackArray::pushString(const std::string&amp; d)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackString(d.c_str(),int(d.length())));
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.142">bool CStackArray::pushString(const char* d,size_t bufferLength)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(new CStackString(d,int(bufferLength)));
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.143">bool CStackArray::pushArray(CStackArray* arr)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(arr);
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.144">bool CStackArray::pushMap(CStackMap* map)
{
    if (_doubleValues.size()+_intValues.size()==0)
    {
        _objectValues.push_back(map);
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.145">bool CStackArray::setDoubleArray(const double* d,size_t l)
{
    if (_doubleValues.size()+_intValues.size()+_objectValues.size()==0)
    {
        for (size_t i=0;i&lt;l;i++)
            _doubleValues.push_back(d[i]);
        return(true);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.146">bool CStackArray::setIntArray(const int* d,size_t l)
{
    if (_doubleValues.size()+_intValues.size()+_objectValues.size()==0)
    {
        for (size_t i=0;i&lt;l;i++)
            _doubleValues.push_back((double)d[i]);
        return(true);
    }
    return(false);
}


CStackObject* CStackArray::copyYourself()
{
    CStackArray* retVal=new CStackArray();
    retVal-&gt;_intValues.assign(_intValues.begin(),_intValues.end());
    retVal-&gt;_doubleValues.assign(_doubleValues.begin(),_doubleValues.end());
    for (size_t i=0;i&lt;_objectValues.size();i++)
        retVal-&gt;_objectValues.push_back(_objectValues[i]-&gt;copyYourself());
    return(retVal);
}

</t>
<t tx="leo.20220407205631.147">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackBool.h"
#include &lt;sstream&gt;

CStackBool::CStackBool(bool theValue)
{
    _objectType=STACK_BOOL;
    _value=theValue;
}

CStackBool::~CStackBool()
{
}

std::string CStackBool::toString() const
{
    std::string strVal = _value ? "true" : "false";
    return(strVal);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.148">bool CStackBool::getValue()
{
    return(_value);
}

</t>
<t tx="leo.20220407205631.149">void CStackBool::setValue(bool theValue)
{
    _value=theValue;
}

CStackObject* CStackBool::copyYourself()
{
    CStackBool* retVal=new CStackBool(_value);
    return(retVal);
}
</t>
<t tx="leo.20220407205631.150">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackMap.h"
#include "stackArray.h"
#include "stackNull.h"
#include "stackNumber.h"
#include "stackBool.h"
#include "stackString.h"
#include &lt;sstream&gt;

CStackMap::CStackMap()
{
    _objectType=STACK_MAP;
}

CStackMap::~CStackMap()
{
    for (std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.begin();it!=_objectValuesKStr.end();it++)
        delete it-&gt;second;
    for (std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.begin();it!=_objectValuesKInt.end();it++)
        delete it-&gt;second;
    for (std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.begin();it!=_objectValuesKBool.end();it++)
        delete it-&gt;second;
}

std::string CStackMap::toString() const
{
    std::stringstream ss;
    ss &lt;&lt; "{";
    std::string sep = "";
    for(const auto &amp;item : _objectValuesKInt)
    {
        ss &lt;&lt; sep &lt;&lt; item.first &lt;&lt; "=" &lt;&lt; item.second-&gt;toString();
        sep = ", ";
    }
    for(const auto &amp;item : _objectValuesKBool)
    {
        ss &lt;&lt; sep &lt;&lt; item.first &lt;&lt; "=" &lt;&lt; item.second-&gt;toString();
        sep = ", ";
    }
    for(const auto &amp;item : _objectValuesKStr)
    {
        ss &lt;&lt; sep &lt;&lt; item.first &lt;&lt; "=" &lt;&lt; item.second-&gt;toString();
        sep = ", ";
    }
    ss &lt;&lt; "}";
    return(ss.str());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.151">void CStackMap::_remove(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
    {
        delete it-&gt;second;
        _objectValuesKStr.erase(it);
    }
}

</t>
<t tx="leo.20220407205631.152">void CStackMap::_remove(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
    {
        delete it-&gt;second;
        _objectValuesKInt.erase(it);
    }
}

</t>
<t tx="leo.20220407205631.153">void CStackMap::_remove(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
    {
        delete it-&gt;second;
        _objectValuesKBool.erase(it);
    }
}

</t>
<t tx="leo.20220407205631.154">void CStackMap::appendTopStackItem(const char* key,int stackId)
{ // this also clears the item from the stack
    _remove(key);
    _objectValuesKStr[key]=CStackObject::buildItemFromTopStackPosition(stackId);
}

</t>
<t tx="leo.20220407205631.155">void CStackMap::appendTopStackItem(int key,int stackId)
{ // this also clears the item from the stack
    _remove(key);
    _objectValuesKInt[key]=CStackObject::buildItemFromTopStackPosition(stackId);
}

</t>
<t tx="leo.20220407205631.156">void CStackMap::appendTopStackItem(bool key,int stackId)
{ // this also clears the item from the stack
    _remove(key);
    _objectValuesKBool[key]=CStackObject::buildItemFromTopStackPosition(stackId);
}

std::map&lt;std::string,CStackObject*&gt;* CStackMap::getKeyValuePairs()
{
    return(&amp;_objectValuesKStr);
}

std::map&lt;std::string,CStackObject*&gt;* CStackMap::getKeyValuePairsKStr()
{
    return(&amp;_objectValuesKStr);
}

std::map&lt;int,CStackObject*&gt;* CStackMap::getKeyValuePairsKInt()
{
    return(&amp;_objectValuesKInt);
}

std::map&lt;bool,CStackObject*&gt;* CStackMap::getKeyValuePairsKBool()
{
    return(&amp;_objectValuesKBool);
}

</t>
<t tx="leo.20220407205631.157">bool CStackMap::isKeyPresent(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    return(it!=_objectValuesKStr.end());
}

</t>
<t tx="leo.20220407205631.158">bool CStackMap::isKeyPresent(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    return(it!=_objectValuesKInt.end());
}

</t>
<t tx="leo.20220407205631.159">bool CStackMap::isKeyPresent(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    return(it!=_objectValuesKBool.end());
}

</t>
<t tx="leo.20220407205631.160">bool CStackMap::isNull(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_NULL);
    return(false);
}

</t>
<t tx="leo.20220407205631.161">bool CStackMap::isBool(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_BOOL);
    return(false);
}

</t>
<t tx="leo.20220407205631.162">bool CStackMap::isNumber(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_NUMBER);
    return(false);
}

</t>
<t tx="leo.20220407205631.163">bool CStackMap::isString(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_STRING);
    return(false);
}

</t>
<t tx="leo.20220407205631.164">bool CStackMap::isArray(const char* key,size_t minSize/*=0*/)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
    {
        if (it-&gt;second-&gt;getObjectType()==STACK_ARRAY)
            return(((CStackArray*)it-&gt;second)-&gt;getSize()&gt;=minSize);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.165">bool CStackMap::isMap(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if (it!=_objectValuesKStr.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_MAP);
    return(false);
}

</t>
<t tx="leo.20220407205631.166">bool CStackMap::isNull(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_NULL);
    return(false);
}

</t>
<t tx="leo.20220407205631.167">bool CStackMap::isBool(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_BOOL);
    return(false);
}

</t>
<t tx="leo.20220407205631.168">bool CStackMap::isNumber(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_NUMBER);
    return(false);
}

</t>
<t tx="leo.20220407205631.169">bool CStackMap::isString(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_STRING);
    return(false);
}

</t>
<t tx="leo.20220407205631.170">bool CStackMap::isArray(int key,size_t minSize/*=0*/)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
    {
        if (it-&gt;second-&gt;getObjectType()==STACK_ARRAY)
            return(((CStackArray*)it-&gt;second)-&gt;getSize()&gt;=minSize);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.171">bool CStackMap::isMap(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if (it!=_objectValuesKInt.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_MAP);
    return(false);
}

</t>
<t tx="leo.20220407205631.172">bool CStackMap::isNull(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_NULL);
    return(false);
}

</t>
<t tx="leo.20220407205631.173">bool CStackMap::isBool(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_BOOL);
    return(false);
}

</t>
<t tx="leo.20220407205631.174">bool CStackMap::isNumber(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_NUMBER);
    return(false);
}

</t>
<t tx="leo.20220407205631.175">bool CStackMap::isString(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_STRING);
    return(false);
}

</t>
<t tx="leo.20220407205631.176">bool CStackMap::isArray(bool key,size_t minSize/*=0*/)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
    {
        if (it-&gt;second-&gt;getObjectType()==STACK_ARRAY)
            return(((CStackArray*)it-&gt;second)-&gt;getSize()&gt;=minSize);
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.177">bool CStackMap::isMap(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if (it!=_objectValuesKBool.end())
        return(it-&gt;second-&gt;getObjectType()==STACK_MAP);
    return(false);
}

</t>
<t tx="leo.20220407205631.178">bool CStackMap::getBool(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_BOOL) )
        return(((CStackBool*)it-&gt;second)-&gt;getValue());
    return(false);
}

</t>
<t tx="leo.20220407205631.179">float CStackMap::getFloat(const char* key)
{
    return((float)getDouble(key));
}

double CStackMap::getDouble(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_NUMBER) )
        return(((CStackNumber*)it-&gt;second)-&gt;getValue());
    return(0.0);
}

</t>
<t tx="leo.20220407205631.180">int CStackMap::getInt(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_NUMBER) )
        return(int(((CStackNumber*)it-&gt;second)-&gt;getValue()));
    return(0);
}

std::string CStackMap::getString(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_STRING) )
        return(((CStackString*)it-&gt;second)-&gt;getValue());
    return("");
}

CStackArray* CStackMap::getArray(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_ARRAY) )
        return((CStackArray*)it-&gt;second);
    return(NULL);
}

CStackMap* CStackMap::getMap(const char* key)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_MAP) )
        return((CStackMap*)it-&gt;second);
    return(NULL);
}

</t>
<t tx="leo.20220407205631.181">bool CStackMap::getBool(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_BOOL) )
        return(((CStackBool*)it-&gt;second)-&gt;getValue());
    return(false);
}

</t>
<t tx="leo.20220407205631.182">float CStackMap::getFloat(int key)
{
    return((float)getDouble(key));
}

double CStackMap::getDouble(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_NUMBER) )
        return(((CStackNumber*)it-&gt;second)-&gt;getValue());
    return(0.0);
}

</t>
<t tx="leo.20220407205631.183">int CStackMap::getInt(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_NUMBER) )
        return(int(((CStackNumber*)it-&gt;second)-&gt;getValue()));
    return(0);
}

std::string CStackMap::getString(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_STRING) )
        return(((CStackString*)it-&gt;second)-&gt;getValue());
    return("");
}

CStackArray* CStackMap::getArray(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_ARRAY) )
        return((CStackArray*)it-&gt;second);
    return(NULL);
}

CStackMap* CStackMap::getMap(int key)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_MAP) )
        return((CStackMap*)it-&gt;second);
    return(NULL);
}

</t>
<t tx="leo.20220407205631.184">bool CStackMap::getBool(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_BOOL) )
        return(((CStackBool*)it-&gt;second)-&gt;getValue());
    return(false);
}

</t>
<t tx="leo.20220407205631.185">float CStackMap::getFloat(bool key)
{
    return((float)getDouble(key));
}

double CStackMap::getDouble(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_NUMBER) )
        return(((CStackNumber*)it-&gt;second)-&gt;getValue());
    return(0.0);
}

</t>
<t tx="leo.20220407205631.186">int CStackMap::getInt(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_NUMBER) )
        return(int(((CStackNumber*)it-&gt;second)-&gt;getValue()));
    return(0);
}

std::string CStackMap::getString(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_STRING) )
        return(((CStackString*)it-&gt;second)-&gt;getValue());
    return("");
}

CStackArray* CStackMap::getArray(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_ARRAY) )
        return((CStackArray*)it-&gt;second);
    return(NULL);
}

CStackMap* CStackMap::getMap(bool key)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(it-&gt;second-&gt;getObjectType()==STACK_MAP) )
        return((CStackMap*)it-&gt;second);
    return(NULL);
}

</t>
<t tx="leo.20220407205631.187">bool CStackMap::contains(const char* key,int theType/*=-1*/,size_t theMinSizeIfArray/*=0*/,bool onlyNumbersInArray/*=false*/)
{
    std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.find(key);
    if ( (it!=_objectValuesKStr.end())&amp;&amp;(theType==-1||it-&gt;second-&gt;getObjectType()==theType) )
    {
        if (theType!=STACK_ARRAY)
            return(true);
        CStackArray* arr=(CStackArray*)it-&gt;second;
        if (arr-&gt;getSize()&gt;=theMinSizeIfArray)
            return((!onlyNumbersInArray)||arr-&gt;isNumberArray());
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.188">bool CStackMap::contains(int key,int theType/*=-1*/,size_t theMinSizeIfArray/*=0*/,bool onlyNumbersInArray/*=false*/)
{
    std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.find(key);
    if ( (it!=_objectValuesKInt.end())&amp;&amp;(theType==-1||it-&gt;second-&gt;getObjectType()==theType) )
    {
        if (theType!=STACK_ARRAY)
            return(true);
        CStackArray* arr=(CStackArray*)it-&gt;second;
        if (arr-&gt;getSize()&gt;=theMinSizeIfArray)
            return((!onlyNumbersInArray)||arr-&gt;isNumberArray());
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.189">bool CStackMap::contains(bool key,int theType/*=-1*/,size_t theMinSizeIfArray/*=0*/,bool onlyNumbersInArray/*=false*/)
{
    std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.find(key);
    if ( (it!=_objectValuesKBool.end())&amp;&amp;(theType==-1||it-&gt;second-&gt;getObjectType()==theType) )
    {
        if (theType!=STACK_ARRAY)
            return(true);
        CStackArray* arr=(CStackArray*)it-&gt;second;
        if (arr-&gt;getSize()&gt;=theMinSizeIfArray)
            return((!onlyNumbersInArray)||arr-&gt;isNumberArray());
    }
    return(false);
}

</t>
<t tx="leo.20220407205631.190">void CStackMap::setNull(const char* key)
{
    _remove(key);
    _objectValuesKStr[key]=new CStackNull();
}

</t>
<t tx="leo.20220407205631.191">void CStackMap::setBool(const char* key,bool d)
{
    _remove(key);
    _objectValuesKStr[key]=new CStackBool(d);
}

</t>
<t tx="leo.20220407205631.192">void CStackMap::setFloat(const char* key,float d)
{
    setDouble(key,(double)d);
}

</t>
<t tx="leo.20220407205631.193">void CStackMap::setDouble(const char* key,double d)
{
    _remove(key);
    _objectValuesKStr[key]=new CStackNumber(d);
}

</t>
<t tx="leo.20220407205631.194">void CStackMap::setInt(const char* key,int d)
{
    _remove(key);
    _objectValuesKStr[key]=new CStackNumber(double(d));
}

</t>
<t tx="leo.20220407205631.195">void CStackMap::setString(const char* key,const std::string&amp; d)
{
    _remove(key);
    _objectValuesKStr[key]=new CStackString(d.c_str(),int(d.length()));
}

</t>
<t tx="leo.20220407205631.196">void CStackMap::setString(const char* key,const char* d,size_t bufferLength)
{
    _remove(key);
    _objectValuesKStr[key]=new CStackString(d,int(bufferLength));
}

</t>
<t tx="leo.20220407205631.197">void CStackMap::setArray(const char* key,CStackArray* arr)
{
    _remove(key);
    _objectValuesKStr[key]=arr;
}

</t>
<t tx="leo.20220407205631.198">void CStackMap::setMap(const char* key,CStackMap* map)
{
    _remove(key);
    _objectValuesKStr[key]=map;
}

</t>
<t tx="leo.20220407205631.199">void CStackMap::setNull(int key)
{
    _remove(key);
    _objectValuesKInt[key]=new CStackNull();
}

</t>
<t tx="leo.20220407205631.2"></t>
<t tx="leo.20220407205631.200">void CStackMap::setBool(int key,bool d)
{
    _remove(key);
    _objectValuesKInt[key]=new CStackBool(d);
}

</t>
<t tx="leo.20220407205631.201">void CStackMap::setFloat(int key,float d)
{
    setDouble(key,(double)d);
}

</t>
<t tx="leo.20220407205631.202">void CStackMap::setDouble(int key,double d)
{
    _remove(key);
    _objectValuesKInt[key]=new CStackNumber(d);
}

</t>
<t tx="leo.20220407205631.203">void CStackMap::setInt(int key,int d)
{
    _remove(key);
    _objectValuesKInt[key]=new CStackNumber(double(d));
}

</t>
<t tx="leo.20220407205631.204">void CStackMap::setString(int key,const std::string&amp; d)
{
    _remove(key);
    _objectValuesKInt[key]=new CStackString(d.c_str(),int(d.length()));
}

</t>
<t tx="leo.20220407205631.205">void CStackMap::setString(int key,const char* d,size_t bufferLength)
{
    _remove(key);
    _objectValuesKInt[key]=new CStackString(d,int(bufferLength));
}

</t>
<t tx="leo.20220407205631.206">void CStackMap::setArray(int key,CStackArray* arr)
{
    _remove(key);
    _objectValuesKInt[key]=arr;
}

</t>
<t tx="leo.20220407205631.207">void CStackMap::setMap(int key,CStackMap* map)
{
    _remove(key);
    _objectValuesKInt[key]=map;
}

</t>
<t tx="leo.20220407205631.208">void CStackMap::setNull(bool key)
{
    _remove(key);
    _objectValuesKBool[key]=new CStackNull();
}

</t>
<t tx="leo.20220407205631.209">void CStackMap::setBool(bool key,bool d)
{
    _remove(key);
    _objectValuesKBool[key]=new CStackBool(d);
}

</t>
<t tx="leo.20220407205631.210">void CStackMap::setFloat(bool key,float d)
{
    setDouble(key,(double)d);
}

</t>
<t tx="leo.20220407205631.211">void CStackMap::setDouble(bool key,double d)
{
    _remove(key);
    _objectValuesKBool[key]=new CStackNumber(d);
}

</t>
<t tx="leo.20220407205631.212">void CStackMap::setInt(bool key,int d)
{
    _remove(key);
    _objectValuesKBool[key]=new CStackNumber(double(d));
}

</t>
<t tx="leo.20220407205631.213">void CStackMap::setString(bool key,const std::string&amp; d)
{
    _remove(key);
    _objectValuesKBool[key]=new CStackString(d.c_str(),int(d.length()));
}

</t>
<t tx="leo.20220407205631.214">void CStackMap::setString(bool key,const char* d,size_t bufferLength)
{
    _remove(key);
    _objectValuesKBool[key]=new CStackString(d,int(bufferLength));
}

</t>
<t tx="leo.20220407205631.215">void CStackMap::setArray(bool key,CStackArray* arr)
{
    _remove(key);
    _objectValuesKBool[key]=arr;
}

</t>
<t tx="leo.20220407205631.216">void CStackMap::setMap(bool key,CStackMap* map)
{
    _remove(key);
    _objectValuesKBool[key]=map;
}

CStackObject* CStackMap::copyYourself()
{
    CStackMap* retVal=new CStackMap();
    for (std::map&lt;std::string,CStackObject*&gt;::iterator it=_objectValuesKStr.begin();it!=_objectValuesKStr.end();it++)
        retVal-&gt;_objectValuesKStr[it-&gt;first]=it-&gt;second-&gt;copyYourself();
    for (std::map&lt;int,CStackObject*&gt;::iterator it=_objectValuesKInt.begin();it!=_objectValuesKInt.end();it++)
        retVal-&gt;_objectValuesKInt[it-&gt;first]=it-&gt;second-&gt;copyYourself();
    for (std::map&lt;bool,CStackObject*&gt;::iterator it=_objectValuesKBool.begin();it!=_objectValuesKBool.end();it++)
        retVal-&gt;_objectValuesKBool[it-&gt;first]=it-&gt;second-&gt;copyYourself();
    return(retVal);
}

</t>
<t tx="leo.20220407205631.217">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackNull.h"

CStackNull::CStackNull()
{
    _objectType=STACK_NULL;
}

CStackNull::~CStackNull()
{
}

std::string CStackNull::toString() const
{
    return("nil");
}

CStackObject* CStackNull::copyYourself()
{
    CStackNull* retVal=new CStackNull();
    return(retVal);
}
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.31"></t>
<t tx="leo.20220407205631.32">@path ./v-rep_plugin/


//Must come before simLib.h, see https://stackoverflow.com/questions/9750344/boostasio-winsock-and-winsock-2-compatibility-issue
#include "Server.h"
#include "simExtFIBR3D.h"

#include "stackArray.h"
#include "stackMap.h"
#include "simLib.h"

#include "string_concurrent_queue.h"

#include &lt;boost/date_time.hpp&gt;

#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

#define _USE_MATH_DEFINES
#include &lt;cmath&gt;

#ifdef _WIN32
#ifdef QT_COMPIL
#include &lt;direct.h&gt;
#else
#include &lt;shlwapi.h&gt;
#pragma comment(lib, "Shlwapi.lib")
#endif
#endif

#if defined(__linux) || defined(__APPLE__)
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#define _stricmp(x,y) strcasecmp(x,y)
#endif

//PCL
//#include &lt;pcl/io/pcd_io.h&gt;
//#include &lt;pcl/point_types.h&gt;
//#include &lt;pcl/filters/voxel_grid.h&gt;

//#define _LOGGING_ 1

//LOGGING
#ifdef _LOGGING_
#include "spdlog/spdlog.h"
#include "spdlog/sinks/stdout_color_sinks.h" //support for stdout logging
#include "spdlog/sinks/basic_file_sink.h" // support for basic file logging
#include "spdlog/sinks/rotating_file_sink.h" // support for rotating file logging
#endif // _LOGGING_

#define CONCAT(x,y,z) x y z
#define strConCat(x,y,z)    CONCAT(x,y,z)

#define PLUGIN_NAME "simFIBR3D"
#define PLUGIN_VERSION 1

#define MESH_CREATION 0
#define OCTREE_COLLISION 1

static LIBRARY simLib; // the CoppelisSim library that we will dynamically load and bind

#ifdef _LOGGING_
using namespace spdlog;
#endif // _LOGGING_
using namespace std::chrono;
using namespace std;

//Component Initialization Variables
bool plugin_loaded = false;
bool first_extrude = true;
int previous_extrude_type = 0;

//Handle gcode line changes
int gcode_line = 0;
//Handle collision line changes
tuple&lt;int, bool&gt; info_line = make_tuple&lt;int,bool&gt;(0, false);

//Object Handlers
unique_ptr&lt;Printer&gt; ptr_printer;
unique_ptr&lt;Extruder&gt; ptr_extruder;
unique_ptr&lt;CommunicationManager&gt; ptr_cm;

system_clock::time_point now, last;

// Get current system time
#ifdef _LOGGING_
boost::posix_time::ptime timeLocal = boost::posix_time::second_clock::local_time();
string date = "logs/fibr3d_" + boost::posix_time::to_iso_string(timeLocal) + "_.txt";

auto mlogger = spdlog::basic_logger_mt("FIBR3Dlogger", date);
#endif // _LOGGING_

//Messages
StringConcurrentQueue msgBar_scq;
StringConcurrentQueue msgBox_scq;

/// LOAD PLUGIN FUNCTION

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_init: Launch this plugin
// --------------------------------------------------------------------------------------
#define LUA_INIT_FIBR3D_CONTROL_COMMAND "simFIBR3D.init" // the name of the new Lua command

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.33">void LUA_INIT_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize()&gt;=2 &amp;&amp; inArguments.isString(0) &amp;&amp; inArguments.isNumber(1)) 
    {
        if (plugin_loaded) {
            ptr_printer.reset();
            ptr_extruder.reset();
            ptr_cm.reset();

            plugin_loaded = false;
        }
        plugin_loaded = true;

        string pname = inArguments.getString(0).c_str();
        int pdofs = inArguments.getInt(1);

        ptr_printer = make_unique&lt;Printer&gt;(pname, pdofs);
        ptr_extruder = make_unique&lt;Extruder&gt;("Extruder", "DrawBoard");
        ptr_cm = make_unique&lt;CommunicationManager&gt;();
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_change_material_shape: Changes deposited material shape
// --------------------------------------------------------------------------------------
#define LUA_CHANGE_MATERIAL_SHAPE_FIBR3D_CONTROL_COMMAND "simFIBR3D.change_material_shape" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.34">void LUA_CHANGE_MATERIAL_SHAPE_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() &gt;= 1 &amp;&amp; inArguments.isNumber(0))
    {
        if (plugin_loaded)
        {
            ptr_extruder-&gt;SetFilamentType(inArguments.getInt(0));
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_change_material_color: Changes deposited material color
// --------------------------------------------------------------------------------------
#define LUA_CHANGE_MATERIAL_COLOR_FIBR3D_CONTROL_COMMAND "simFIBR3D.change_material_color" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.35">void LUA_CHANGE_MATERIAL_COLOR_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() &gt;= 1 &amp;&amp; inArguments.isNumber(0))
    {
        if (plugin_loaded)
        {
            ptr_extruder-&gt;SetFilamentColor(inArguments.getInt(0));	
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_change_material_size: Changes deposited material size
// --------------------------------------------------------------------------------------
#define LUA_CHANGE_MATERIAL_SIZE_FIBR3D_CONTROL_COMMAND "simFIBR3D.change_material_size" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.36">void LUA_CHANGE_MATERIAL_SIZE_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() &gt;= 1 &amp;&amp; inArguments.isNumber(0))
    {
        if (plugin_loaded)
        {
            ptr_extruder-&gt;SetFilamentSize(inArguments.getFloat(0));
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_change_filament_resolution: Changes the number of elements printed in the filament
// --------------------------------------------------------------------------------------
#define LUA_CHANGE_FILAMENT_RESOLUTION_FIBR3D_CONTROL_COMMAND "simFIBR3D.change_filament_resolution" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.37">void LUA_CHANGE_FILAMENT_RESOLUTION_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() &gt;= 1 &amp;&amp; inArguments.isNumber(0))
    {
        if (plugin_loaded)
        {
            ptr_extruder-&gt;SetFilamentResolution(inArguments.getFloat(0));
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_remove_material: Cleans deposited material
// --------------------------------------------------------------------------------------
#define LUA_REMOVE_MATERIAL_FIBR3D_CONTROL_COMMAND "simFIBR3D.remove_material" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.38">void LUA_REMOVE_MATERIAL_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() == 0)
    {
        if (plugin_loaded)
        {
            _internal_::v_repExtRemoveMaterial();
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_create_mesh: Attempts to create a mesh from the printed material
// --------------------------------------------------------------------------------------
#define LUA_CREATE_MESH_FIBR3D_CONTROL_COMMAND "simFIBR3D.create_mesh" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.39">void LUA_CREATE_MESH_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() == 0)
    {
        if (plugin_loaded)
        {
            _internal_::v_repExtCreateMesh();
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_set_collision_handles: Set collision handles
// --------------------------------------------------------------------------------------
#define LUA_SET_COLLISION_HANDLES_FIBR3D_CONTROL_COMMAND "simFIBR3D.set_collision_handles" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.40">void LUA_SET_COLLISION_HANDLES_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() == 1 &amp;&amp; inArguments.isNumberArray())
    {
        if (plugin_loaded)
        {
            const int* collision_handles = inArguments.getIntPointer();
            size_t num_collisions = inArguments.getInts()-&gt;size();

            ptr_printer-&gt;collision_handles = std::vector&lt;int&gt;(collision_handles, collision_handles + num_collisions);
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_enable_collisions: Enables/Disables collision checking
// --------------------------------------------------------------------------------------
#define LUA_ENABLE_COLLISIONS_FIBR3D_CONTROL_COMMAND "simFIBR3D.enable_collisions" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.41">void LUA_ENABLE_COLLISIONS_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() == 1 &amp;&amp; inArguments.isBool(0))
    {
        if (plugin_loaded)
        {
            ptr_printer-&gt;collisions_enabled = inArguments.getBool(0);
        }
    }
}

// --------------------------------------------------------------------------------------
// simExtSurgRobotControl_cleanup: Cleanup this plugin
// --------------------------------------------------------------------------------------
#define LUA_CLEANUP_FIBR3D_CONTROL_COMMAND "simFIBR3D.cleanup" // the name of the new Lua command

</t>
<t tx="leo.20220407205631.42">void LUA_CLEANUP_FIBR3D_CONTROL_CALLBACK(SScriptCallBack* p)
{
    int stack = p-&gt;stackID;

    CStackArray inArguments;
    inArguments.buildFromStack(stack);

    if (inArguments.getSize() == 0)
    {
        if (plugin_loaded) {
            ptr_printer.reset(nullptr);
            ptr_extruder.reset(nullptr);
            ptr_cm.reset(nullptr);

            plugin_loaded = false;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////
/// PRINTER PLUGIN INTERFACE

</t>
<t tx="leo.20220407205631.43">float v_repExtGetSimulationTimeStep()
{
    float dt = simGetSimulationTimeStep();
    if (dt == -1.0f)
    {
        dt = 0.1f;
    }

    return dt;
}

</t>
<t tx="leo.20220407205631.44">void v_repExtPQGetJointPositions(std::vector&lt;double&gt;&amp; pos)
{
    if (ptr_printer-&gt;ready)
    {
        pos = ptr_printer-&gt;get_cur_pos();
    }
}

</t>
<t tx="leo.20220407205631.45">void v_repExtPQSetJointTrajectory(std::vector&lt;std::vector&lt;double&gt; &gt; &amp; dpos, const std::vector&lt; std::pair&lt;bool, int&gt; &gt; &amp;extrude, const std::vector&lt;int&gt; &amp;line)
{
    if (ptr_printer-&gt;ready)
    {
        // Push target positions and extrude property
        for (size_t i = 0; i &lt; dpos.size(); ++i)
        {
            ptr_printer-&gt;target_jpos.push_front(dpos[i]);
            //push paint and type
            ptr_extruder-&gt;paint.push_front(extrude[i]);

            //added line control
            ptr_printer-&gt;line.push_front(line[i]);
        }
    }
}

</t>
<t tx="leo.20220407205631.46">void v_repExtPQAdvanceLine(int line)
{
    if (ptr_printer-&gt;ready)
    {
        //added line control
        ptr_printer-&gt;line.push_front(line);
    }
}

</t>
<t tx="leo.20220407205631.47">void v_repExtPQStopPrinting()
{
    //Stop server communication
    ptr_cm-&gt;StopServer();

    //Clear joint position / velocity queues
    ptr_printer-&gt;target_jpos.clear();
    ptr_extruder-&gt;paint.clear();

    v_repExtPQBoxMsgCommunication("Printing process halted. Communications terminated.");
}

</t>
<t tx="leo.20220407205631.48">void v_repExtPQBarMsgCommunication(const std::string &amp; msg)
{
    if (ptr_printer-&gt;ready)
    {
        msgBar_scq.push_back(msg);
    }
}

</t>
<t tx="leo.20220407205631.49">void v_repExtPQBoxMsgCommunication(const std::string &amp; msg)
{
    if (ptr_printer-&gt;ready)
    {
        msgBox_scq.push_back(msg);
    }
}

////////////////////////////////////////////////////////////////////////////////////////
/// PRINTER INTERNAL

namespace _internal_ {

</t>
<t tx="leo.20220407205631.50">void v_repExtGetHandles(Printer * printer, Extruder * extruder)
{
    //Get robot handles
    int phandle = simGetObjectHandle(printer-&gt;name.c_str());
    if (phandle != -1)
    {
        printer-&gt;handle = phandle;
        //Get robot joint handles
        int bit_options, num_objects;
        bit_options = 1; //bit0 set (1): exclude the tree base from the returned array
        int *ret = simGetObjectsInTree(phandle, sim_object_joint_type, bit_options, &amp;num_objects);
        if (ret != nullptr)
        {
            printer-&gt;joint_handles.resize(printer-&gt;dofs);
            // Common 3 DoFs
            printer-&gt;joint_handles[0] = simGetObjectHandle("AxisX_joint");
            printer-&gt;joint_handles[1] = simGetObjectHandle("AxisY_joint");
            printer-&gt;joint_handles[2] = simGetObjectHandle("AxisZ_joint");
            if (printer-&gt;dofs == 5) {
                printer-&gt;joint_handles[3] = simGetObjectHandle("AxisB_joint");
                printer-&gt;joint_handles[4] = simGetObjectHandle("AxisC_joint");
            }
            printer-&gt;ready = true;
        }
        else {
            msgBox_scq.push_back("Could not retrieve the printer joint handles.");
            return;
        }
        
        ////Get collision handle
        //int coll_res = simGetCollisionHandle(printer-&gt;collision_name.c_str());
        //if(simIsHandleValid(coll_res, sim_appobj_collision_type))
        //{
        //	printer-&gt;collision_handle = coll_res;
        //}
        //else
        //{
        //	msgBox_scq.push_back("Could not retrieve the collision handle.");
        //}
    }
    else {
        msgBox_scq.push_back("Could not retrieve the printer handle.");
        return;
    }

    //Get extruder handle
    int ejhandle = simGetObjectHandle(extruder-&gt;ext_name.c_str());
    int bhandle = simGetObjectHandle(extruder-&gt;bed_name.c_str());
    int fohandle = simGetObjectHandle(extruder-&gt;octree_name.c_str());
    if (ejhandle != -1 &amp;&amp; bhandle != -1)
    {
        float *mat = new float[12];
        std::vector&lt;float&gt; vmat;
        extruder-&gt;ext_handle = ejhandle;
        extruder-&gt;bed_handle = bhandle;
        extruder-&gt;octree_handle = fohandle;
        if (printer-&gt;dofs == 3) {
            extruder-&gt;last_printer_point[3] = 0.0;
            extruder-&gt;last_printer_point[4] = 0.0;
        }
        simGetObjectMatrix(ejhandle, -1, mat);
        //Filament placement
        mat[11] -= extruder-&gt;GetFilamentSize() * 2.0;
        vmat.assign(mat, mat + 12);
        extruder-&gt;SetInitialTransformation(vmat);
    }
    else
    {
        msgBox_scq.push_back("Could not retrieve the extruder or the bed handle.");
        return;
    }
}

</t>
<t tx="leo.20220407205631.51">bool v_repExtGetJointPositions(const std::vector&lt;int&gt;&amp; joint_handles, std::vector&lt;double&gt;&amp; pos)
{
    //! Commented because the pos comes with an assigned size and if the printer only
    //! has 3 DoF it only assigns the first 3 elements.
    //pos.resize(joint_handles.size()); 
    for (size_t i = 0; i &lt; joint_handles.size(); ++i)
    {
        simFloat jpos;
        if (simGetJointPosition(joint_handles[i], &amp;jpos) != -1)
        {
            pos[i] = static_cast&lt;double&gt;(jpos);
        }
        else
        {
            msgBox_scq.push_back("Could not retrieve current joint positions.");
            return false;
        }
    }
    return true;
}

</t>
<t tx="leo.20220407205631.52">bool v_repExtGetJointVelocities(const std::vector&lt;int&gt;&amp; joint_handles, std::vector&lt;double&gt;&amp; vel)
{
    //! Commented because the pos comes with an assigned size and if the printer only
    //! has 3 DoF it only assigns the first 3 elements.
    //pos.resize(joint_handles.size()); 
    for (size_t i = 0; i &lt; joint_handles.size(); ++i)
    {
        simFloat jvel;
        if (simGetObjectFloatParameter(joint_handles[i], sim_jointfloatparam_velocity, &amp;jvel) != -1)
        {
            vel[i] = static_cast&lt;double&gt;(jvel);
        }
        else
        {
            msgBox_scq.push_back("Could not retrieve current joint velocities.");
            return false;
        }
    }
    return true;
}

</t>
<t tx="leo.20220407205631.53">bool v_repExtSetJointPositions(const std::vector&lt;int&gt;&amp; joint_handles, const std::vector&lt;double&gt;&amp; dpos, const int ehandle, const bool extrude,
    const int extrude_type)
{
    //! Commented because the plugin can either operate with 3 or a 5 DoF
    //if (joint_handles.size() != dpos.size())
    //{
    //	msgBox_scq.push_back("Number of joint handles specified do not match target joint positions.");
    //	return false;
    //}

    //Set joint positions
    for (size_t i = 0; i &lt; joint_handles.size(); ++i)
    {
        if (simSetJointPosition(joint_handles[i], dpos[i]) == -1)
        {
            msgBox_scq.push_back("Could not set desired joint position for a passive joint.");
            return false;
        }
    }

    //Set extruder
    if (extrude)
    {
        std::vector&lt;double&gt; cpos(5, 0.0);
        std::vector&lt;double&gt; bpos(5, 0.0); 

        float last_pt[3] = { 0.0, 0.0, 0.0 }; //Last printed point
        float dvec[3] = { 0.0, 0.0, 0.0 };	//distance vector between points
        float last_bc[2] = { 0.0, 0.0 }; //Last bc coordinates

        float int_pt[3] = { 0.0, 0.0, 0.0 }; //intermediate point
        float draw_pt[3] = { 0.0, 0.0, 0.0 };
        float draw_pt_6[6] = { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0 };

        std::vector&lt;float&gt; paint_color;
        float paint_size;
        ptr_extruder-&gt;PaintInfo(extrude_type, paint_color, paint_size);

        //If new extrude type, and not already first extrude
        if (extrude_type != previous_extrude_type) {
            //Required to reset paint, and adjust to new color and size
            first_extrude = true;
        }

        //Store previous type in memory to catch when it changes
        previous_extrude_type = extrude_type;

        float resolution = paint_size * ptr_extruder-&gt;GetFilamentResolution();

        //Get current joint positions
        v_repExtGetJointPositions(joint_handles, cpos);
        bpos.assign(ptr_extruder-&gt;last_printer_point, ptr_extruder-&gt;last_printer_point+5);

        //We are only interested in drawing on the extrusion bed - d_o
        if (first_extrude)
        {
            //sim_drawing_cyclic = if the drawing object is full, then the first items are overwritten
            int mode = ptr_extruder-&gt;drawobj_mode + sim_drawing_cyclic;
            
            size_t it_paint = simAddDrawingObject(mode, paint_size, resolution, ptr_extruder-&gt;bed_handle, ptr_extruder-&gt;buffer_size, &amp;paint_color[0], NULL, NULL, NULL);
            ptr_extruder-&gt;paint_handle.push_back(it_paint);

            //Saved last printed point
            copy(cpos.begin(), cpos.end(), ptr_extruder-&gt;last_printer_point);

            //Convert to world coordinates and draw
            ptr_extruder-&gt;CalculateWorldPoint(cpos, draw_pt);
            switch (ptr_extruder-&gt;drawobj_mode) {
            case 6: // cubes
                copy(draw_pt, draw_pt + 3, draw_pt_6);
                v_repAddDrawingItem(ptr_extruder-&gt;paint_handle.back(), draw_pt_6);
                break;
            case 7: // spheres
            default:
                v_repAddDrawingItem(ptr_extruder-&gt;paint_handle.back(), draw_pt);
            }
            
            first_extrude = false;
        }

        copy(ptr_extruder-&gt;last_printer_point, ptr_extruder-&gt;last_printer_point + 3, last_pt);
        copy(ptr_extruder-&gt;last_printer_point + 3, ptr_extruder-&gt;last_printer_point + 5, last_bc);

        dvec[0] = cpos[0] - last_pt[0];
        dvec[1] = cpos[1] - last_pt[1];
        dvec[2] = cpos[2] - last_pt[2];

        //norm of distance vector 
        float ddist = sqrt(pow(dvec[0], 2) + pow(dvec[1], 2) + pow(dvec[2], 2));
        float bcdist = (float)ptr_extruder-&gt;CalculateRealDistancePoints(bpos,cpos);

        // XYZ motion &gt; 0
        if (ddist &gt; resolution)
        {
            //Number of spheres in segment
            //Determines the number of spheres required to cover the distance from the previous point to the new one.
            int n_sph = static_cast&lt;int&gt;(ceil(ddist / resolution));

            for (size_t i = 0; i &lt; n_sph; ++i)
            {
                int_pt[0] = last_pt[0] + i * (dvec[0] / n_sph);
                int_pt[1] = last_pt[1] + i * (dvec[1] / n_sph);
                int_pt[2] = last_pt[2] + i * (dvec[2] / n_sph);

                //Convert to world coordinates and draw
                ptr_extruder-&gt;CalculateWorldPoint(int_pt, draw_pt);
                switch (ptr_extruder-&gt;drawobj_mode) {
                case 6: // cubes
                    copy(draw_pt, draw_pt + 3, draw_pt_6);
                    v_repAddDrawingItem(ptr_extruder-&gt;paint_handle.back(), draw_pt_6);
                    break;
                case 7: // spheres
                default:
                    v_repAddDrawingItem(ptr_extruder-&gt;paint_handle.back(), draw_pt);
                }
            }
            //Saved last printed point
            copy(cpos.begin(), cpos.end(), ptr_extruder-&gt;last_printer_point);
        }
        // No XYZ motion
        else if(bcdist &gt; (resolution/100.0)) {
            // Draw 1
            //Saved last printed point
            copy(cpos.begin(), cpos.end(), ptr_extruder-&gt;last_printer_point);

            //Convert to world coordinates and draw
            ptr_extruder-&gt;CalculateWorldPoint(cpos, draw_pt);
            switch (ptr_extruder-&gt;drawobj_mode) {
            case 6: // cubes
                copy(draw_pt, draw_pt + 3, draw_pt_6);
                v_repAddDrawingItem(ptr_extruder-&gt;paint_handle.back(), draw_pt_6);
                break;
            case 7: // spheres
            default:
                v_repAddDrawingItem(ptr_extruder-&gt;paint_handle.back(), draw_pt);
            }
        }
    }
    else
    {
        first_extrude = true;
    }

    return true;
}

</t>
<t tx="leo.20220407205631.54">void v_repExtRemoveMaterial()
{
    if (ptr_extruder)
    {
        //Remove existing Drawing objects
        for_each(ptr_extruder-&gt;paint_handle.begin(), ptr_extruder-&gt;paint_handle.end(), 
            [&amp;](int &amp;h) { simRemoveDrawingObject(h); });

        //Set First Extrude to true to redraw Drawing object
        first_extrude = true;
    
        if (OCTREE_COLLISION)
        {
            simRemoveVoxelsFromOctree(ptr_extruder-&gt;octree_handle, 1, NULL, 0, NULL);
        }
    }
}

</t>
<t tx="leo.20220407205631.55">void v_repExtCreateMesh() 
{	/*
    if (MESH_CREATION &amp;&amp; ptr_extruder)
    {
        int mode = ptr_extruder-&gt;drawobj_mode + sim_drawing_cyclic;
        double size = ptr_extruder-&gt;GetFilamentSize();
        size_t n_pts = ptr_extruder-&gt;paint_items.size();
        size_t n_pts2 = ptr_extruder-&gt;paint_items2.size();

        // Initialize non-ordered point cloud
        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
        cloud-&gt;width = n_pts;
        cloud-&gt;height = 1;
        cloud-&gt;is_dense = false;
        cloud-&gt;points.resize(n_pts);

        // Initialize non-ordered point cloud
        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud2(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
        cloud2-&gt;width = n_pts2;
        cloud2-&gt;height = 1;
        cloud2-&gt;is_dense = false;
        cloud2-&gt;points.resize(n_pts2);

        for (size_t i = 0; i &lt; n_pts; ++i)
        {
            std::vector&lt;float&gt; pt = ptr_extruder-&gt;paint_items.at(i);
            cloud-&gt;points[i].x = pt[0];
            cloud-&gt;points[i].y = pt[1];
            cloud-&gt;points[i].z = pt[2];
        }

        for (size_t i = 0; i &lt; n_pts2; ++i)
        {
            std::vector&lt;float&gt; pt2 = ptr_extruder-&gt;paint_items2.at(i);
            cloud2-&gt;points[i].x = pt2[0];
            cloud2-&gt;points[i].y = pt2[1];
            cloud2-&gt;points[i].z = pt2[2];
        }

        pcl::io::savePCDFileASCII("C://Work//PCL//GreedyProjection//test_pcd.pcd", *cloud);
        std::cerr &lt;&lt; "Saved " &lt;&lt; cloud-&gt;points.size() &lt;&lt; " data points to test_pcd.pcd." &lt;&lt; std::endl;

        pcl::io::savePCDFileASCII("C://Work//PCL//GreedyProjection//test_pcd2.pcd", *cloud2);
        std::cerr &lt;&lt; "Saved " &lt;&lt; cloud2-&gt;points.size() &lt;&lt; " data points to test_pcd.pcd." &lt;&lt; std::endl;

        // Filter
        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_filtered(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
        pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
        sor.setInputCloud(cloud2);
        sor.setLeafSize(size, size, size);
        sor.filter(*cloud_filtered);

        // Remove previous
        v_repExtRemoveMaterial();
        
        // Draw filtered
        int it_paint = simAddDrawingObject(mode, size, 0, ptr_extruder-&gt;bed_handle, ptr_extruder-&gt;buffer_size, ptr_extruder-&gt;GetFilamentColor(), NULL, NULL, NULL);
        ptr_extruder-&gt;paint_handle.push_back(it_paint);
        
        //Draw the object in the simulator
        float point[6] = {0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f};
        std::for_each(cloud_filtered-&gt;begin(), cloud_filtered-&gt;end(), [&amp;](pcl::PointXYZ &amp;p) 
            { 
                point[0] = p.x;
                point[1] = p.y;
                point[2] = p.z;
                simAddDrawingObjectItem(it_paint, point);
            });

        cout &lt;&lt; "Decimated cloud with " &lt;&lt; cloud-&gt;size() &lt;&lt; " -&gt; " &lt;&lt; cloud_filtered-&gt;size() &lt;&lt; " pts.\n";
    }
    */
}

</t>
<t tx="leo.20220407205631.56">void v_repExtBarMsgCommunication(const string &amp;message)
{
    simAddStatusbarMessage(message.c_str());
}

</t>
<t tx="leo.20220407205631.57">void v_repExtBoxMsgCommunication(const string &amp;message)
{
    simDisplayDialog("FIBR3D message",
        message.c_str(),
        sim_dlgstyle_ok,
        NULL, //no input
        NULL, //title default colors
        NULL, //title default colors
        NULL); //custom uiHandle
}

</t>
<t tx="leo.20220407205631.58">    void v_repAddDrawingItem(const int paint_handle, const float *paint_point)
    {
        //Add object to paint_items VectorConcurrentQueue
        std::vector&lt;float&gt; 
            pt(paint_point, paint_point + 3),
            otpt(paint_point, paint_point + 3);
        ptr_extruder-&gt;paint_items.push_back(pt);

        //Draw the object in the simulator
        simAddDrawingObjectItem(paint_handle, paint_point);

        if (OCTREE_COLLISION)
        {
            //otpt[2] -= ptr_extruder-&gt;octree_leaf_size / 2;
            //Check and add point to octree
            simInt res = simCheckOctreePointOccupancy(ptr_extruder-&gt;octree_handle, 0, &amp;otpt[0], 1, NULL, NULL, NULL);
            if (res == 0) {
                simInsertVoxelsIntoOctree(ptr_extruder-&gt;octree_handle, 0, &amp;otpt[0], 1, NULL, NULL, NULL);
            }
        }
    }

}

// This is the plugin start routine (called just once, just after the plugin was loaded):
SIM_DLLEXPORT unsigned char simStart(void* reservedPointer,int reservedInt)
{
    // Dynamically load and bind CoppelisSim functions:
    // 1. Figure out this plugin's directory:
    char curDirAndFile[1024];
#ifdef _WIN32
    #ifdef QT_COMPIL
        _getcwd(curDirAndFile, sizeof(curDirAndFile));
    #else
        GetModuleFileName(NULL,curDirAndFile,1023);
        PathRemoveFileSpec(curDirAndFile);
    #endif
#else
    getcwd(curDirAndFile, sizeof(curDirAndFile));
#endif

    std::string currentDirAndPath(curDirAndFile);
    // 2. Append the CoppelisSim library's name:
    std::string temp(currentDirAndPath);
#ifdef _WIN32
    temp+="\\coppeliaSim.dll";
#elif defined (__linux)
    temp+="/libcoppeliaSim.so";
#elif defined (__APPLE__)
    temp+="/libcoppeliaSim.dylib";
#endif /* __linux || __APPLE__ */
    // 3. Load the CoppelisSim library:
    simLib=loadSimLibrary(temp.c_str());
    if (simLib==NULL)
    {
        printf("simExtFIBR3D: error: could not find or correctly load the CoppeliaSim library. Cannot start the plugin.\n"); // cannot use simAddLog here.
        return(0); // Means error, CoppelisSim will unload this plugin
    }
    if (getSimProcAddresses(simLib)==0)
    {
        printf("simExtFIBR3D: error: could not find all required functions in the CoppeliaSim library. Cannot start the plugin.\n"); // cannot use simAddLog here.
        unloadSimLibrary(simLib);
        return(0); // Means error, CoppelisSim will unload this plugin
    }

    // Check the version of CoppelisSim:
    int simVer,simRev;
    simGetIntegerParameter(sim_intparam_program_version,&amp;simVer);
    simGetIntegerParameter(sim_intparam_program_revision,&amp;simRev);
    if( (simVer&lt;40000) || ((simVer==40000)&amp;&amp;(simRev&lt;1)) )
    {
        simAddStatusbarMessage("sorry, your CoppelisSim copy is somewhat old, CoppelisSim 4.0.0 rev1 or higher is required. Cannot start the plugin.");
        unloadSimLibrary(simLib);
        return(0); // Means error, CoppelisSim will unload this plugin
    }

    std::vector&lt;int&gt; inArgs;

    // Implicitely include the script lua/simExtRTDE.lua:
    simRegisterScriptVariable("simFIBR3D","require('simExtFIBR3D')",0);

    // Register the new Lua command "simExtSurgRobotControl_functions":
    simRegisterScriptCallbackFunction(strConCat(LUA_INIT_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_INIT_FIBR3D_CONTROL_COMMAND, "(string printerName, number printerDoFs)"), LUA_INIT_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CHANGE_MATERIAL_SHAPE_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_CHANGE_MATERIAL_SHAPE_FIBR3D_CONTROL_COMMAND, "(number shapeID)"), LUA_CHANGE_MATERIAL_SHAPE_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CHANGE_MATERIAL_COLOR_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_CHANGE_MATERIAL_COLOR_FIBR3D_CONTROL_COMMAND, "(number colorID)"), LUA_CHANGE_MATERIAL_COLOR_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CHANGE_MATERIAL_SIZE_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_CHANGE_MATERIAL_SIZE_FIBR3D_CONTROL_COMMAND, "(number size)"), LUA_CHANGE_MATERIAL_SIZE_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CHANGE_FILAMENT_RESOLUTION_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_CHANGE_FILAMENT_RESOLUTION_FIBR3D_CONTROL_COMMAND, "(number resolution)"), LUA_CHANGE_FILAMENT_RESOLUTION_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_REMOVE_MATERIAL_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_REMOVE_MATERIAL_FIBR3D_CONTROL_COMMAND, "()"), LUA_REMOVE_MATERIAL_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CREATE_MESH_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_CREATE_MESH_FIBR3D_CONTROL_COMMAND, "()"), LUA_CREATE_MESH_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_SET_COLLISION_HANDLES_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_SET_COLLISION_HANDLES_FIBR3D_CONTROL_COMMAND, "(table collisionHandles)"), LUA_SET_COLLISION_HANDLES_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_ENABLE_COLLISIONS_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_ENABLE_COLLISIONS_FIBR3D_CONTROL_COMMAND, "(bool enableCollisions)"), LUA_ENABLE_COLLISIONS_FIBR3D_CONTROL_CALLBACK);
    simRegisterScriptCallbackFunction(strConCat(LUA_CLEANUP_FIBR3D_CONTROL_COMMAND, "@", PLUGIN_NAME), strConCat("void", LUA_CLEANUP_FIBR3D_CONTROL_COMMAND, "()"), LUA_CLEANUP_FIBR3D_CONTROL_CALLBACK);

    return(PLUGIN_VERSION); // initialization went fine, we return the version number of this plugin (can be queried with simGetModuleName)
}

// This is the plugin end routine (called just once, when CoppelisSim is ending, i.e. releasing this plugin):
SIM_DLLEXPORT void simEnd()
{
    // Here you could handle various clean-up tasks

    unloadSimLibrary(simLib); // release the library
}

// This is the plugin messaging routine (i.e. CoppelisSim calls this function very often, with various messages):
SIM_DLLEXPORT void* simMessage(int message,int* auxiliaryData,void* customData,int* replyData)
{ // This is called quite often. Just watch out for messages/events you want to handle
    // Keep following 5 lines at the beginning and unchanged:
    static bool refreshDlgFlag=true;
    int errorModeSaved;
    simGetIntegerParameter(sim_intparam_error_report_mode,&amp;errorModeSaved);
    simSetIntegerParameter(sim_intparam_error_report_mode,sim_api_errormessage_ignore);
    void* retVal=NULL;

    // Here we can intercept many messages from V-REP (actually callbacks). Only the most important messages are listed here.
    // For a complete list of messages that you can intercept/react with, search for "sim_message_eventcallback"-type constants
    // in the V-REP user manual.

    if (message==sim_message_eventcallback_refreshdialogs)
    {
        refreshDlgFlag=true; // V-REP dialogs were refreshed. Maybe a good idea to refresh this plugin's dialog too
    }

    if (message==sim_message_eventcallback_menuitemselected)
    { // A custom menu bar entry was selected..
      // here you could make a plugin's main dialog visible/invisible
    }

    if (message==sim_message_eventcallback_instancepass)
    {   // This message is sent each time the scene was rendered (well, shortly after) (very often)
        // It is important to always correctly react to events in V-REP. This message is the most convenient way to do so:
        int flags=auxiliaryData[0];
        bool sceneContentChanged=((flags&amp;(1+2+4+8+16+32+64+256))!=0); // object erased, created, model or scene loaded, und/redo called, instance switched, or object scaled since last sim_message_eventcallback_instancepass message
        bool sceneLoaded=((flags&amp;8)!=0);

        if (sceneLoaded)
        { // React to a scene load here!!
        }

        if (sceneContentChanged)
        { // we actualize plugin objects for changes in the scene
            refreshDlgFlag=true; // always a good idea to trigger a refresh of this plugin's dialog here
        }
    }

    if (message==sim_message_eventcallback_mainscriptabouttobecalled)
    { // The main script is about to be run (only called while a simulation is running (and not paused!))
    }

    if (message == sim_message_eventcallback_simulationabouttostart)
    { // Simulation is about to start
        if ((customData == NULL) || (std::string("FIBR3D").compare((char*)customData) == 0)) // is the command also meant for this plugin?
        {
            if (plugin_loaded)
            {
                //Get Printer and Extruder Handles
                _internal_::v_repExtGetHandles(ptr_printer.get(), ptr_extruder.get());

                simAddStatusbarMessage("Waiting for connection from Parser...");
                ptr_cm-&gt;LaunchServer();

#ifdef _LOGGING_
                //Logger initialization
                mlogger-&gt;info("LAUNCHED PLUGIN");
                mlogger-&gt;info("TIME, LINE, X, Y, Z, B, C, vX, vY, vZ, vB, vC");
                set_level(spdlog::level::info);
                //flush_every(std::chrono::seconds(1));
                set_pattern("%v");

                now = system_clock::now();
                last = now;
#endif // _LOGGING_

                
            }
        }
    }

    if (message==sim_message_eventcallback_simulationended)
    { // Simulation just ended
        if ((customData == NULL) || (std::string("FIBR3D").compare((char*)customData) == 0)) // is the command also meant for this plugin?
        {
            if (plugin_loaded)
            {
                //If queues not empty, empty
                while (!ptr_printer-&gt;target_jpos.empty()) {
                    ptr_printer-&gt;target_jpos.pop_back();
                }

                //If queues not empty, empty
                while (!ptr_extruder-&gt;paint.empty()) {
                    ptr_extruder-&gt;paint.pop_back();
                }

                //Clean deposited material
                _internal_::v_repExtRemoveMaterial();

                //Reset actuator positions
                std::vector&lt;double&gt; jpos(ptr_printer-&gt;dofs, 0.0);
                _internal_::v_repExtSetJointPositions(ptr_printer-&gt;joint_handles, jpos, ptr_extruder-&gt;ext_handle, false, 0);

                simAddStatusbarMessage("Close TCP/IP connection with Printer parser.");
                ptr_cm-&gt;StopServer();

#ifdef _LOGGING_
                mlogger-&gt;flush();
#endif // _LOGGING_
            }
        }
    }

    if (message==sim_message_eventcallback_moduleopen)
    {
        if ( (customData==NULL)||(std::string("FIBR3D").compare((char*)customData)==0) ) // is the command also meant for this plugin?
        {

        }
    }

    if (message==sim_message_eventcallback_modulehandle)
    {
        if ((customData == NULL) || (std::string("FIBR3D").compare((char*)customData) == 0)) // is the command also meant for this plugin?
        {
            if (plugin_loaded)
            {
                //Robot Real
                if (ptr_printer-&gt;ready)
                {				
                    //Read Joints
                    std::vector&lt;double&gt; jpos(ptr_printer-&gt;dofs, 0.0), jvel(ptr_printer-&gt;dofs, 0.0);
                    if (_internal_::v_repExtGetJointPositions(ptr_printer-&gt;joint_handles, jpos))
                    {
                        ptr_printer-&gt;set_cur_pos(jpos);

#ifdef _LOGGING_
                        _internal_::v_repExtGetJointVelocities(ptr_printer-&gt;joint_handles, jvel);

                        now = system_clock::now();
                        int elapsed = static_cast&lt;int&gt;(duration_cast&lt;milliseconds&gt; (now - last).count());
                        //last = now;

                        //current line too
                        // Pos: m -&gt; 1000 mm, Ori: rad -&gt; 180/M_PI deg
                        // Vel: m/s -&gt; 60000 mm/min, AVel: rad/s -&gt; 60 * 180/M_PI deg/min
                        mlogger-&gt;info("{:6d}, {:2d}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f}, {:03.3f} ",
                            elapsed,
                            ptr_printer-&gt;line.back(),
                            jpos[0] * 1000, jpos[1] * 1000, jpos[2] * 1000, 
                            jpos[3] * 180 / M_PI, jpos[4] * 180 / M_PI,
                            jvel[0] * 60000, jvel[1] * 60000,  jvel[2] * 60000,  
                            jvel[3] * 60 * 180 / M_PI, jvel[4] * 60 * 180 / M_PI);
#endif // _LOGGING_
                    }

                    //Set Joints
                    if (!ptr_printer-&gt;target_jpos.empty())
                    {
                        //Printing should have its own funcion with jpos!
                        std::pair&lt;bool, int&gt; current_paint = ptr_extruder-&gt;paint.back();
                        if (_internal_::v_repExtSetJointPositions(ptr_printer-&gt;joint_handles, ptr_printer-&gt;target_jpos.back(), 
                            ptr_extruder-&gt;ext_handle, current_paint.first, current_paint.second))
                        {
                            if (!ptr_printer-&gt;target_jpos.empty()) 
                            {
                                ptr_printer-&gt;target_jpos.pop_back();
                            }
                            if (!ptr_extruder-&gt;paint.empty())
                            {
                                ptr_extruder-&gt;paint.pop_back();
                            }
                            //was here
                            //if (!ptr_printer-&gt;line.empty())
                        }
                        else
                        {
                            ptr_printer-&gt;target_jpos.clear();
                            ptr_extruder-&gt;paint.clear();
                            ptr_printer-&gt;line.clear();
                        }
                    }
                }

                //Check current line, updated when there are also no joints to move
                if (!ptr_printer-&gt;line.empty())
                {
                    //Current line collision		
                    //int res = simReadCollision(ptr_printer-&gt;collision_handle);
                    //bool colliding = (res == 1);
                    //int res = simHandleCollision(sim_handle_all);
                    //bool colliding = (res &gt; 0);
                    bool colliding = false; // set to true by default, collision detection selected in vrep gui
                    int number_collisions = 0;
                    if (ptr_printer-&gt;collisions_enabled) {
                        for_each(ptr_printer-&gt;collision_handles.begin(), ptr_printer-&gt;collision_handles.end(), [&amp;](const int &amp;handle) {
                            int res = simHandleCollision(handle);
                            number_collisions += (res != -1 ? res : 0);
                        });
                        colliding = (number_collisions &gt; 0);
                    }


                    //Changed current line
                    int current_line = ptr_printer-&gt;line.back();

                    //Broadcast if new line or
                    //			if same line and no collision before and collision now
                    if (std::get&lt;0&gt;(info_line) != current_line ||
                        (std::get&lt;0&gt;(info_line) == current_line &amp;&amp; !std::get&lt;1&gt;(info_line) &amp;&amp; colliding))
                    {
                        std::get&lt;0&gt;(info_line) = current_line;
                        std::get&lt;1&gt;(info_line) = colliding;

                        //trigger event
                        ptr_cm-&gt;get_server()-&gt;broadcast(current_line, colliding);
                    }
                    ptr_printer-&gt;line.pop_back();
                }

                //Error messages
                if (!msgBar_scq.empty()) //Status bar messages
                {
                    _internal_::v_repExtBarMsgCommunication(msgBar_scq.consume_back());
                }

                if (!msgBox_scq.empty()) //Message box errors
                {
                    _internal_::v_repExtBoxMsgCommunication(msgBox_scq.consume_back());
                }
            }
        }
    }

    if (message==sim_message_eventcallback_moduleclose)
    {
    }

    if (message==sim_message_eventcallback_instanceswitch)
    { // We switched to a different scene. Such a switch can only happen while simulation is not running
    }

    if (message==sim_message_eventcallback_broadcast)
    { // Here we have a plugin that is broadcasting data (the broadcaster will also receive this data!)
    }

    if (message==sim_message_eventcallback_scenesave)
    { // The scene is about to be saved. If required do some processing here (e.g. add custom scene data to be serialized with the scene)
    }

    // You can add many more messages to handle here

    if ((message==sim_message_eventcallback_guipass)&amp;&amp;refreshDlgFlag)
    { // handle refresh of the plugin's dialogs
        // ...
        refreshDlgFlag=false;
    }

    // Keep following unchanged:
    simSetIntegerParameter(sim_intparam_error_report_mode,errorModeSaved); // restore previous settings
    return(retVal);
}
</t>
<t tx="leo.20220407205631.59">@path ./v-rep_plugin/
#pragma once

#include "Printer.h"
#include "Extruder.h"

#include &lt;string&gt;

#ifdef _WIN32
    #define SIM_DLLEXPORT extern "C" __declspec(dllexport)
#else
    #define SIM_DLLEXPORT extern "C"
#endif


// The 3 required entry points of the CoppelisSim plugin:
SIM_DLLEXPORT unsigned char simStart(void* reservedPointer,int reservedInt);
SIM_DLLEXPORT void simEnd();
SIM_DLLEXPORT void* simMessage(int message,int* auxiliaryData,void* customData,int* replyData);

/*!
 * Guaranteeing the VRep standard API functions are always called from the VRep main thread.
 *
 * Instead of directly calling this functions from communication threads, the information is
 * passed to queues that are push/poped from the communication or VRep thread.
 *
 * To clear the plugin files, it is created objects that encapsulate information relative to
 * robots, end-effectors or surgical trajectories.
 */

 //Printer Communication Functions
float v_repExtGetSimulationTimeStep();
void v_repExtPQGetJointPositions(std::vector&lt;double&gt; &amp;pos);
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205631.60">void v_repExtPQSetJointTrajectory(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;dpos, const std::vector&lt; std::pair&lt;bool, int&gt; &gt; &amp;extrude, 
    const std::vector&lt;int&gt; &amp;line);
void v_repExtPQAdvanceLine(int line);
void v_repExtPQStopPrinting(); //Stop communication server, clear joint queues...
void v_repExtPQBarMsgCommunication(const std::string &amp;msg);
void v_repExtPQBoxMsgCommunication(const std::string &amp;msg);

namespace _internal_ {
    //Printer Control
    void v_repExtGetHandles(Printer *printer, Extruder *extruder);
    bool v_repExtGetJointPositions(const std::vector&lt;int&gt; &amp;jhandles, std::vector&lt;double&gt; &amp;pos);
    bool v_repExtSetJointPositions(const std::vector&lt;int&gt; &amp;jhandles, const std::vector&lt;double&gt; &amp;dpos, const int ehandle, const bool extrude, 
</t>
<t tx="leo.20220407205631.64"></t>
<t tx="leo.20220407205631.65"></t>
<t tx="leo.20220407205631.66">@path ./v-rep_plugin/coppelia/common/
#include "luaFunctionData.h"
#include &lt;sstream&gt;
#include &lt;cstring&gt;

CLuaFunctionData::CLuaFunctionData()
{
}

CLuaFunctionData::~CLuaFunctionData()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.67">void CLuaFunctionData::getInputDataForFunctionRegistration(const int* dat,std::vector&lt;int&gt;&amp; outDat)
{
    outDat.clear();
    outDat.push_back(dat[0]);
    for (int i=0;i&lt;dat[0];i++)
        outDat.push_back((dat[1+2*i+0]|SIM_LUA_ARG_NIL_ALLOWED)-SIM_LUA_ARG_NIL_ALLOWED);
}

std::vector&lt;CLuaFunctionDataItem&gt;* CLuaFunctionData::getInDataPtr()
{ // use this when reading data from Lua from inside of a custom Lua function call
    return(&amp;_inData);
}

std::vector&lt;CLuaFunctionDataItem&gt;* CLuaFunctionData::getOutDataPtr_luaFunctionCall()
{ // use this when reading data returned from a Lua function call from a plugin
    return(&amp;_outData);
}

</t>
<t tx="leo.20220407205631.68">bool CLuaFunctionData::readDataFromLua(const SLuaCallBack* p,const int* expectedArguments,int requiredArgumentCount,const char* functionName)
{
    // use this when reading data from Lua from inside of a custom Lua function call
    _inData.clear();
    int argCnt=p-&gt;inputArgCount;
    if (argCnt&lt;requiredArgumentCount)
    {
        simSetLastError(functionName,"Not enough arguments.");
        return(false);
    }

    int boolArgInd=0;
    int intArgInd=0;
    int floatArgInd=0;
    int doubleArgInd=0;
    int charArgInd=0;
    int charBuffArgInd=0;

    for (int i=0;i&lt;argCnt;i++)
    {
        if (i&gt;=expectedArguments[0])
            break;
        bool done=false;
        if (p-&gt;inputArgTypeAndSize[i*2+0]==sim_lua_arg_nil)
        {
            // is nil explicitely allowed?
            if (expectedArguments[1+i*2+0]&amp;SIM_LUA_ARG_NIL_ALLOWED)
            { // yes. This is for an argument that can optionally also be nil.
                CLuaFunctionDataItem dat;
                _inData.push_back(dat);
                done=true;
            }
            else
            { // no
                if (int(_inData.size())&lt;requiredArgumentCount)
                {
                    std::ostringstream str;
                    str &lt;&lt; "Argument " &lt;&lt; i+1 &lt;&lt; " is not correct.";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
                break; // this argument is nil, so it is like inexistant. But we also won't explore any more arguments, we have enough.
            }
        }
        if (!done)
        {
            if (p-&gt;inputArgTypeAndSize[i*2+0]!=((expectedArguments[1+i*2+0]|SIM_LUA_ARG_NIL_ALLOWED)-SIM_LUA_ARG_NIL_ALLOWED))
            {
                std::ostringstream str;
                str &lt;&lt; "Argument " &lt;&lt; i+1 &lt;&lt; " is not correct.";
                simSetLastError(functionName,str.str().c_str());
                return(false);
            }
            if (p-&gt;inputArgTypeAndSize[i*2+0]&amp;sim_lua_arg_table)
            { // we have a table
                if ( (p-&gt;inputArgTypeAndSize[i*2+1]&lt;expectedArguments[1+i*2+1])&amp;&amp;(expectedArguments[1+i*2+1]!=0) )
                {
                    std::ostringstream str;
                    str &lt;&lt; "Argument " &lt;&lt; i+1 &lt;&lt; " is not correct (wrong table size).";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
                else
                {
                    int t=p-&gt;inputArgTypeAndSize[i*2+0]-sim_lua_arg_table;
                    int itemCnt=p-&gt;inputArgTypeAndSize[i*2+1];

                    if (t==sim_lua_arg_nil)
                    {
                        CLuaFunctionDataItem* a=new CLuaFunctionDataItem();
                        a-&gt;setNilTable(itemCnt);
                        CLuaFunctionDataItem dat;
                        dat.setNilTable(itemCnt);
                        _inData.push_back(dat);
                    }
                    if (t==sim_lua_arg_bool)
                    {
                        std::vector&lt;bool&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;inputBool[boolArgInd++]!=0);
                        CLuaFunctionDataItem dat(vect);
                        _inData.push_back(dat);
                    }
                    if (t==sim_lua_arg_int)
                    {
                        std::vector&lt;int&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;inputInt[intArgInd++]);
                        CLuaFunctionDataItem dat(vect);
                        _inData.push_back(dat);
                    }
                    if (t==sim_lua_arg_float)
                    {
                        std::vector&lt;float&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;inputFloat[floatArgInd++]);
                        CLuaFunctionDataItem dat(vect);
                        _inData.push_back(dat);
                    }
                    if (t==sim_lua_arg_double)
                    {
                        std::vector&lt;double&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;inputDouble[doubleArgInd++]);
                        CLuaFunctionDataItem dat(vect);
                        _inData.push_back(dat);
                    }
                    if (t==sim_lua_arg_string)
                    {
                        std::vector&lt;std::string&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                        {
                            std::string str(p-&gt;inputChar+charArgInd);
                            vect.push_back(str);
                            charArgInd+=int(strlen(p-&gt;inputChar+charArgInd))+1;
                        }
                        CLuaFunctionDataItem dat(vect);
                        _inData.push_back(dat);
                    }
                    if (t==sim_lua_arg_charbuff)
                    {
                        std::ostringstream str;
                        str &lt;&lt; "Argument " &lt;&lt; i+1 &lt;&lt; " cannot be a table.";
                        simSetLastError(functionName,str.str().c_str());
                        return(false);
                    }
                }
            }
            else
            { // we do not have a table
                int t=p-&gt;inputArgTypeAndSize[i*2+0];
                if (t==sim_lua_arg_nil)
                {
                    CLuaFunctionDataItem dat;
                    _inData.push_back(dat);
                }
                if (t==sim_lua_arg_bool)
                {
                    CLuaFunctionDataItem dat(p-&gt;inputBool[boolArgInd++]!=0);
                    _inData.push_back(dat);
                }
                if (t==sim_lua_arg_int)
                {
                    CLuaFunctionDataItem dat(p-&gt;inputInt[intArgInd++]);
                    _inData.push_back(dat);
                }
                if (t==sim_lua_arg_float)
                {
                    CLuaFunctionDataItem dat(p-&gt;inputFloat[floatArgInd++]);
                    _inData.push_back(dat);
                }
                if (t==sim_lua_arg_double)
                {
                    CLuaFunctionDataItem dat(p-&gt;inputDouble[doubleArgInd++]);
                    _inData.push_back(dat);
                }
                if (t==sim_lua_arg_string)
                {
                    CLuaFunctionDataItem dat(std::string(p-&gt;inputChar+charArgInd));
                    charArgInd+=int(strlen(p-&gt;inputChar+charArgInd))+1;
                    _inData.push_back(dat);
                }
                if (t==sim_lua_arg_charbuff)
                {
                    if ( (p-&gt;inputArgTypeAndSize[i*2+1]&lt;expectedArguments[1+i*2+1])&amp;&amp;(expectedArguments[1+i*2+1]!=0) )
                    {
                        std::ostringstream str;
                        str &lt;&lt; "Argument " &lt;&lt; i+1 &lt;&lt; " is not correct (wrong buffer size).";
                        simSetLastError(functionName,str.str().c_str());
                        return(false);
                    }
                    else
                    {
                        CLuaFunctionDataItem dat(p-&gt;inputCharBuff+charBuffArgInd,p-&gt;inputArgTypeAndSize[i*2+1]);
                        charBuffArgInd+=p-&gt;inputArgTypeAndSize[i*2+1];
                        _inData.push_back(dat);
                    }
                }
            }
        }
    }
    return(true);
}

</t>
<t tx="leo.20220407205631.69">bool CLuaFunctionData::readDataFromLua_luaFunctionCall(const SLuaCallBack* p,const int* expectedArguments,int requiredArgumentCount,const char* functionName)
{
    // use this when reading data returned from a Lua function call from a plugin
    _outData.clear();
    int argCnt=p-&gt;outputArgCount;
    if (argCnt&lt;requiredArgumentCount)
    {
        simSetLastError(functionName,"Not enough return arguments.");
        return(false);
    }

    int boolArgInd=0;
    int intArgInd=0;
    int floatArgInd=0;
    int doubleArgInd=0;
    int charArgInd=0;
    int charBuffArgInd=0;

    for (int i=0;i&lt;argCnt;i++)
    {
        if (i&gt;=expectedArguments[0])
            break;
        bool done=false;
        if (p-&gt;outputArgTypeAndSize[i*2+0]==sim_lua_arg_nil)
        {
            // is nil explicitely allowed?
            if (expectedArguments[1+i*2+0]&amp;SIM_LUA_ARG_NIL_ALLOWED)
            { // yes. This is for an argument that can optionally also be nil.
                CLuaFunctionDataItem dat;
                _outData.push_back(dat);
                done=true;
            }
            else
            { // no
                if (int(_outData.size())&lt;requiredArgumentCount)
                {
                    std::ostringstream str;
                    str &lt;&lt; "Return argument " &lt;&lt; i+1 &lt;&lt; " is not correct.";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
                break; // this argument is nil, so it is like inexistant. But we also won't explore any more arguments, we have enough.
            }
        }
        if (!done)
        {
            if (p-&gt;outputArgTypeAndSize[i*2+0]!=((expectedArguments[1+i*2+0]|SIM_LUA_ARG_NIL_ALLOWED)-SIM_LUA_ARG_NIL_ALLOWED))
            {
                std::ostringstream str;
                str &lt;&lt; "Return argument " &lt;&lt; i+1 &lt;&lt; " is not correct.";
                simSetLastError(functionName,str.str().c_str());
                return(false);
            }
            if (p-&gt;outputArgTypeAndSize[i*2+0]&amp;sim_lua_arg_table)
            { // we have a table
                if ( (p-&gt;outputArgTypeAndSize[i*2+1]&lt;expectedArguments[1+i*2+1])&amp;&amp;(expectedArguments[1+i*2+1]!=0) )
                {
                    std::ostringstream str;
                    str &lt;&lt; "Return argument " &lt;&lt; i+1 &lt;&lt; " is not correct (wrong table size).";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
                else
                {
                    int t=p-&gt;outputArgTypeAndSize[i*2+0]-sim_lua_arg_table;
                    int itemCnt=p-&gt;outputArgTypeAndSize[i*2+1];

                    if (t==sim_lua_arg_nil)
                    {
                        CLuaFunctionDataItem* a=new CLuaFunctionDataItem();
                        a-&gt;setNilTable(itemCnt);
                        CLuaFunctionDataItem dat;
                        dat.setNilTable(itemCnt);
                        _outData.push_back(dat);
                    }
                    if (t==sim_lua_arg_bool)
                    {
                        std::vector&lt;bool&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;outputBool[boolArgInd++]!=0);
                        CLuaFunctionDataItem dat(vect);
                        _outData.push_back(dat);
                    }
                    if (t==sim_lua_arg_int)
                    {
                        std::vector&lt;int&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;outputInt[intArgInd++]);
                        CLuaFunctionDataItem dat(vect);
                        _outData.push_back(dat);
                    }
                    if (t==sim_lua_arg_float)
                    {
                        std::vector&lt;float&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;outputFloat[floatArgInd++]);
                        CLuaFunctionDataItem dat(vect);
                        _outData.push_back(dat);
                    }
                    if (t==sim_lua_arg_double)
                    {
                        std::vector&lt;double&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                            vect.push_back(p-&gt;outputDouble[doubleArgInd++]);
                        CLuaFunctionDataItem dat(vect);
                        _outData.push_back(dat);
                    }
                    if (t==sim_lua_arg_string)
                    {
                        std::vector&lt;std::string&gt; vect;
                        for (int j=0;j&lt;itemCnt;j++)
                        {
                            std::string str(p-&gt;outputChar+charArgInd);
                            vect.push_back(str);
                            charArgInd+=int(strlen(p-&gt;outputChar+charArgInd))+1;
                        }
                        CLuaFunctionDataItem dat(vect);
                        _outData.push_back(dat);
                    }
                    if (t==sim_lua_arg_charbuff)
                    {
                        std::ostringstream str;
                        str &lt;&lt; "Return argument " &lt;&lt; i+1 &lt;&lt; " cannot be a table.";
                        simSetLastError(functionName,str.str().c_str());
                        return(false);
                    }
                }
            }
            else
            { // we do not have a table
                int t=p-&gt;outputArgTypeAndSize[i*2+0];
                if (t==sim_lua_arg_nil)
                {
                    CLuaFunctionDataItem dat;
                    _outData.push_back(dat);
                }
                if (t==sim_lua_arg_bool)
                {
                    CLuaFunctionDataItem dat(p-&gt;outputBool[boolArgInd++]!=0);
                    _outData.push_back(dat);
                }
                if (t==sim_lua_arg_int)
                {
                    CLuaFunctionDataItem dat(p-&gt;outputInt[intArgInd++]);
                    _outData.push_back(dat);
                }
                if (t==sim_lua_arg_float)
                {
                    CLuaFunctionDataItem dat(p-&gt;outputFloat[floatArgInd++]);
                    _outData.push_back(dat);
                }
                if (t==sim_lua_arg_double)
                {
                    CLuaFunctionDataItem dat(p-&gt;outputDouble[doubleArgInd++]);
                    _outData.push_back(dat);
                }
                if (t==sim_lua_arg_string)
                {
                    CLuaFunctionDataItem dat(std::string(p-&gt;outputChar+charArgInd));
                    charArgInd+=int(strlen(p-&gt;outputChar+charArgInd))+1;
                    _outData.push_back(dat);
                }
                if (t==sim_lua_arg_charbuff)
                {
                    if ( (p-&gt;outputArgTypeAndSize[i*2+1]&lt;expectedArguments[1+i*2+1])&amp;&amp;(expectedArguments[1+i*2+1]!=0) )
                    {
                        std::ostringstream str;
                        str &lt;&lt; "Return argument " &lt;&lt; i+1 &lt;&lt; " is not correct (wrong buffer size).";
                        simSetLastError(functionName,str.str().c_str());
                        return(false);
                    }
                    else
                    {
                        CLuaFunctionDataItem dat(p-&gt;outputCharBuff+charBuffArgInd,p-&gt;outputArgTypeAndSize[i*2+1]);
                        charBuffArgInd+=p-&gt;outputArgTypeAndSize[i*2+1];
                        _outData.push_back(dat);
                    }
                }
            }
        }
    }
    return(true);
}

</t>
<t tx="leo.20220407205631.70">void CLuaFunctionData::pushOutData(const CLuaFunctionDataItem&amp; dataItem)
{ // use this when returning data from inside of a custom Lua function call
    _outData.push_back(dataItem);
}

</t>
<t tx="leo.20220407205631.71">void CLuaFunctionData::pushOutData_luaFunctionCall(const CLuaFunctionDataItem&amp; dataItem)
{ // use this when doing a Lua function call from a plugin
    _inData.push_back(dataItem);
}

</t>
<t tx="leo.20220407205631.72">void CLuaFunctionData::writeDataToLua(SLuaCallBack* p)
{
    // use this when returning data from inside of a custom Lua function call
    p-&gt;outputArgCount=0;
    int itemCnt=int(_outData.size());
    if (itemCnt&gt;0)
    {
        p-&gt;outputArgCount=itemCnt;
        p-&gt;outputArgTypeAndSize=(simInt*)simCreateBuffer(p-&gt;outputArgCount*2*sizeof(simInt));

        int boolDataCnt=0;
        int intDataCnt=0;
        int floatDataCnt=0;
        int doubleDataCnt=0;
        int charDataCnt=0;
        int charBuffDataCnt=0;

        for (int i=0;i&lt;itemCnt;i++)
        {
            if (_outData[i].isTable())
            { // table
                if (_outData[i].getType()==-1)
                {
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_nil|sim_lua_arg_table;
                    p-&gt;outputArgTypeAndSize[i*2+1]=_outData[i].getNilTableSize();
                }
                if (_outData[i].getType()==0)
                {
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_bool|sim_lua_arg_table;
                    p-&gt;outputArgTypeAndSize[i*2+1]=int(_outData[i].boolData.size());
                    boolDataCnt+=p-&gt;outputArgTypeAndSize[i*2+1];
                }
                if (_outData[i].getType()==1)
                {
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_int|sim_lua_arg_table;
                    p-&gt;outputArgTypeAndSize[i*2+1]=int(_outData[i].intData.size());
                    intDataCnt+=p-&gt;outputArgTypeAndSize[i*2+1];
                }
                if (_outData[i].getType()==2)
                {
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_float|sim_lua_arg_table;
                    p-&gt;outputArgTypeAndSize[i*2+1]=int(_outData[i].floatData.size());
                    floatDataCnt+=p-&gt;outputArgTypeAndSize[i*2+1];
                }
                if (_outData[i].getType()==5)
                {
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_double|sim_lua_arg_table;
                    p-&gt;outputArgTypeAndSize[i*2+1]=int(_outData[i].doubleData.size());
                    doubleDataCnt+=p-&gt;outputArgTypeAndSize[i*2+1];
                }
                if (_outData[i].getType()==3)
                {
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_string|sim_lua_arg_table;
                    p-&gt;outputArgTypeAndSize[i*2+1]=int(_outData[i].stringData.size());
                    for (int j=0;j&lt;int(_outData[i].stringData.size());j++)
                        charDataCnt+=int(_outData[i].stringData[j].length())+1;
                }
            }
            else
            {
                if (_outData[i].getType()==-1)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=0;
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_nil;
                }
                if (_outData[i].getType()==0)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=0;
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_bool;
                    boolDataCnt++;
                }
                if (_outData[i].getType()==1)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=0;
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_int;
                    intDataCnt++;
                }
                if (_outData[i].getType()==2)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=0;
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_float;
                    floatDataCnt++;
                }
                if (_outData[i].getType()==5)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=0;
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_double;
                    doubleDataCnt++;
                }
                if (_outData[i].getType()==3)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=0;
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_string;
                    charDataCnt+=int(_outData[i].stringData[0].length())+1;
                }
                if (_outData[i].getType()==4)
                {
                    p-&gt;outputArgTypeAndSize[i*2+1]=int(_outData[i].stringData[0].length());
                    p-&gt;outputArgTypeAndSize[i*2+0]=sim_lua_arg_charbuff;
                    charBuffDataCnt+=int(_outData[i].stringData[0].length());
                }
            }
        }

        // Now create the buffers:
        p-&gt;outputBool=(simBool*)simCreateBuffer(boolDataCnt*sizeof(simBool));
        p-&gt;outputInt=(simInt*)simCreateBuffer(intDataCnt*sizeof(simInt));
        p-&gt;outputFloat=(simFloat*)simCreateBuffer(floatDataCnt*sizeof(simFloat));
        p-&gt;outputDouble=(simDouble*)simCreateBuffer(doubleDataCnt*sizeof(simDouble));
        p-&gt;outputChar=(simChar*)simCreateBuffer(charDataCnt*sizeof(simChar));
        p-&gt;outputCharBuff=(simChar*)simCreateBuffer(charBuffDataCnt*sizeof(simChar));
        
        // Now populate the buffers:
        int boolDataOff=0;
        int intDataOff=0;
        int floatDataOff=0;
        int doubleDataOff=0;
        int charDataOff=0;
        int charBuffDataOff=0;

        for (int i=0;i&lt;itemCnt;i++)
        {
            if (_outData[i].isTable())
            { // table
                if (_outData[i].getType()==0)
                {
                    for (int j=0;j&lt;int(_outData[i].boolData.size());j++)
                        p-&gt;outputBool[boolDataOff++]=_outData[i].boolData[j];
                }
                if (_outData[i].getType()==1)
                {
                    for (int j=0;j&lt;int(_outData[i].intData.size());j++)
                        p-&gt;outputInt[intDataOff++]=_outData[i].intData[j];
                }
                if (_outData[i].getType()==2)
                {
                    for (int j=0;j&lt;int(_outData[i].floatData.size());j++)
                        p-&gt;outputFloat[floatDataOff++]=_outData[i].floatData[j];
                }
                if (_outData[i].getType()==5)
                {
                    for (int j=0;j&lt;int(_outData[i].doubleData.size());j++)
                        p-&gt;outputDouble[doubleDataOff++]=_outData[i].doubleData[j];
                }
                if (_outData[i].getType()==3)
                {
                    for (int j=0;j&lt;int(_outData[i].stringData.size());j++)
                    {
                        for (int k=0;k&lt;int(_outData[i].stringData[j].length());k++)
                            p-&gt;outputChar[charDataOff++]=_outData[i].stringData[j][k];
                        p-&gt;outputChar[charDataOff++]=0;
                    }
                }
            }
            else
            {
                if (_outData[i].getType()==0)
                    p-&gt;outputBool[boolDataOff++]=_outData[i].boolData[0];
                if (_outData[i].getType()==1)
                    p-&gt;outputInt[intDataOff++]=_outData[i].intData[0];
                if (_outData[i].getType()==2)
                    p-&gt;outputFloat[floatDataOff++]=_outData[i].floatData[0];
                if (_outData[i].getType()==5)
                    p-&gt;outputDouble[doubleDataOff++]=_outData[i].doubleData[0];
                if (_outData[i].getType()==3)
                {
                    for (int j=0;j&lt;int(_outData[i].stringData[0].length());j++)
                        p-&gt;outputChar[charDataOff++]=_outData[i].stringData[0][j];
                    p-&gt;outputChar[charDataOff++]=0;
                }
                if (_outData[i].getType()==4)
                {
                    for (int j=0;j&lt;int(_outData[i].stringData[0].length());j++)
                        p-&gt;outputCharBuff[charBuffDataOff++]=_outData[i].stringData[0][j];
                }
            }
        }
    }
}

</t>
<t tx="leo.20220407205631.73">void CLuaFunctionData::writeDataToLua_luaFunctionCall(SLuaCallBack* p,const int* expectedArguments)
{
    // use this when doing a Lua function call from a plugin
    p-&gt;objectID=-1; // added this on 23/2/2016, to avoid conflicts (even if chances are very small) with new way of calling simCallScriptFunction
    p-&gt;inputArgCount=0;
    p-&gt;inputBool=NULL;
    p-&gt;inputInt=NULL;
    p-&gt;inputFloat=NULL;
    p-&gt;inputDouble=NULL;
    p-&gt;inputChar=NULL;
    p-&gt;inputCharBuff=NULL;
    p-&gt;inputArgTypeAndSize=NULL;

    p-&gt;outputArgCount=expectedArguments[0];
    p-&gt;outputBool=NULL;
    p-&gt;outputInt=NULL;
    p-&gt;outputFloat=NULL;
    p-&gt;outputDouble=NULL;
    p-&gt;outputChar=NULL;
    p-&gt;outputCharBuff=NULL;
    p-&gt;outputArgTypeAndSize=(simInt*)simCreateBuffer(p-&gt;outputArgCount*2*sizeof(simInt));
    for (int i=0;i&lt;p-&gt;outputArgCount*2;i++)
        p-&gt;outputArgTypeAndSize[i]=expectedArguments[1+i];

    int itemCnt=int(_inData.size());
    if (itemCnt&gt;0)
    {
        p-&gt;inputArgCount=itemCnt;
        p-&gt;inputArgTypeAndSize=(simInt*)simCreateBuffer(p-&gt;inputArgCount*2*sizeof(simInt));

        int boolDataCnt=0;
        int intDataCnt=0;
        int floatDataCnt=0;
        int doubleDataCnt=0;
        int charDataCnt=0;
        int charBuffDataCnt=0;

        for (int i=0;i&lt;itemCnt;i++)
        {
            if (_inData[i].isTable())
            { // table
                if (_inData[i].getType()==-1)
                {
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_nil|sim_lua_arg_table;
                    p-&gt;inputArgTypeAndSize[i*2+1]=_inData[i].getNilTableSize();
                }
                if (_inData[i].getType()==0)
                {
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_bool|sim_lua_arg_table;
                    p-&gt;inputArgTypeAndSize[i*2+1]=int(_inData[i].boolData.size());
                    boolDataCnt+=p-&gt;inputArgTypeAndSize[i*2+1];
                }
                if (_inData[i].getType()==1)
                {
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_int|sim_lua_arg_table;
                    p-&gt;inputArgTypeAndSize[i*2+1]=int(_inData[i].intData.size());
                    intDataCnt+=p-&gt;inputArgTypeAndSize[i*2+1];
                }
                if (_inData[i].getType()==2)
                {
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_float|sim_lua_arg_table;
                    p-&gt;inputArgTypeAndSize[i*2+1]=int(_inData[i].floatData.size());
                    floatDataCnt+=p-&gt;inputArgTypeAndSize[i*2+1];
                }
                if (_inData[i].getType()==5)
                {
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_double|sim_lua_arg_table;
                    p-&gt;inputArgTypeAndSize[i*2+1]=int(_inData[i].doubleData.size());
                    doubleDataCnt+=p-&gt;inputArgTypeAndSize[i*2+1];
                }
                if (_inData[i].getType()==3)
                {
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_string|sim_lua_arg_table;
                    p-&gt;inputArgTypeAndSize[i*2+1]=int(_inData[i].stringData.size());
                    for (int j=0;j&lt;int(_inData[i].stringData.size());j++)
                        charDataCnt+=int(_inData[i].stringData[j].length())+1;
                }
            }
            else
            {
                if (_inData[i].getType()==-1)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=0;
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_nil;
                }
                if (_inData[i].getType()==0)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=0;
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_bool;
                    boolDataCnt++;
                }
                if (_inData[i].getType()==1)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=0;
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_int;
                    intDataCnt++;
                }
                if (_inData[i].getType()==2)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=0;
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_float;
                    floatDataCnt++;
                }
                if (_inData[i].getType()==5)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=0;
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_double;
                    doubleDataCnt++;
                }
                if (_inData[i].getType()==3)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=0;
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_string;
                    charDataCnt+=int(_inData[i].stringData[0].length())+1;
                }
                if (_inData[i].getType()==4)
                {
                    p-&gt;inputArgTypeAndSize[i*2+1]=int(_inData[i].stringData[0].length());
                    p-&gt;inputArgTypeAndSize[i*2+0]=sim_lua_arg_charbuff;
                    charBuffDataCnt+=int(_inData[i].stringData[0].length());
                }
            }
        }

        // Now create the buffers:
        p-&gt;inputBool=(simBool*)simCreateBuffer(boolDataCnt*sizeof(simBool));
        p-&gt;inputInt=(simInt*)simCreateBuffer(intDataCnt*sizeof(simInt));
        p-&gt;inputFloat=(simFloat*)simCreateBuffer(floatDataCnt*sizeof(simFloat));
        p-&gt;inputDouble=(simDouble*)simCreateBuffer(doubleDataCnt*sizeof(simDouble));
        p-&gt;inputChar=(simChar*)simCreateBuffer(charDataCnt*sizeof(simChar));
        p-&gt;inputCharBuff=(simChar*)simCreateBuffer(charBuffDataCnt*sizeof(simChar));
        
        // Now populate the buffers:
        int boolDataOff=0;
        int intDataOff=0;
        int floatDataOff=0;
        int doubleDataOff=0;
        int charDataOff=0;
        int charBuffDataOff=0;

        for (int i=0;i&lt;itemCnt;i++)
        {
            if (_inData[i].isTable())
            { // table
                if (_inData[i].getType()==0)
                {
                    for (int j=0;j&lt;int(_inData[i].boolData.size());j++)
                        p-&gt;inputBool[boolDataOff++]=_inData[i].boolData[j];
                }
                if (_inData[i].getType()==1)
                {
                    for (int j=0;j&lt;int(_inData[i].intData.size());j++)
                        p-&gt;inputInt[intDataOff++]=_inData[i].intData[j];
                }
                if (_inData[i].getType()==2)
                {
                    for (int j=0;j&lt;int(_inData[i].floatData.size());j++)
                        p-&gt;inputFloat[floatDataOff++]=_inData[i].floatData[j];
                }
                if (_inData[i].getType()==5)
                {
                    for (int j=0;j&lt;int(_inData[i].doubleData.size());j++)
                        p-&gt;inputDouble[doubleDataOff++]=_inData[i].doubleData[j];
                }
                if (_inData[i].getType()==3)
                {
                    for (int j=0;j&lt;int(_inData[i].stringData.size());j++)
                    {
                        for (int k=0;k&lt;int(_inData[i].stringData[j].length());k++)
                            p-&gt;inputChar[charDataOff++]=_inData[i].stringData[j][k];
                        p-&gt;inputChar[charDataOff++]=0;
                    }
                }
            }
            else
            {
                if (_inData[i].getType()==0)
                    p-&gt;inputBool[boolDataOff++]=_inData[i].boolData[0];
                if (_inData[i].getType()==1)
                    p-&gt;inputInt[intDataOff++]=_inData[i].intData[0];
                if (_inData[i].getType()==2)
                    p-&gt;inputFloat[floatDataOff++]=_inData[i].floatData[0];
                if (_inData[i].getType()==5)
                    p-&gt;inputDouble[doubleDataOff++]=_inData[i].doubleData[0];
                if (_inData[i].getType()==3)
                {
                    for (int j=0;j&lt;int(_inData[i].stringData[0].length());j++)
                        p-&gt;inputChar[charDataOff++]=_inData[i].stringData[0][j];
                    p-&gt;inputChar[charDataOff++]=0;
                }
                if (_inData[i].getType()==4)
                {
                    for (int j=0;j&lt;int(_inData[i].stringData[0].length());j++)
                        p-&gt;inputCharBuff[charBuffDataOff++]=_inData[i].stringData[0][j];
                }
            }
        }
    }
}

</t>
<t tx="leo.20220407205631.74">void CLuaFunctionData::releaseBuffers_luaFunctionCall(SLuaCallBack* p)
{ // this is the old version. Use instead 'releaseBuffers_scriptFunctionCall'
    // use this you finished with a Lua function call from a plugin
    simReleaseBuffer((char*)p-&gt;inputBool);
    p-&gt;inputBool=NULL;
    simReleaseBuffer((char*)p-&gt;inputInt);
    p-&gt;inputInt=NULL;
    simReleaseBuffer((char*)p-&gt;inputFloat);
    p-&gt;inputFloat=NULL;
    simReleaseBuffer((char*)p-&gt;inputDouble);
    p-&gt;inputDouble=NULL;
    simReleaseBuffer((char*)p-&gt;inputChar);
    p-&gt;inputChar=NULL;
    simReleaseBuffer((char*)p-&gt;inputCharBuff);
    p-&gt;inputCharBuff=NULL;
    simReleaseBuffer((char*)p-&gt;inputArgTypeAndSize);
    p-&gt;inputArgTypeAndSize=NULL;

    simReleaseBuffer((char*)p-&gt;outputBool);
    p-&gt;outputBool=NULL;
    simReleaseBuffer((char*)p-&gt;outputInt);
    p-&gt;outputInt=NULL;
    simReleaseBuffer((char*)p-&gt;outputFloat);
    p-&gt;outputFloat=NULL;
    simReleaseBuffer((char*)p-&gt;outputDouble);
    p-&gt;outputDouble=NULL;
    simReleaseBuffer((char*)p-&gt;outputChar);
    p-&gt;outputChar=NULL;
    simReleaseBuffer((char*)p-&gt;outputCharBuff);
    p-&gt;outputCharBuff=NULL;
    simReleaseBuffer((char*)p-&gt;outputArgTypeAndSize);
    p-&gt;outputArgTypeAndSize=NULL;
}
</t>
<t tx="leo.20220407205631.75">@path ./v-rep_plugin/coppelia/common/
#include "luaFunctionDataItem.h"

CLuaFunctionDataItem::CLuaFunctionDataItem()
{
    _nilTableSize=0;
    _isTable=false;
    _type=-1; // nil
}

CLuaFunctionDataItem::CLuaFunctionDataItem(bool v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=0;
    boolData.push_back(v);
}

CLuaFunctionDataItem::CLuaFunctionDataItem(int v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=1;
    intData.push_back(v);
}

CLuaFunctionDataItem::CLuaFunctionDataItem(float v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=2;
    floatData.push_back(v);
}

CLuaFunctionDataItem::CLuaFunctionDataItem(double v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=5;
    doubleData.push_back(v);
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const std::string&amp; v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=3;
    stringData.push_back(v);
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const char* bufferPtr,unsigned int bufferLength)
{
    _nilTableSize=0;
    _isTable=false;
    _type=4;
    std::string v(bufferPtr,bufferLength);
    stringData.push_back(v);
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const std::vector&lt;bool&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=0;
    boolData.assign(v.begin(),v.end());
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const std::vector&lt;int&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=1;
    intData.assign(v.begin(),v.end());
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const std::vector&lt;float&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=2;
    floatData.assign(v.begin(),v.end());
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const std::vector&lt;double&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=5;
    doubleData.assign(v.begin(),v.end());
}

CLuaFunctionDataItem::CLuaFunctionDataItem(const std::vector&lt;std::string&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=3;
    stringData.assign(v.begin(),v.end());
}

CLuaFunctionDataItem::~CLuaFunctionDataItem()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.76">bool CLuaFunctionDataItem::isTable()
{
    return(_isTable);
}

</t>
<t tx="leo.20220407205631.77">int CLuaFunctionDataItem::getType()
{
    return(_type);
}

</t>
<t tx="leo.20220407205631.78">void CLuaFunctionDataItem::setNilTable(int size)
{
    if (_type==-1)
    {
        _isTable=true;
        _nilTableSize=size;
    }
}

</t>
<t tx="leo.20220407205631.79">int CLuaFunctionDataItem::getNilTableSize()
{
    return(_nilTableSize);
}
</t>
<t tx="leo.20220407205631.80">@path ./v-rep_plugin/coppelia/common/
#include "scriptFunctionData.h"
#include &lt;sstream&gt;
#include &lt;cstring&gt;

CScriptFunctionData::CScriptFunctionData()
{
}

CScriptFunctionData::~CScriptFunctionData()
{
}

std::vector&lt;CScriptFunctionDataItem&gt;* CScriptFunctionData::getInDataPtr()
{ // use this when reading data from a script from inside of a custom script function call
    return(&amp;_inData);
}

std::vector&lt;CScriptFunctionDataItem&gt;* CScriptFunctionData::getOutDataPtr_scriptFunctionCall()
{ // use this when reading data returned from a script function call from a plugin
    return(&amp;_outData);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.81">bool CScriptFunctionData::readDataFromStack(int stackHandle,const int* expectedArguments,int requiredArgumentCount,const char* functionName)
{  // use this when reading data from a script from inside of a custom script function call
    bool retVal=_readData(stackHandle,expectedArguments,requiredArgumentCount,functionName,"arguments.","Argument ",_inData);
    simPopStackItem(stackHandle,0); // clears the stack (which will serve as return value container from now)
    return(retVal);
}

</t>
<t tx="leo.20220407205631.82">bool CScriptFunctionData::readDataFromStack_scriptFunctionCall(int stackHandle,const int* expectedArguments,int requiredArgumentCount,const char* functionName)
{   // use this when reading data returned from a Lua function call from a plugin
    bool retVal=_readData(stackHandle,expectedArguments,requiredArgumentCount,functionName,"return arguments.","Return argument ",_outData);
    simPopStackItem(stackHandle,0); // clears the stack
    return(retVal);
}

</t>
<t tx="leo.20220407205631.83">void CScriptFunctionData::pushOutData(const CScriptFunctionDataItem&amp; dataItem)
{ // use this when returning data from inside of a custom Lua function call
    _outData.push_back(dataItem);
}

</t>
<t tx="leo.20220407205631.84">void CScriptFunctionData::pushOutData_scriptFunctionCall(const CScriptFunctionDataItem&amp; dataItem)
{ // use this when doing a Lua function call from a plugin
    _inData.push_back(dataItem);
}

</t>
<t tx="leo.20220407205631.85">void CScriptFunctionData::writeDataToStack(int stackHandle)
{   // use this when returning data from inside of a custom Lua function call
    _writeData(stackHandle,_outData);
}

</t>
<t tx="leo.20220407205631.86">void CScriptFunctionData::writeDataToStack_scriptFunctionCall(int stackHandle)
{ // use this when doing a Lua function call from a plugin
    _writeData(stackHandle,_inData);
}

</t>
<t tx="leo.20220407205631.87">bool CScriptFunctionData::_readData(int stack,const int* expectedArguments,int requiredArgumentCount,const char* functionName,const char* argumentText1,const char* argumentText2,std::vector&lt;CScriptFunctionDataItem&gt;&amp; inOutData)
{  // use this when reading data from a script from inside of a custom script function call
    inOutData.clear();
    int argCnt=simGetStackSize(stack);
    if (argCnt&lt;requiredArgumentCount)
    {
        std::ostringstream str;
        str &lt;&lt; "Not enough " &lt;&lt; argumentText1;
        simSetLastError(functionName,str.str().c_str());
        return(false);
    }

    for (int i=0;i&lt;argCnt;i++)
    {
        if (i&gt;=expectedArguments[0])
            break;
        bool done=false;
        simMoveStackItemToTop(stack,0);
        if (simIsStackValueNull(stack)==1)
        {
            // is nil explicitely allowed?
            if (expectedArguments[1+i*2+0]&amp;SIM_SCRIPT_ARG_NULL_ALLOWED)
            { // yes. This is for an argument that can optionally also be nil.
                CScriptFunctionDataItem dat;
                inOutData.push_back(dat);
                done=true;
            }
            else
            { // no
                if (int(inOutData.size())&lt;requiredArgumentCount)
                {
                    std::ostringstream str;
                    str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " is not correct.";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
                break; // this argument is nil, so it is like inexistant. But we also won't explore any more arguments, we have enough.
            }
        }
        if (!done)
        {
            int tableSize=simGetStackTableInfo(stack,0);
            bool expectingATable=(((expectedArguments[1+i*2+0]|SIM_SCRIPT_ARG_NULL_ALLOWED)-SIM_SCRIPT_ARG_NULL_ALLOWED)&amp;sim_script_arg_table)!=0;
            if ( (tableSize&gt;=0)!=expectingATable )
            {
                std::ostringstream str;
                str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " is not correct.";
                simSetLastError(functionName,str.str().c_str());
                return(false);
            }
            int expectingType=(((expectedArguments[1+i*2+0]|SIM_SCRIPT_ARG_NULL_ALLOWED)-SIM_SCRIPT_ARG_NULL_ALLOWED)|sim_script_arg_table)-sim_script_arg_table;
            if (expectingATable)
            { // we have a table
                int infoType=0;
                if (expectingType==sim_script_arg_null)
                    infoType=1;
                if (expectingType==sim_script_arg_bool)
                    infoType=3;
                if (expectingType==sim_script_arg_float)
                    infoType=2;
                if (expectingType==sim_script_arg_int32)
                    infoType=2;
                if (expectingType==sim_script_arg_string)
                    infoType=4;
                if (expectingType==sim_script_arg_charbuff)
                    infoType=4;
                if (expectingType==sim_script_arg_double)
                    infoType=2;
                if (simGetStackTableInfo(stack,infoType)&lt;1)
                { // table content cannot be converted
                    std::ostringstream str;
                    str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " is not correct.";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }

                if ( (tableSize&lt;expectedArguments[1+i*2+1])&amp;&amp;(expectedArguments[1+i*2+1]!=0) )
                {
                    std::ostringstream str;
                    str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " is not correct (wrong table size).";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
                else
                {
                    int t=expectingType;
                    int itemCnt=tableSize;

                    if (t==sim_script_arg_null)
                    {
                        CScriptFunctionDataItem* a=new CScriptFunctionDataItem();
                        a-&gt;setNilTable(itemCnt);
                        CScriptFunctionDataItem dat;
                        dat.setNilTable(itemCnt);
                        inOutData.push_back(dat);
                    }
                    if (t==sim_script_arg_bool)
                    {
                        std::vector&lt;bool&gt; vect;
                        simUnfoldStackTable(stack); // this removes the table and exposes the inside
                        for (int j=0;j&lt;itemCnt;j++)
                        {
                            simBool val;
                            simGetStackBoolValue(stack,&amp;val);
                            vect.insert(vect.begin(),val!=0);
                            simPopStackItem(stack,2);
                        }
                        simPushTableOntoStack(stack); // empty table, will be removed at the end of the loop
                        CScriptFunctionDataItem dat(vect);
                        inOutData.push_back(dat);
                    }
                    if (t==sim_script_arg_int32)
                    {
                        std::vector&lt;int&gt; vect;
                        if (itemCnt&gt;0)
                        {
                            vect.resize(itemCnt);
                            simGetStackInt32Table(stack,&amp;vect[0],itemCnt);
                        }
                        CScriptFunctionDataItem dat(vect);
                        inOutData.push_back(dat);
                    }
                    if (t==sim_script_arg_float)
                    {
                        std::vector&lt;float&gt; vect;
                        if (itemCnt&gt;0)
                        {
                            vect.resize(itemCnt);
                            simGetStackFloatTable(stack,&amp;vect[0],itemCnt);
                        }
                        CScriptFunctionDataItem dat(vect);
                        inOutData.push_back(dat);
                    }
                    if (t==sim_script_arg_double)
                    {
                        std::vector&lt;double&gt; vect;
                        if (itemCnt&gt;0)
                        {
                            vect.resize(itemCnt);
                            simGetStackDoubleTable(stack,&amp;vect[0],itemCnt);
                        }
                        CScriptFunctionDataItem dat(vect);
                        inOutData.push_back(dat);
                    }
                    if (t==sim_script_arg_string)
                    {
                        std::vector&lt;std::string&gt; vect;
                        simUnfoldStackTable(stack); // this removes the table and exposes the inside
                        for (int j=0;j&lt;itemCnt;j++)
                        {
                            int l;
                            char* str=simGetStackStringValue(stack,&amp;l);
                            std::string str2(str); // treat it as a char string, not buffer
                            simReleaseBuffer(str);
                            vect.insert(vect.begin(),str2);
                            simPopStackItem(stack,2);
                        }
                        simPushTableOntoStack(stack); // empty table, will be removed at the end of the loop
                        CScriptFunctionDataItem dat(vect);
                        inOutData.push_back(dat);
                    }
                    if (t==sim_script_arg_charbuff)
                    {
                        std::ostringstream str;
                        str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " cannot be a table.";
                        simSetLastError(functionName,str.str().c_str());
                        return(false);
                    }
                }
            }
            else
            { // we do not have a table
                int t=expectingType;
                bool failedMsgAndLeave=false;
                if (t==sim_script_arg_null)
                {
                    if (simIsStackValueNull(stack)&gt;0)
                    {
                        CScriptFunctionDataItem dat;
                        inOutData.push_back(dat);
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (t==sim_script_arg_bool)
                {
                    simBool val=0;
                    if (simGetStackBoolValue(stack,&amp;val)==1)
                    {
                        CScriptFunctionDataItem dat(val!=0);
                        inOutData.push_back(dat);
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (t==sim_script_arg_int32)
                {
                    int val=0;
                    if (simGetStackInt32Value(stack,&amp;val)==1)
                    {
                        CScriptFunctionDataItem dat(val);
                        inOutData.push_back(dat);
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (t==sim_script_arg_float)
                {
                    float val=0.0;
                    if (simGetStackFloatValue(stack,&amp;val)==1)
                    {
                        CScriptFunctionDataItem dat(val);
                        inOutData.push_back(dat);
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (t==sim_script_arg_double)
                {
                    double val=0.0;
                    if (simGetStackDoubleValue(stack,&amp;val)==1)
                    {
                        CScriptFunctionDataItem dat(val);
                        inOutData.push_back(dat);
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (t==sim_script_arg_string)
                {
                    int l;
                    char* str=simGetStackStringValue(stack,&amp;l);
                    if (str!=NULL)
                    {
                        std::string str2(str);
                        simReleaseBuffer(str);
                        CScriptFunctionDataItem dat(str2); // treat it as a char string, not buffer
                        inOutData.push_back(dat);
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (t==sim_script_arg_charbuff)
                {
                    int l;
                    char* str=simGetStackStringValue(stack,&amp;l);
                    if (str!=NULL)
                    {
                        if ( (l&lt;expectedArguments[1+i*2+1])&amp;&amp;(expectedArguments[1+i*2+1]!=0) )
                        {
                            simReleaseBuffer(str);
                            std::ostringstream str;
                            str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " is not correct (wrong buffer size).";
                            simSetLastError(functionName,str.str().c_str());
                            return(false);
                        }
                        else
                        {
                            CScriptFunctionDataItem dat(str,l);
                            inOutData.push_back(dat);
                            simReleaseBuffer(str);
                        }
                    }
                    else
                        failedMsgAndLeave=true;
                }
                if (failedMsgAndLeave)
                {
                    std::ostringstream str;
                    str &lt;&lt; argumentText2 &lt;&lt; i+1 &lt;&lt; " is not correct.";
                    simSetLastError(functionName,str.str().c_str());
                    return(false);
                }
            }
        }
        simPopStackItem(stack,1);
    }
    return(true);
}

</t>
<t tx="leo.20220407205631.88">void CScriptFunctionData::_writeData(int stack,std::vector&lt;CScriptFunctionDataItem&gt;&amp; inOutData)
{
    simPopStackItem(stack,0); // Clear the stack

    int itemCnt=int(inOutData.size());

    for (int i=0;i&lt;itemCnt;i++)
    {
        if (inOutData[i].isTable())
        { // table
            if (inOutData[i].getType()==-1)
            { // nil table
                simPushTableOntoStack(stack);
                for (int j=0;j&lt;inOutData[i].getNilTableSize();j++)
                {
                    simPushInt32OntoStack(stack,j+1); // the key
                    simPushNullOntoStack(stack); // the value
                    simInsertDataIntoStackTable(stack);
                }
            }
            if (inOutData[i].getType()==0)
            { // bool table
                simPushTableOntoStack(stack);
                for (size_t j=0;j&lt;inOutData[i].boolData.size();j++)
                {
                    simPushInt32OntoStack(stack,(int)j+1); // the key
                    simPushBoolOntoStack(stack,inOutData[i].boolData[j]); // the value
                    simInsertDataIntoStackTable(stack);
                }
            }
            if (inOutData[i].getType()==1)
            { // int table
                if (inOutData[i].int32Data.size()&gt;0)
                    simPushInt32TableOntoStack(stack,&amp;inOutData[i].int32Data[0],int(inOutData[i].int32Data.size()));
                else
                    simPushTableOntoStack(stack);
            }
            if (inOutData[i].getType()==2)
            { // float table
                if (inOutData[i].floatData.size()&gt;0)
                    simPushFloatTableOntoStack(stack,&amp;inOutData[i].floatData[0],int(inOutData[i].floatData.size()));
                else
                    simPushTableOntoStack(stack);
            }
            if (inOutData[i].getType()==5)
            { // double table
                if (inOutData[i].doubleData.size()&gt;0)
                    simPushDoubleTableOntoStack(stack,&amp;inOutData[i].doubleData[0],int(inOutData[i].doubleData.size()));
                else
                    simPushTableOntoStack(stack);
            }
            if (inOutData[i].getType()==3)
            { // string table
                simPushTableOntoStack(stack);
                for (size_t j=0;j&lt;inOutData[i].stringData.size();j++)
                {
                    simPushInt32OntoStack(stack,(int)j+1); // the key
                    simPushStringOntoStack(stack,inOutData[i].stringData[j].c_str(),(int)inOutData[i].stringData[j].length()); // the value
                    simInsertDataIntoStackTable(stack);
                }
            }
        }
        else
        { // non-table values:
            if (inOutData[i].getType()==-1)
                simPushNullOntoStack(stack);
            if (inOutData[i].getType()==0)
                simPushBoolOntoStack(stack,inOutData[i].boolData[0]);
            if (inOutData[i].getType()==1)
                simPushInt32OntoStack(stack,inOutData[i].int32Data[0]);
            if (inOutData[i].getType()==2)
                simPushFloatOntoStack(stack,inOutData[i].floatData[0]);
            if (inOutData[i].getType()==5)
                simPushDoubleOntoStack(stack,inOutData[i].doubleData[0]);
            if ( (inOutData[i].getType()==3)||(inOutData[i].getType()==4) )
                simPushStringOntoStack(stack,inOutData[i].stringData[0].c_str(),(int)inOutData[i].stringData[0].length());
        }
    }
}
</t>
<t tx="leo.20220407205631.89">@path ./v-rep_plugin/coppelia/common/
#include "scriptFunctionDataItem.h"

CScriptFunctionDataItem::CScriptFunctionDataItem()
{
    _nilTableSize=0;
    _isTable=false;
    _type=-1; // nil
}

CScriptFunctionDataItem::CScriptFunctionDataItem(bool v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=0;
    boolData.push_back(v);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(int v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=1;
    int32Data.push_back(v);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(float v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=2;
    floatData.push_back(v);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(double v)
{
    _nilTableSize=0;
    _isTable=false;
    _type=5;
    doubleData.push_back(v);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const std::string&amp; str)
{
    _nilTableSize=0;
    _isTable=false;
    _type=3;
    stringData.push_back(str);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const char* str)
{
    _nilTableSize=0;
    _isTable=false;
    _type=3;
    stringData.push_back(str);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const char* bufferPtr,unsigned int bufferLength)
{
    _nilTableSize=0;
    _isTable=false;
    _type=4;
    std::string v(bufferPtr,bufferLength);
    stringData.push_back(v);
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const std::vector&lt;bool&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=0;
    boolData.assign(v.begin(),v.end());
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const std::vector&lt;int&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=1;
    int32Data.assign(v.begin(),v.end());
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const std::vector&lt;float&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=2;
    floatData.assign(v.begin(),v.end());
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const std::vector&lt;double&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=5;
    doubleData.assign(v.begin(),v.end());
}

CScriptFunctionDataItem::CScriptFunctionDataItem(const std::vector&lt;std::string&gt;&amp; v)
{
    _nilTableSize=0;
    _isTable=true;
    _type=3;
    stringData.assign(v.begin(),v.end());
}

CScriptFunctionDataItem::~CScriptFunctionDataItem()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.90">bool CScriptFunctionDataItem::isTable()
{
    return(_isTable);
}

</t>
<t tx="leo.20220407205631.91">int CScriptFunctionDataItem::getType()
{
    return(_type);
}

</t>
<t tx="leo.20220407205631.92">void CScriptFunctionDataItem::setNilTable(int size)
{
    if (_type==-1)
    {
        _isTable=true;
        _nilTableSize=size;
    }
}

</t>
<t tx="leo.20220407205631.93">int CScriptFunctionDataItem::getNilTableSize()
{
    return(_nilTableSize);
}
</t>
<t tx="leo.20220407205631.94">@path ./v-rep_plugin/coppelia/common/
#include "../include/simLib.h"
#include &lt;stdio.h&gt;
#if defined (__linux) || defined (__APPLE__)
    #include &lt;dlfcn.h&gt;
#endif

#ifndef SIM_LIBRARY

ptrSimRunSimulator simRunSimulator=nullptr;
ptrSimRunSimulatorEx simRunSimulatorEx=nullptr;
ptrSimGetSimulatorMessage simGetSimulatorMessage=nullptr;
ptrSimGetMainWindow simGetMainWindow=nullptr;
ptrSimGetLastError simGetLastError=nullptr;
ptrSimLoadModule simLoadModule=nullptr;
ptrSimUnloadModule simUnloadModule=nullptr;
ptrSimSendModuleMessage simSendModuleMessage=nullptr;
ptrSimSetBooleanParameter simSetBooleanParameter=nullptr;
ptrSimGetBooleanParameter simGetBooleanParameter=nullptr;
ptrSimSetBoolParameter simSetBoolParameter=nullptr;
ptrSimGetBoolParameter simGetBoolParameter=nullptr;
ptrSimSetIntegerParameter simSetIntegerParameter=nullptr;
ptrSimGetIntegerParameter simGetIntegerParameter=nullptr;
ptrSimSetInt32Parameter simSetInt32Parameter=nullptr;
ptrSimGetInt32Parameter simGetInt32Parameter=nullptr;
ptrSimGetUInt64Parameter simGetUInt64Parameter=nullptr;
ptrSimSetFloatingParameter simSetFloatingParameter=nullptr;
ptrSimGetFloatingParameter simGetFloatingParameter=nullptr;
ptrSimSetFloatParameter simSetFloatParameter=nullptr;
ptrSimGetFloatParameter simGetFloatParameter=nullptr;
ptrSimSetStringParameter simSetStringParameter=nullptr;
ptrSimGetStringParameter simGetStringParameter=nullptr;
ptrSimGetObjectHandle simGetObjectHandle=nullptr;
ptrSimRemoveObject simRemoveObject=nullptr;
ptrSimRemoveModel simRemoveModel=nullptr;
ptrSimGetObjectName simGetObjectName=nullptr;
ptrSimGetObjects simGetObjects=nullptr;
ptrSimSetObjectName simSetObjectName=nullptr;
ptrSimGetCollectionHandle simGetCollectionHandle=nullptr;
ptrSimRemoveCollection simRemoveCollection=nullptr;
ptrSimEmptyCollection simEmptyCollection=nullptr;
ptrSimGetCollectionName simGetCollectionName=nullptr;
ptrSimSetCollectionName simSetCollectionName=nullptr;
ptrSimGetObjectMatrix simGetObjectMatrix=nullptr;
ptrSimSetObjectMatrix simSetObjectMatrix=nullptr;
ptrSimGetObjectPosition simGetObjectPosition=nullptr;
ptrSimSetObjectPosition simSetObjectPosition=nullptr;
ptrSimGetObjectOrientation simGetObjectOrientation=nullptr;
ptrSimSetObjectOrientation simSetObjectOrientation=nullptr;
ptrSimGetJointPosition simGetJointPosition=nullptr;
ptrSimSetJointPosition simSetJointPosition=nullptr;
ptrSimSetJointTargetPosition simSetJointTargetPosition=nullptr;
ptrSimGetJointTargetPosition simGetJointTargetPosition=nullptr;
ptrSimSetJointMaxForce simSetJointMaxForce=nullptr;
ptrSimGetPathPosition simGetPathPosition=nullptr;
ptrSimSetPathPosition simSetPathPosition=nullptr;
ptrSimGetPathLength simGetPathLength=nullptr;
ptrSimGetJointMatrix simGetJointMatrix=nullptr;
ptrSimSetSphericalJointMatrix simSetSphericalJointMatrix=nullptr;
ptrSimGetJointInterval simGetJointInterval=nullptr;
ptrSimSetJointInterval simSetJointInterval=nullptr;
ptrSimGetObjectParent simGetObjectParent=nullptr;
ptrSimGetObjectChild simGetObjectChild=nullptr;
ptrSimSetObjectParent simSetObjectParent=nullptr;
ptrSimGetObjectType simGetObjectType=nullptr;
ptrSimGetJointType simGetJointType=nullptr;
ptrSimBuildIdentityMatrix simBuildIdentityMatrix=nullptr;
ptrSimCopyMatrix simCopyMatrix=nullptr;
ptrSimBuildMatrix simBuildMatrix=nullptr;
ptrSimGetEulerAnglesFromMatrix simGetEulerAnglesFromMatrix=nullptr;
ptrSimInvertMatrix simInvertMatrix=nullptr;
ptrSimMultiplyMatrices simMultiplyMatrices=nullptr;
ptrSimInterpolateMatrices simInterpolateMatrices=nullptr;
ptrSimTransformVector simTransformVector=nullptr;
ptrSimReservedCommand simReservedCommand=nullptr;
ptrSimGetSimulationTime simGetSimulationTime=nullptr;
ptrSimGetSimulationState simGetSimulationState=nullptr;
ptrSimGetSystemTime simGetSystemTime=nullptr;
ptrSimGetSystemTimeInMilliseconds simGetSystemTimeInMilliseconds=nullptr;
ptrSimGetSystemTimeInMs simGetSystemTimeInMs=nullptr;
ptrSimLoadScene simLoadScene=nullptr;
ptrSimCloseScene simCloseScene=nullptr;
ptrSimSaveScene simSaveScene=nullptr;
ptrSimLoadModel simLoadModel=nullptr;
ptrSimSaveModel simSaveModel=nullptr;
ptrSimAddStatusbarMessage simAddStatusbarMessage=nullptr;
ptrSimAddModuleMenuEntry simAddModuleMenuEntry=nullptr;
ptrSimSetModuleMenuItemState simSetModuleMenuItemState=nullptr;
ptrSimDoesFileExist simDoesFileExist=nullptr;
ptrSimIsObjectInSelection simIsObjectInSelection=nullptr;
ptrSimAddObjectToSelection simAddObjectToSelection=nullptr;
ptrSimRemoveObjectFromSelection simRemoveObjectFromSelection=nullptr;
ptrSimGetObjectSelectionSize simGetObjectSelectionSize=nullptr;
ptrSimGetObjectLastSelection simGetObjectLastSelection=nullptr;
ptrSimGetObjectSelection simGetObjectSelection=nullptr;
ptrSimHandleCollision simHandleCollision=nullptr;
ptrSimReadCollision simReadCollision=nullptr;
ptrSimHandleDistance simHandleDistance=nullptr;
ptrSimReadDistance simReadDistance=nullptr;
ptrSimHandleProximitySensor simHandleProximitySensor=nullptr;
ptrSimReadProximitySensor simReadProximitySensor=nullptr;
ptrSimHandleMill simHandleMill=nullptr;
ptrSimHandleIkGroup simHandleIkGroup=nullptr;
ptrSimCheckIkGroup simCheckIkGroup=nullptr;
ptrSimHandleDynamics simHandleDynamics=nullptr;
ptrSimGetScriptHandle simGetScriptHandle=nullptr;
ptrSimSetScriptText simSetScriptText=nullptr;
ptrSimGetScriptText simGetScriptText=nullptr;
ptrSimGetScriptProperty simGetScriptProperty=nullptr;
ptrSimAssociateScriptWithObject simAssociateScriptWithObject=nullptr;
ptrSimGetScript simGetScript=nullptr;
ptrSimGetScriptAssociatedWithObject simGetScriptAssociatedWithObject=nullptr;
ptrSimGetCustomizationScriptAssociatedWithObject simGetCustomizationScriptAssociatedWithObject=nullptr;
ptrSimGetObjectAssociatedWithScript simGetObjectAssociatedWithScript=nullptr;
ptrSimGetScriptName simGetScriptName=nullptr;
ptrSimHandleMainScript simHandleMainScript=nullptr;
ptrSimResetScript simResetScript=nullptr;
ptrSimAddScript simAddScript=nullptr;
ptrSimRemoveScript simRemoveScript=nullptr;
ptrSimRefreshDialogs simRefreshDialogs=nullptr;
ptrSimGetCollisionHandle simGetCollisionHandle=nullptr;
ptrSimGetDistanceHandle simGetDistanceHandle=nullptr;
ptrSimGetIkGroupHandle simGetIkGroupHandle=nullptr;
ptrSimResetCollision simResetCollision=nullptr;
ptrSimResetDistance simResetDistance=nullptr;
ptrSimResetProximitySensor simResetProximitySensor=nullptr;
ptrSimResetMill simResetMill=nullptr;
ptrSimCheckProximitySensor simCheckProximitySensor=nullptr;
ptrSimCheckProximitySensorEx simCheckProximitySensorEx=nullptr;
ptrSimCheckProximitySensorEx2 simCheckProximitySensorEx2=nullptr;
ptrSimCreateBuffer simCreateBuffer=nullptr;
ptrSimReleaseBuffer simReleaseBuffer=nullptr;
ptrSimCheckCollision simCheckCollision=nullptr;
ptrSimCheckCollisionEx simCheckCollisionEx=nullptr;
ptrSimCheckDistance simCheckDistance=nullptr;
ptrSimGetObjectConfiguration simGetObjectConfiguration=nullptr;
ptrSimSetObjectConfiguration simSetObjectConfiguration=nullptr;
ptrSimGetConfigurationTree simGetConfigurationTree=nullptr;
ptrSimSetConfigurationTree simSetConfigurationTree=nullptr;
ptrSimSetSimulationTimeStep simSetSimulationTimeStep=nullptr;
ptrSimGetSimulationTimeStep simGetSimulationTimeStep=nullptr;
ptrSimGetRealTimeSimulation simGetRealTimeSimulation=nullptr;
ptrSimIsRealTimeSimulationStepNeeded simIsRealTimeSimulationStepNeeded=nullptr;
ptrSimAdjustRealTimeTimer simAdjustRealTimeTimer=nullptr;
ptrSimGetSimulationPassesPerRenderingPass simGetSimulationPassesPerRenderingPass=nullptr;
ptrSimAdvanceSimulationByOneStep simAdvanceSimulationByOneStep=nullptr;
ptrSimStartSimulation simStartSimulation=nullptr;
ptrSimStopSimulation simStopSimulation=nullptr;
ptrSimPauseSimulation simPauseSimulation=nullptr;
ptrSimBroadcastMessage simBroadcastMessage=nullptr;
ptrSimGetModuleName simGetModuleName=nullptr;
ptrSimFloatingViewAdd simFloatingViewAdd=nullptr;
ptrSimFloatingViewRemove simFloatingViewRemove=nullptr;
ptrSimAdjustView simAdjustView=nullptr;
ptrSimSetLastError simSetLastError=nullptr;
ptrSimHandleGraph simHandleGraph=nullptr;
ptrSimResetGraph simResetGraph=nullptr;
ptrSimSetNavigationMode simSetNavigationMode=nullptr;
ptrSimGetNavigationMode simGetNavigationMode=nullptr;
ptrSimSetPage simSetPage=nullptr;
ptrSimGetPage simGetPage=nullptr;
ptrSimDisplayDialog simDisplayDialog=nullptr;
ptrSimGetDialogResult simGetDialogResult=nullptr;
ptrSimGetDialogInput simGetDialogInput=nullptr;
ptrSimEndDialog simEndDialog=nullptr;
ptrSimRegisterScriptCallbackFunction simRegisterScriptCallbackFunction=nullptr;
ptrSimRegisterScriptVariable simRegisterScriptVariable=nullptr;
ptrSimSetJointTargetVelocity simSetJointTargetVelocity=nullptr;
ptrSimGetJointTargetVelocity simGetJointTargetVelocity=nullptr;
ptrSimSetPathTargetNominalVelocity simSetPathTargetNominalVelocity=nullptr;
ptrSimGetScriptRawBuffer simGetScriptRawBuffer=nullptr;
ptrSimSetScriptRawBuffer simSetScriptRawBuffer=nullptr;
ptrSimReleaseScriptRawBuffer simReleaseScriptRawBuffer=nullptr;
ptrSimCopyPasteObjects simCopyPasteObjects=nullptr;
ptrSimScaleSelectedObjects simScaleSelectedObjects=nullptr;
ptrSimScaleObjects simScaleObjects=nullptr;
ptrSimDeleteSelectedObjects simDeleteSelectedObjects=nullptr;
ptrSimGetObjectUniqueIdentifier simGetObjectUniqueIdentifier=nullptr;
ptrSimGetNameSuffix simGetNameSuffix=nullptr;
ptrSimSendData simSendData=nullptr;
ptrSimReceiveData simReceiveData=nullptr;
ptrSimSetGraphUserData simSetGraphUserData=nullptr;
ptrSimSetNameSuffix simSetNameSuffix=nullptr;
ptrSimAddDrawingObject simAddDrawingObject=nullptr;
ptrSimRemoveDrawingObject simRemoveDrawingObject=nullptr;
ptrSimAddDrawingObjectItem simAddDrawingObjectItem=nullptr;
ptrSimAddParticleObject simAddParticleObject=nullptr;
ptrSimRemoveParticleObject simRemoveParticleObject=nullptr;
ptrSimAddParticleObjectItem simAddParticleObjectItem=nullptr;
ptrSimGetObjectSizeFactor simGetObjectSizeFactor=nullptr;
ptrSimAnnounceSceneContentChange simAnnounceSceneContentChange=nullptr;
ptrSimResetMilling simResetMilling=nullptr;
ptrSimApplyMilling simApplyMilling=nullptr;
ptrSimSetIntegerSignal simSetIntegerSignal=nullptr;
ptrSimGetIntegerSignal simGetIntegerSignal=nullptr;
ptrSimClearIntegerSignal simClearIntegerSignal=nullptr;
ptrSimSetFloatSignal simSetFloatSignal=nullptr;
ptrSimGetFloatSignal simGetFloatSignal=nullptr;
ptrSimClearFloatSignal simClearFloatSignal=nullptr;
ptrSimSetDoubleSignal simSetDoubleSignal=nullptr;
ptrSimGetDoubleSignal simGetDoubleSignal=nullptr;
ptrSimClearDoubleSignal simClearDoubleSignal=nullptr;
ptrSimSetStringSignal simSetStringSignal=nullptr;
ptrSimGetStringSignal simGetStringSignal=nullptr;
ptrSimClearStringSignal simClearStringSignal=nullptr;
ptrSimGetSignalName simGetSignalName=nullptr;
ptrSimSetObjectProperty simSetObjectProperty=nullptr;
ptrSimGetObjectProperty simGetObjectProperty=nullptr;
ptrSimSetObjectSpecialProperty simSetObjectSpecialProperty=nullptr;
ptrSimGetObjectSpecialProperty simGetObjectSpecialProperty=nullptr;
ptrSimGetPositionOnPath simGetPositionOnPath=nullptr;
ptrSimGetDataOnPath simGetDataOnPath=nullptr;
ptrSimGetOrientationOnPath simGetOrientationOnPath=nullptr;
ptrSimGetClosestPositionOnPath simGetClosestPositionOnPath=nullptr;
ptrSimReadForceSensor simReadForceSensor=nullptr;
ptrSimBreakForceSensor simBreakForceSensor=nullptr;
ptrSimGetShapeVertex simGetShapeVertex=nullptr;
ptrSimGetShapeTriangle simGetShapeTriangle=nullptr;
ptrSimSetLightParameters simSetLightParameters=nullptr;
ptrSimGetLightParameters simGetLightParameters=nullptr;
ptrSimGetVelocity simGetVelocity=nullptr;
ptrSimGetObjectVelocity simGetObjectVelocity=nullptr;
ptrSimAddForceAndTorque simAddForceAndTorque=nullptr;
ptrSimAddForce simAddForce=nullptr;
ptrSimSetExplicitHandling simSetExplicitHandling=nullptr;
ptrSimGetExplicitHandling simGetExplicitHandling=nullptr;
ptrSimGetLinkDummy simGetLinkDummy=nullptr;
ptrSimSetLinkDummy simSetLinkDummy=nullptr;
ptrSimSetModelProperty simSetModelProperty=nullptr;
ptrSimGetModelProperty simGetModelProperty=nullptr;
ptrSimSetShapeColor simSetShapeColor=nullptr;
ptrSimGetShapeColor simGetShapeColor=nullptr;
ptrSimResetDynamicObject simResetDynamicObject=nullptr;
ptrSimSetJointMode simSetJointMode=nullptr;
ptrSimGetJointMode simGetJointMode=nullptr;
ptrSimSerialOpen simSerialOpen=nullptr;
ptrSimSerialClose simSerialClose=nullptr;
ptrSimSerialSend simSerialSend=nullptr;
ptrSimSerialRead simSerialRead=nullptr;
ptrSimSerialCheck simSerialCheck=nullptr;
ptrSimGetContactInfo simGetContactInfo=nullptr;
ptrSimSetThreadIsFree simSetThreadIsFree=nullptr;
ptrSimTubeOpen simTubeOpen=nullptr;
ptrSimTubeClose simTubeClose=nullptr;
ptrSimTubeWrite simTubeWrite=nullptr;
ptrSimTubeRead simTubeRead=nullptr;
ptrSimTubeStatus simTubeStatus=nullptr;
ptrSimAuxiliaryConsoleOpen simAuxiliaryConsoleOpen=nullptr;
ptrSimAuxiliaryConsoleClose simAuxiliaryConsoleClose=nullptr;
ptrSimAuxiliaryConsoleShow simAuxiliaryConsoleShow=nullptr;
ptrSimAuxiliaryConsolePrint simAuxiliaryConsolePrint=nullptr;
ptrSimImportShape simImportShape=nullptr;
ptrSimImportMesh simImportMesh=nullptr;
ptrSimExportMesh simExportMesh=nullptr;
ptrSimCreateMeshShape simCreateMeshShape=nullptr;
ptrSimCreatePureShape simCreatePureShape=nullptr;
ptrSimCreateHeightfieldShape simCreateHeightfieldShape=nullptr;
ptrSimGetShapeMesh simGetShapeMesh=nullptr;
ptrSimAddBanner simAddBanner=nullptr;
ptrSimRemoveBanner simRemoveBanner=nullptr;
ptrSimCreateJoint simCreateJoint=nullptr;
ptrSimCreateDummy simCreateDummy=nullptr;
ptrSimCreateProximitySensor simCreateProximitySensor=nullptr;
ptrSimCreatePath simCreatePath=nullptr;
ptrSimInsertPathCtrlPoints simInsertPathCtrlPoints=nullptr;
ptrSimCutPathCtrlPoints simCutPathCtrlPoints=nullptr;
ptrSimCreateForceSensor simCreateForceSensor=nullptr;
ptrSimCreateVisionSensor simCreateVisionSensor=nullptr;
ptrSimGetObjectIntParameter simGetObjectIntParameter=nullptr;
ptrSimSetObjectIntParameter simSetObjectIntParameter=nullptr;
ptrSimGetObjectInt32Parameter simGetObjectInt32Parameter=nullptr;
ptrSimSetObjectInt32Parameter simSetObjectInt32Parameter=nullptr;
ptrSimGetObjectFloatParameter simGetObjectFloatParameter=nullptr;
ptrSimSetObjectFloatParameter simSetObjectFloatParameter=nullptr;
ptrSimGetObjectStringParameter simGetObjectStringParameter=nullptr;
ptrSimSetObjectStringParameter simSetObjectStringParameter=nullptr;
ptrSimSetSimulationPassesPerRenderingPass simSetSimulationPassesPerRenderingPass=nullptr;
ptrSimGetRotationAxis simGetRotationAxis=nullptr;
ptrSimRotateAroundAxis simRotateAroundAxis=nullptr;
ptrSimGetJointForce simGetJointForce=nullptr;
ptrSimGetJointMaxForce simGetJointMaxForce=nullptr;
ptrSimSetArrayParameter simSetArrayParameter=nullptr;
ptrSimGetArrayParameter simGetArrayParameter=nullptr;
ptrSimSetIkGroupProperties simSetIkGroupProperties=nullptr;
ptrSimSetIkElementProperties simSetIkElementProperties=nullptr;
ptrSimCameraFitToView simCameraFitToView=nullptr;
ptrSimPersistentDataWrite simPersistentDataWrite=nullptr;
ptrSimPersistentDataRead simPersistentDataRead=nullptr;
ptrSimIsHandleValid simIsHandleValid=nullptr;
ptrSimHandleVisionSensor simHandleVisionSensor=nullptr;
ptrSimReadVisionSensor simReadVisionSensor=nullptr;
ptrSimResetVisionSensor simResetVisionSensor=nullptr;
ptrSimCheckVisionSensor simCheckVisionSensor=nullptr;
ptrSimCheckVisionSensorEx simCheckVisionSensorEx=nullptr;
ptrSimGetVisionSensorResolution simGetVisionSensorResolution=nullptr;
ptrSimGetVisionSensorImage simGetVisionSensorImage=nullptr;
ptrSimGetVisionSensorCharImage simGetVisionSensorCharImage=nullptr;
ptrSimSetVisionSensorImage simSetVisionSensorImage=nullptr;
ptrSimSetVisionSensorCharImage simSetVisionSensorCharImage=nullptr;
ptrSimGetVisionSensorDepthBuffer simGetVisionSensorDepthBuffer=nullptr;
ptrSimGetObjectQuaternion simGetObjectQuaternion=nullptr;
ptrSimSetObjectQuaternion simSetObjectQuaternion=nullptr;
ptrSimRMLPosition simRMLPosition=nullptr;
ptrSimRMLVelocity simRMLVelocity=nullptr;
ptrSimRMLPos simRMLPos=nullptr;
ptrSimRMLVel simRMLVel=nullptr;
ptrSimRMLStep simRMLStep=nullptr;
ptrSimRMLRemove simRMLRemove=nullptr;
ptrSimBuildMatrixQ simBuildMatrixQ=nullptr;
ptrSimGetQuaternionFromMatrix simGetQuaternionFromMatrix=nullptr;
ptrSimFileDialog simFileDialog=nullptr;
ptrSimMsgBox simMsgBox=nullptr;
ptrSimSetShapeMassAndInertia simSetShapeMassAndInertia=nullptr;
ptrSimGetShapeMassAndInertia simGetShapeMassAndInertia=nullptr;
ptrSimGroupShapes simGroupShapes=nullptr;
ptrSimUngroupShape simUngroupShape=nullptr;
ptrSimConvexDecompose simConvexDecompose=nullptr;
ptrSimGetIkGroupMatrix simGetIkGroupMatrix=nullptr;
ptrSimAddGhost simAddGhost=nullptr;
ptrSimModifyGhost simModifyGhost=nullptr;
ptrSimQuitSimulator simQuitSimulator=nullptr;
ptrSimGetThreadId simGetThreadId=nullptr;
ptrSimLockResources simLockResources=nullptr;
ptrSimUnlockResources simUnlockResources=nullptr;
ptrSimEnableEventCallback simEnableEventCallback=nullptr;
ptrSimSetShapeMaterial simSetShapeMaterial=nullptr;
ptrSimGetTextureId simGetTextureId=nullptr;
ptrSimReadTexture simReadTexture=nullptr;
ptrSimWriteTexture simWriteTexture=nullptr;
ptrSimCreateTexture simCreateTexture=nullptr;
ptrSimWriteCustomDataBlock simWriteCustomDataBlock=nullptr;
ptrSimReadCustomDataBlock simReadCustomDataBlock=nullptr;
ptrSimReadCustomDataBlockTags simReadCustomDataBlockTags=nullptr;
ptrSimAddPointCloud simAddPointCloud=nullptr;
ptrSimModifyPointCloud simModifyPointCloud=nullptr;
ptrSimGetShapeGeomInfo simGetShapeGeomInfo=nullptr;
ptrSimGetObjectsInTree simGetObjectsInTree=nullptr;
ptrSimSetObjectSizeValues simSetObjectSizeValues=nullptr;
ptrSimGetObjectSizeValues simGetObjectSizeValues=nullptr;
ptrSimScaleObject simScaleObject=nullptr;
ptrSimSetShapeTexture simSetShapeTexture=nullptr;
ptrSimGetShapeTextureId simGetShapeTextureId=nullptr;
ptrSimGetCollectionObjects simGetCollectionObjects=nullptr;
ptrSimSetScriptAttribute simSetScriptAttribute=nullptr;
ptrSimGetScriptAttribute simGetScriptAttribute=nullptr;
ptrSimReorientShapeBoundingBox simReorientShapeBoundingBox=nullptr;
ptrSimSwitchThread simSwitchThread=nullptr;
ptrSimCreateIkGroup simCreateIkGroup=nullptr;
ptrSimRemoveIkGroup simRemoveIkGroup=nullptr;
ptrSimCreateIkElement simCreateIkElement=nullptr;
ptrSimCreateCollection simCreateCollection=nullptr;
ptrSimAddObjectToCollection simAddObjectToCollection=nullptr;
ptrSimSaveImage simSaveImage=nullptr;
ptrSimLoadImage simLoadImage=nullptr;
ptrSimGetScaledImage simGetScaledImage=nullptr;
ptrSimTransformImage simTransformImage=nullptr;
ptrSimGetQHull simGetQHull=nullptr;
ptrSimGetDecimatedMesh simGetDecimatedMesh=nullptr;
ptrSimExportIk simExportIk=nullptr;
ptrSimCallScriptFunctionEx simCallScriptFunctionEx=nullptr;
ptrSimComputeJacobian simComputeJacobian=nullptr;
ptrSimGetConfigForTipPose simGetConfigForTipPose=nullptr;
ptrSimGenerateIkPath simGenerateIkPath=nullptr;
ptrSimGetExtensionString simGetExtensionString=nullptr;
ptrSimComputeMassAndInertia simComputeMassAndInertia=nullptr;
ptrSimCreateStack simCreateStack=nullptr;
ptrSimReleaseStack simReleaseStack=nullptr;
ptrSimCopyStack simCopyStack=nullptr;
ptrSimPushNullOntoStack simPushNullOntoStack=nullptr;
ptrSimPushBoolOntoStack simPushBoolOntoStack=nullptr;
ptrSimPushInt32OntoStack simPushInt32OntoStack=nullptr;
ptrSimPushFloatOntoStack simPushFloatOntoStack=nullptr;
ptrSimPushDoubleOntoStack simPushDoubleOntoStack=nullptr;
ptrSimPushStringOntoStack simPushStringOntoStack=nullptr;
ptrSimPushUInt8TableOntoStack simPushUInt8TableOntoStack=nullptr;
ptrSimPushInt32TableOntoStack simPushInt32TableOntoStack=nullptr;
ptrSimPushFloatTableOntoStack simPushFloatTableOntoStack=nullptr;
ptrSimPushDoubleTableOntoStack simPushDoubleTableOntoStack=nullptr;
ptrSimPushTableOntoStack simPushTableOntoStack=nullptr;
ptrSimInsertDataIntoStackTable simInsertDataIntoStackTable=nullptr;
ptrSimGetStackSize simGetStackSize=nullptr;
ptrSimPopStackItem simPopStackItem=nullptr;
ptrSimMoveStackItemToTop simMoveStackItemToTop=nullptr;
ptrSimIsStackValueNull simIsStackValueNull=nullptr;
ptrSimGetStackBoolValue simGetStackBoolValue=nullptr;
ptrSimGetStackInt32Value simGetStackInt32Value=nullptr;
ptrSimGetStackFloatValue simGetStackFloatValue=nullptr;
ptrSimGetStackDoubleValue simGetStackDoubleValue=nullptr;
ptrSimGetStackStringValue simGetStackStringValue=nullptr;
ptrSimGetStackTableInfo simGetStackTableInfo=nullptr;
ptrSimGetStackUInt8Table simGetStackUInt8Table=nullptr;
ptrSimGetStackInt32Table simGetStackInt32Table=nullptr;
ptrSimGetStackFloatTable simGetStackFloatTable=nullptr;
ptrSimGetStackDoubleTable simGetStackDoubleTable=nullptr;
ptrSimUnfoldStackTable simUnfoldStackTable=nullptr;
ptrSimDebugStack simDebugStack=nullptr;
ptrSimSetScriptVariable simSetScriptVariable=nullptr;
ptrSimGetEngineFloatParameter simGetEngineFloatParameter=nullptr;
ptrSimGetEngineInt32Parameter simGetEngineInt32Parameter=nullptr;
ptrSimGetEngineBoolParameter simGetEngineBoolParameter=nullptr;
ptrSimSetEngineFloatParameter simSetEngineFloatParameter=nullptr;
ptrSimSetEngineInt32Parameter simSetEngineInt32Parameter=nullptr;
ptrSimSetEngineBoolParameter simSetEngineBoolParameter=nullptr;
ptrSimCreateOctree simCreateOctree=nullptr;
ptrSimCreatePointCloud simCreatePointCloud=nullptr;
ptrSimSetPointCloudOptions simSetPointCloudOptions=nullptr;
ptrSimGetPointCloudOptions simGetPointCloudOptions=nullptr;
ptrSimInsertVoxelsIntoOctree simInsertVoxelsIntoOctree=nullptr;
ptrSimRemoveVoxelsFromOctree simRemoveVoxelsFromOctree=nullptr;
ptrSimInsertPointsIntoPointCloud simInsertPointsIntoPointCloud=nullptr;
ptrSimRemovePointsFromPointCloud simRemovePointsFromPointCloud=nullptr;
ptrSimIntersectPointsWithPointCloud simIntersectPointsWithPointCloud=nullptr;
ptrSimGetOctreeVoxels simGetOctreeVoxels=nullptr;
ptrSimGetPointCloudPoints simGetPointCloudPoints=nullptr;
ptrSimInsertObjectIntoOctree simInsertObjectIntoOctree=nullptr;
ptrSimSubtractObjectFromOctree simSubtractObjectFromOctree=nullptr;
ptrSimInsertObjectIntoPointCloud simInsertObjectIntoPointCloud=nullptr;
ptrSimSubtractObjectFromPointCloud simSubtractObjectFromPointCloud=nullptr;
ptrSimCheckOctreePointOccupancy simCheckOctreePointOccupancy=nullptr;
ptrSimOpenTextEditor simOpenTextEditor=nullptr;
ptrSimPackTable simPackTable=nullptr;
ptrSimUnpackTable simUnpackTable=nullptr;
ptrSimSetReferencedHandles simSetReferencedHandles=nullptr;
ptrSimGetReferencedHandles simGetReferencedHandles=nullptr;
ptrSimGetShapeViz simGetShapeViz=nullptr;
ptrSimExecuteScriptString simExecuteScriptString=nullptr;
ptrSimGetApiFunc simGetApiFunc=nullptr;
ptrSimGetApiInfo simGetApiInfo=nullptr;
ptrSimSetModuleInfo simSetModuleInfo=nullptr;
ptrSimGetModuleInfo simGetModuleInfo=nullptr;
ptrSimIsDeprecated simIsDeprecated=nullptr;
ptrSimGetPersistentDataTags simGetPersistentDataTags=nullptr;
ptrSimEventNotification simEventNotification=nullptr;
ptrSimApplyTexture simApplyTexture=nullptr;
ptrSimSetJointDependency simSetJointDependency=nullptr;
ptrSimSetStringNamedParam simSetStringNamedParam=nullptr;
ptrSimGetStringNamedParam simGetStringNamedParam=nullptr;
ptrSimGetUserParameter simGetUserParameter=nullptr;
ptrSimSetUserParameter simSetUserParameter=nullptr;


// Following courtesy of Stephen James:
ptrSimExtLaunchUIThread simExtLaunchUIThread=nullptr;
ptrSimExtCanInitSimThread simExtCanInitSimThread=nullptr;
ptrSimExtSimThreadInit simExtSimThreadInit=nullptr;
ptrSimExtSimThreadDestroy simExtSimThreadDestroy=nullptr;
ptrSimExtPostExitRequest simExtPostExitRequest=nullptr;
ptrSimExtGetExitRequest simExtGetExitRequest=nullptr;
ptrSimExtStep simExtStep=nullptr;
ptrSimExtCallScriptFunction simExtCallScriptFunction=nullptr;



ptr_simGetContactCallbackCount _simGetContactCallbackCount=nullptr;
ptr_simGetContactCallback _simGetContactCallback=nullptr;
ptr_simSetDynamicSimulationIconCode _simSetDynamicSimulationIconCode=nullptr;
ptr_simSetDynamicObjectFlagForVisualization _simSetDynamicObjectFlagForVisualization=nullptr;
ptr_simGetObjectListSize _simGetObjectListSize=nullptr;
ptr_simGetObjectFromIndex _simGetObjectFromIndex=nullptr;
ptr_simGetObjectID _simGetObjectID=nullptr;
ptr_simGetObjectType _simGetObjectType=nullptr;
ptr_simGetObjectChildren _simGetObjectChildren=nullptr;
ptr_simGetGeomProxyFromShape _simGetGeomProxyFromShape=nullptr;
ptr_simGetParentObject _simGetParentObject=nullptr;
ptr_simGetObject _simGetObject=nullptr;
ptr_simGetIkGroupObject _simGetIkGroupObject=nullptr;
ptr_simMpHandleIkGroupObject _simMpHandleIkGroupObject=nullptr;
ptr_simGetObjectLocalTransformation _simGetObjectLocalTransformation=nullptr;
ptr_simSetObjectLocalTransformation _simSetObjectLocalTransformation=nullptr;
ptr_simSetObjectCumulativeTransformation _simSetObjectCumulativeTransformation=nullptr;
ptr_simGetObjectCumulativeTransformation _simGetObjectCumulativeTransformation=nullptr;
ptr_simIsShapeDynamicallyStatic _simIsShapeDynamicallyStatic=nullptr;
ptr_simGetTreeDynamicProperty _simGetTreeDynamicProperty=nullptr;
ptr_simGetDummyLinkType _simGetDummyLinkType=nullptr;
ptr_simGetJointMode _simGetJointMode=nullptr;
ptr_simIsJointInHybridOperation _simIsJointInHybridOperation=nullptr;
ptr_simDisableDynamicTreeForManipulation _simDisableDynamicTreeForManipulation=nullptr;
ptr_simIsShapeDynamicallyRespondable _simIsShapeDynamicallyRespondable=nullptr;
ptr_simGetDynamicCollisionMask _simGetDynamicCollisionMask=nullptr;
ptr_simGetLastParentForLocalGlobalCollidable _simGetLastParentForLocalGlobalCollidable=nullptr;
ptr_simSetShapeIsStaticAndNotRespondableButDynamicTag _simSetShapeIsStaticAndNotRespondableButDynamicTag=nullptr;
ptr_simGetShapeIsStaticAndNotRespondableButDynamicTag _simGetShapeIsStaticAndNotRespondableButDynamicTag=nullptr;
ptr_simSetJointPosition _simSetJointPosition=nullptr;
ptr_simGetJointPosition _simGetJointPosition=nullptr;
ptr_simSetDynamicMotorPositionControlTargetPosition _simSetDynamicMotorPositionControlTargetPosition=nullptr;
ptr_simGetInitialDynamicVelocity _simGetInitialDynamicVelocity=nullptr;
ptr_simSetInitialDynamicVelocity _simSetInitialDynamicVelocity=nullptr;
ptr_simGetInitialDynamicAngVelocity _simGetInitialDynamicAngVelocity=nullptr;
ptr_simSetInitialDynamicAngVelocity _simSetInitialDynamicAngVelocity=nullptr;
ptr_simGetStartSleeping _simGetStartSleeping=nullptr;
ptr_simGetWasPutToSleepOnce _simGetWasPutToSleepOnce=nullptr;
ptr_simGetDynamicsFullRefreshFlag _simGetDynamicsFullRefreshFlag=nullptr;
ptr_simSetDynamicsFullRefreshFlag _simSetDynamicsFullRefreshFlag=nullptr;
ptr_simSetGeomProxyDynamicsFullRefreshFlag _simSetGeomProxyDynamicsFullRefreshFlag=nullptr;
ptr_simGetGeomProxyDynamicsFullRefreshFlag _simGetGeomProxyDynamicsFullRefreshFlag=nullptr;
ptr_simGetParentFollowsDynamic _simGetParentFollowsDynamic=nullptr;
ptr_simSetShapeDynamicVelocity _simSetShapeDynamicVelocity=nullptr;
ptr_simGetAdditionalForceAndTorque _simGetAdditionalForceAndTorque=nullptr;
ptr_simClearAdditionalForceAndTorque _simClearAdditionalForceAndTorque=nullptr;
ptr_simGetJointPositionInterval _simGetJointPositionInterval=nullptr;
ptr_simGetJointType _simGetJointType=nullptr;
ptr_simIsForceSensorBroken _simIsForceSensorBroken=nullptr;
ptr_simGetDynamicForceSensorLocalTransformationPart2 _simGetDynamicForceSensorLocalTransformationPart2=nullptr;
ptr_simIsDynamicMotorEnabled _simIsDynamicMotorEnabled=nullptr;
ptr_simIsDynamicMotorPositionCtrlEnabled _simIsDynamicMotorPositionCtrlEnabled=nullptr;
ptr_simIsDynamicMotorTorqueModulationEnabled _simIsDynamicMotorTorqueModulationEnabled=nullptr;
ptr_simGetMotorPid _simGetMotorPid=nullptr;
ptr_simGetDynamicMotorTargetPosition _simGetDynamicMotorTargetPosition=nullptr;
ptr_simGetDynamicMotorTargetVelocity _simGetDynamicMotorTargetVelocity=nullptr;
ptr_simGetDynamicMotorMaxForce _simGetDynamicMotorMaxForce=nullptr;
ptr_simGetDynamicMotorUpperLimitVelocity _simGetDynamicMotorUpperLimitVelocity=nullptr;
ptr_simSetDynamicMotorReflectedPositionFromDynamicEngine _simSetDynamicMotorReflectedPositionFromDynamicEngine=nullptr;
ptr_simSetJointSphericalTransformation _simSetJointSphericalTransformation=nullptr;
ptr_simAddForceSensorCumulativeForcesAndTorques _simAddForceSensorCumulativeForcesAndTorques=nullptr;
ptr_simAddJointCumulativeForcesOrTorques _simAddJointCumulativeForcesOrTorques=nullptr;
ptr_simSetDynamicJointLocalTransformationPart2 _simSetDynamicJointLocalTransformationPart2=nullptr;
ptr_simSetDynamicForceSensorLocalTransformationPart2 _simSetDynamicForceSensorLocalTransformationPart2=nullptr;
ptr_simSetDynamicJointLocalTransformationPart2IsValid _simSetDynamicJointLocalTransformationPart2IsValid=nullptr;
ptr_simSetDynamicForceSensorLocalTransformationPart2IsValid _simSetDynamicForceSensorLocalTransformationPart2IsValid=nullptr;
ptr_simGetGeomWrapFromGeomProxy _simGetGeomWrapFromGeomProxy=nullptr;
ptr_simGetLocalInertiaFrame _simGetLocalInertiaFrame=nullptr;
ptr_simGetPurePrimitiveType _simGetPurePrimitiveType=nullptr;
ptr_simIsGeomWrapGeometric _simIsGeomWrapGeometric=nullptr;
ptr_simIsGeomWrapConvex _simIsGeomWrapConvex=nullptr;
ptr_simGetGeometricCount _simGetGeometricCount=nullptr;
ptr_simGetAllGeometrics _simGetAllGeometrics=nullptr;
ptr_simGetPurePrimitiveSizes _simGetPurePrimitiveSizes=nullptr;
ptr_simMakeDynamicAnnouncement _simMakeDynamicAnnouncement=nullptr;
ptr_simGetVerticesLocalFrame _simGetVerticesLocalFrame=nullptr;
ptr_simGetHeightfieldData _simGetHeightfieldData=nullptr;
ptr_simGetCumulativeMeshes _simGetCumulativeMeshes=nullptr;
ptr_simGetMass _simGetMass=nullptr;
ptr_simGetPrincipalMomentOfInertia _simGetPrincipalMomentOfInertia=nullptr;
ptr_simGetGravity _simGetGravity=nullptr;
ptr_simGetTimeDiffInMs _simGetTimeDiffInMs=nullptr;
ptr_simDoEntitiesCollide _simDoEntitiesCollide=nullptr;
ptr_simGetDistanceBetweenEntitiesIfSmaller _simGetDistanceBetweenEntitiesIfSmaller=nullptr;
ptr_simHandleJointControl _simHandleJointControl=nullptr;
ptr_simHandleCustomContact _simHandleCustomContact=nullptr;
ptr_simGetPureHollowScaling _simGetPureHollowScaling=nullptr;
ptr_simGetJointCallbackCallOrder _simGetJointCallbackCallOrder=nullptr;
ptr_simDynCallback _simDynCallback=nullptr;


// Deprecated begin
ptrSimGetMaterialId simGetMaterialId=nullptr;
ptrSimGetShapeMaterial simGetShapeMaterial=nullptr;
ptrSimHandleVarious simHandleVarious=nullptr;
ptrSimSerialPortOpen simSerialPortOpen=nullptr;
ptrSimSerialPortClose simSerialPortClose=nullptr;
ptrSimSerialPortSend simSerialPortSend=nullptr;
ptrSimSerialPortRead simSerialPortRead=nullptr;
ptrSimJointGetForce simJointGetForce=nullptr;
ptrSimGetPathPlanningHandle simGetPathPlanningHandle=nullptr;
ptrSimGetMotionPlanningHandle simGetMotionPlanningHandle=nullptr;
ptrSimGetMpConfigForTipPose simGetMpConfigForTipPose=nullptr;
ptrSimFindMpPath simFindMpPath=nullptr;
ptrSimSimplifyMpPath simSimplifyMpPath=nullptr;
ptrSimGetMpConfigTransition simGetMpConfigTransition=nullptr;
ptrSimFindIkPath simFindIkPath=nullptr;
ptrSimCreateMotionPlanning simCreateMotionPlanning=nullptr;
ptrSimRemoveMotionPlanning simRemoveMotionPlanning=nullptr;
ptrSimSearchPath simSearchPath=nullptr;
ptrSimInitializePathSearch simInitializePathSearch=nullptr;
ptrSimPerformPathSearchStep simPerformPathSearchStep=nullptr;
ptrSimLockInterface simLockInterface=nullptr;
ptrSimCopyPasteSelectedObjects simCopyPasteSelectedObjects=nullptr;
ptrSimResetPath simResetPath=nullptr;
ptrSimHandlePath simHandlePath=nullptr;
ptrSimResetJoint simResetJoint=nullptr;
ptrSimHandleJoint simHandleJoint=nullptr;
ptrSimAppendScriptArrayEntry simAppendScriptArrayEntry=nullptr;
ptrSimClearScriptVariable simClearScriptVariable=nullptr;
ptr_simGetJointOdeParameters _simGetJointOdeParameters=nullptr;
ptr_simGetJointBulletParameters _simGetJointBulletParameters=nullptr;
ptr_simGetOdeMaxContactFrictionCFMandERP _simGetOdeMaxContactFrictionCFMandERP=nullptr;
ptr_simGetBulletCollisionMargin _simGetBulletCollisionMargin=nullptr;
ptr_simGetBulletStickyContact _simGetBulletStickyContact=nullptr;
ptr_simGetBulletRestitution _simGetBulletRestitution=nullptr;
ptr_simGetVortexParameters _simGetVortexParameters=nullptr;
ptr_simGetNewtonParameters _simGetNewtonParameters=nullptr;
ptr_simGetDamping _simGetDamping=nullptr;
ptr_simGetFriction _simGetFriction=nullptr;
ptrSimAddSceneCustomData simAddSceneCustomData=nullptr;
ptrSimGetSceneCustomDataLength simGetSceneCustomDataLength=nullptr;
ptrSimGetSceneCustomData simGetSceneCustomData=nullptr;
ptrSimAddObjectCustomData simAddObjectCustomData=nullptr;
ptrSimGetObjectCustomDataLength simGetObjectCustomDataLength=nullptr;
ptrSimGetObjectCustomData simGetObjectCustomData=nullptr;
ptrSimCreateUI simCreateUI=nullptr;
ptrSimCreateUIButton simCreateUIButton=nullptr;
ptrSimGetUIHandle simGetUIHandle=nullptr;
ptrSimGetUIProperty simGetUIProperty=nullptr;
ptrSimGetUIEventButton simGetUIEventButton=nullptr;
ptrSimSetUIProperty simSetUIProperty=nullptr;
ptrSimGetUIButtonProperty simGetUIButtonProperty=nullptr;
ptrSimSetUIButtonProperty simSetUIButtonProperty=nullptr;
ptrSimGetUIButtonSize simGetUIButtonSize=nullptr;
ptrSimSetUIButtonLabel simSetUIButtonLabel=nullptr;
ptrSimGetUIButtonLabel simGetUIButtonLabel=nullptr;
ptrSimSetUISlider simSetUISlider=nullptr;
ptrSimGetUISlider simGetUISlider=nullptr;
ptrSimSetUIButtonColor simSetUIButtonColor=nullptr;
ptrSimSetUIButtonTexture simSetUIButtonTexture=nullptr;
ptrSimCreateUIButtonArray simCreateUIButtonArray=nullptr;
ptrSimSetUIButtonArrayColor simSetUIButtonArrayColor=nullptr;
ptrSimDeleteUIButtonArray simDeleteUIButtonArray=nullptr;
ptrSimRemoveUI simRemoveUI=nullptr;
ptrSimSetUIPosition simSetUIPosition=nullptr;
ptrSimGetUIPosition simGetUIPosition=nullptr;
ptrSimLoadUI simLoadUI=nullptr;
ptrSimSaveUI simSaveUI=nullptr;
ptrSimHandleGeneralCallbackScript simHandleGeneralCallbackScript=nullptr;
ptrSimRegisterCustomLuaFunction simRegisterCustomLuaFunction=nullptr;
ptrSimRegisterCustomLuaVariable simRegisterCustomLuaVariable=nullptr;
ptrSimRegisterContactCallback simRegisterContactCallback=nullptr;
ptrSimGetMechanismHandle simGetMechanismHandle=nullptr;
ptrSimHandleMechanism simHandleMechanism=nullptr;
ptrSimHandleCustomizationScripts simHandleCustomizationScripts=nullptr;
ptrSimCallScriptFunction simCallScriptFunction=nullptr;
ptrSimSetVisionSensorFilter simSetVisionSensorFilter=nullptr;
ptrSimGetVisionSensorFilter simGetVisionSensorFilter=nullptr;
ptrSimGetScriptSimulationParameter simGetScriptSimulationParameter=nullptr;
ptrSimSetScriptSimulationParameter simSetScriptSimulationParameter=nullptr;
ptrSimSetJointForce simSetJointForce=nullptr;
// Deprecated end


LIBRARY loadSimLibrary(const char* pathAndFilename)
{
    #ifdef QT_FRAMEWORK
        QLibrary* lib=new QLibrary(pathAndFilename);
        if (!lib-&gt;load())
        {
            delete lib;
            lib=NULL;
        }
        return lib;
    #else
        #ifdef _WIN32
            return LoadLibraryA(pathAndFilename);
        #elif defined (__linux) || defined (__APPLE__)
            return dlopen(pathAndFilename,RTLD_LAZY);
        #endif
    #endif // QT_FRAMEWORK
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.95">void unloadSimLibrary(LIBRARY lib)
{
    #ifdef QT_FRAMEWORK
        if (lib!=0)
        {
            lib-&gt;unload();
            delete lib;
        }
    #else
        #ifdef _WIN32
            if (lib!=0)
                FreeLibrary(lib);
        #elif defined (__linux) || defined (__APPLE__)
                dlclose(lib);
        #endif
    #endif // QT_FRAMEWORK
}

FARPROC _getProcAddress(LIBRARY lib,const char* funcName)
{
    #ifdef QT_FRAMEWORK
        return (void*)lib-&gt;resolve(funcName);
    #else
        #ifdef _WIN32
            return GetProcAddress(lib,funcName);
        #elif defined (__linux) || defined (__APPLE__)
            return dlsym(lib,funcName);
        #endif
    #endif // QT_FRAMEWORK
}

</t>
<t tx="leo.20220407205631.96">int getSimProcAddresses(LIBRARY lib)
{
    simRunSimulator=(ptrSimRunSimulator)(_getProcAddress(lib,"simRunSimulator"));
    simRunSimulatorEx=(ptrSimRunSimulatorEx)(_getProcAddress(lib,"simRunSimulatorEx"));
    simGetSimulatorMessage=(ptrSimGetSimulatorMessage)(_getProcAddress(lib,"simGetSimulatorMessage"));
    simGetMainWindow=(ptrSimGetMainWindow)(_getProcAddress(lib,"simGetMainWindow"));
    simGetLastError=(ptrSimGetLastError)(_getProcAddress(lib,"simGetLastError"));
    simLoadModule=(ptrSimLoadModule)(_getProcAddress(lib,"simLoadModule"));
    simUnloadModule=(ptrSimUnloadModule)(_getProcAddress(lib,"simUnloadModule"));
    simSendModuleMessage=(ptrSimSendModuleMessage)(_getProcAddress(lib,"simSendModuleMessage"));
    simSetBooleanParameter=(ptrSimSetBooleanParameter)(_getProcAddress(lib,"simSetBooleanParameter"));
    simGetBooleanParameter=(ptrSimGetBooleanParameter)(_getProcAddress(lib,"simGetBooleanParameter"));
    simSetBoolParameter=(ptrSimSetBoolParameter)(_getProcAddress(lib,"simSetBoolParameter"));
    simGetBoolParameter=(ptrSimGetBoolParameter)(_getProcAddress(lib,"simGetBoolParameter"));
    simSetIntegerParameter=(ptrSimSetIntegerParameter)(_getProcAddress(lib,"simSetIntegerParameter"));
    simGetIntegerParameter=(ptrSimGetIntegerParameter)(_getProcAddress(lib,"simGetIntegerParameter"));
    simSetInt32Parameter=(ptrSimSetInt32Parameter)(_getProcAddress(lib,"simSetInt32Parameter"));
    simGetInt32Parameter=(ptrSimGetInt32Parameter)(_getProcAddress(lib,"simGetInt32Parameter"));
    simGetUInt64Parameter=(ptrSimGetUInt64Parameter)(_getProcAddress(lib,"simGetUInt64Parameter"));
    simSetFloatingParameter=(ptrSimSetFloatingParameter)(_getProcAddress(lib,"simSetFloatingParameter"));
    simGetFloatingParameter=(ptrSimGetFloatingParameter)(_getProcAddress(lib,"simGetFloatingParameter"));
    simSetFloatParameter=(ptrSimSetFloatParameter)(_getProcAddress(lib,"simSetFloatParameter"));
    simGetFloatParameter=(ptrSimGetFloatParameter)(_getProcAddress(lib,"simGetFloatParameter"));
    simSetStringParameter=(ptrSimSetStringParameter)(_getProcAddress(lib,"simSetStringParameter"));
    simGetStringParameter=(ptrSimGetStringParameter)(_getProcAddress(lib,"simGetStringParameter"));
    simGetObjectHandle=(ptrSimGetObjectHandle)(_getProcAddress(lib,"simGetObjectHandle"));
    simRemoveObject=(ptrSimRemoveObject)(_getProcAddress(lib,"simRemoveObject"));
    simRemoveModel=(ptrSimRemoveModel)(_getProcAddress(lib,"simRemoveModel"));
    simGetObjectName=(ptrSimGetObjectName)(_getProcAddress(lib,"simGetObjectName"));
    simGetObjects=(ptrSimGetObjects)(_getProcAddress(lib,"simGetObjects"));
    simSetObjectName=(ptrSimSetObjectName)(_getProcAddress(lib,"simSetObjectName"));
    simGetCollectionHandle=(ptrSimGetCollectionHandle)(_getProcAddress(lib,"simGetCollectionHandle"));
    simRemoveCollection=(ptrSimRemoveCollection)(_getProcAddress(lib,"simRemoveCollection"));
    simEmptyCollection=(ptrSimEmptyCollection)(_getProcAddress(lib,"simEmptyCollection"));
    simGetCollectionName=(ptrSimGetCollectionName)(_getProcAddress(lib,"simGetCollectionName"));
    simSetCollectionName=(ptrSimSetCollectionName)(_getProcAddress(lib,"simSetCollectionName"));
    simGetObjectMatrix=(ptrSimGetObjectMatrix)(_getProcAddress(lib,"simGetObjectMatrix"));
    simSetObjectMatrix=(ptrSimSetObjectMatrix)(_getProcAddress(lib,"simSetObjectMatrix"));
    simGetObjectPosition=(ptrSimGetObjectPosition)(_getProcAddress(lib,"simGetObjectPosition"));
    simSetObjectPosition=(ptrSimSetObjectPosition)(_getProcAddress(lib,"simSetObjectPosition"));
    simGetObjectOrientation=(ptrSimGetObjectOrientation)(_getProcAddress(lib,"simGetObjectOrientation"));
    simSetObjectOrientation=(ptrSimSetObjectOrientation)(_getProcAddress(lib,"simSetObjectOrientation"));
    simGetJointPosition=(ptrSimGetJointPosition)(_getProcAddress(lib,"simGetJointPosition"));
    simSetJointPosition=(ptrSimSetJointPosition)(_getProcAddress(lib,"simSetJointPosition"));
    simSetJointTargetPosition=(ptrSimSetJointTargetPosition)(_getProcAddress(lib,"simSetJointTargetPosition"));
    simGetJointTargetPosition=(ptrSimGetJointTargetPosition)(_getProcAddress(lib,"simGetJointTargetPosition"));
    simSetJointMaxForce=(ptrSimSetJointMaxForce)(_getProcAddress(lib,"simSetJointMaxForce"));
    simGetPathPosition=(ptrSimGetPathPosition)(_getProcAddress(lib,"simGetPathPosition"));
    simSetPathPosition=(ptrSimSetPathPosition)(_getProcAddress(lib,"simSetPathPosition"));
    simGetPathLength=(ptrSimGetPathLength)(_getProcAddress(lib,"simGetPathLength"));
    simGetJointMatrix=(ptrSimGetJointMatrix)(_getProcAddress(lib,"simGetJointMatrix"));
    simSetSphericalJointMatrix=(ptrSimSetSphericalJointMatrix)(_getProcAddress(lib,"simSetSphericalJointMatrix"));
    simGetJointInterval=(ptrSimGetJointInterval)(_getProcAddress(lib,"simGetJointInterval"));
    simSetJointInterval=(ptrSimSetJointInterval)(_getProcAddress(lib,"simSetJointInterval"));
    simGetObjectParent=(ptrSimGetObjectParent)(_getProcAddress(lib,"simGetObjectParent"));
    simGetObjectChild=(ptrSimGetObjectChild)(_getProcAddress(lib,"simGetObjectChild"));
    simSetObjectParent=(ptrSimSetObjectParent)(_getProcAddress(lib,"simSetObjectParent"));
    simGetObjectType=(ptrSimGetObjectType)(_getProcAddress(lib,"simGetObjectType"));
    simGetJointType=(ptrSimGetJointType)(_getProcAddress(lib,"simGetJointType"));
    simBuildIdentityMatrix=(ptrSimBuildIdentityMatrix)(_getProcAddress(lib,"simBuildIdentityMatrix"));
    simCopyMatrix=(ptrSimCopyMatrix)(_getProcAddress(lib,"simCopyMatrix"));
    simBuildMatrix=(ptrSimBuildMatrix)(_getProcAddress(lib,"simBuildMatrix"));
    simGetEulerAnglesFromMatrix=(ptrSimGetEulerAnglesFromMatrix)(_getProcAddress(lib,"simGetEulerAnglesFromMatrix"));
    simInvertMatrix=(ptrSimInvertMatrix)(_getProcAddress(lib,"simInvertMatrix"));
    simMultiplyMatrices=(ptrSimMultiplyMatrices)(_getProcAddress(lib,"simMultiplyMatrices"));
    simInterpolateMatrices=(ptrSimInterpolateMatrices)(_getProcAddress(lib,"simInterpolateMatrices"));
    simTransformVector=(ptrSimTransformVector)(_getProcAddress(lib,"simTransformVector"));
    simReservedCommand=(ptrSimReservedCommand)(_getProcAddress(lib,"simReservedCommand"));
    simGetSimulationTime=(ptrSimGetSimulationTime)(_getProcAddress(lib,"simGetSimulationTime"));
    simGetSimulationState=(ptrSimGetSimulationState)(_getProcAddress(lib,"simGetSimulationState"));
    simGetSystemTime=(ptrSimGetSystemTime)(_getProcAddress(lib,"simGetSystemTime"));
    simGetSystemTimeInMilliseconds=(ptrSimGetSystemTimeInMilliseconds)(_getProcAddress(lib,"simGetSystemTimeInMilliseconds"));
    simGetSystemTimeInMs=(ptrSimGetSystemTimeInMs)(_getProcAddress(lib,"simGetSystemTimeInMs"));
    simLoadScene=(ptrSimLoadScene)(_getProcAddress(lib,"simLoadScene"));
    simCloseScene=(ptrSimCloseScene)(_getProcAddress(lib,"simCloseScene"));
    simSaveScene=(ptrSimSaveScene)(_getProcAddress(lib,"simSaveScene"));
    simLoadModel=(ptrSimLoadModel)(_getProcAddress(lib,"simLoadModel"));
    simSaveModel=(ptrSimSaveModel)(_getProcAddress(lib,"simSaveModel"));
    simAddStatusbarMessage=(ptrSimAddStatusbarMessage)(_getProcAddress(lib,"simAddStatusbarMessage"));
    simAddModuleMenuEntry=(ptrSimAddModuleMenuEntry)(_getProcAddress(lib,"simAddModuleMenuEntry"));
    simSetModuleMenuItemState=(ptrSimSetModuleMenuItemState)(_getProcAddress(lib,"simSetModuleMenuItemState"));
    simDoesFileExist=(ptrSimDoesFileExist)(_getProcAddress(lib,"simDoesFileExist"));
    simIsObjectInSelection=(ptrSimIsObjectInSelection)(_getProcAddress(lib,"simIsObjectInSelection"));
    simAddObjectToSelection=(ptrSimAddObjectToSelection)(_getProcAddress(lib,"simAddObjectToSelection"));
    simRemoveObjectFromSelection=(ptrSimRemoveObjectFromSelection)(_getProcAddress(lib,"simRemoveObjectFromSelection"));
    simGetObjectSelectionSize=(ptrSimGetObjectSelectionSize)(_getProcAddress(lib,"simGetObjectSelectionSize"));
    simGetObjectLastSelection=(ptrSimGetObjectLastSelection)(_getProcAddress(lib,"simGetObjectLastSelection"));
    simGetObjectSelection=(ptrSimGetObjectSelection)(_getProcAddress(lib,"simGetObjectSelection"));
    simHandleCollision=(ptrSimHandleCollision)(_getProcAddress(lib,"simHandleCollision"));
    simReadCollision=(ptrSimReadCollision)(_getProcAddress(lib,"simReadCollision"));
    simHandleDistance=(ptrSimHandleDistance)(_getProcAddress(lib,"simHandleDistance"));
    simReadDistance=(ptrSimReadDistance)(_getProcAddress(lib,"simReadDistance"));
    simHandleProximitySensor=(ptrSimHandleProximitySensor)(_getProcAddress(lib,"simHandleProximitySensor"));
    simReadProximitySensor=(ptrSimReadProximitySensor)(_getProcAddress(lib,"simReadProximitySensor"));
    simHandleMill=(ptrSimHandleMill)(_getProcAddress(lib,"simHandleMill"));
    simHandleIkGroup=(ptrSimHandleIkGroup)(_getProcAddress(lib,"simHandleIkGroup"));
    simCheckIkGroup=(ptrSimCheckIkGroup)(_getProcAddress(lib,"simCheckIkGroup"));
    simHandleDynamics=(ptrSimHandleDynamics)(_getProcAddress(lib,"simHandleDynamics"));
    simGetScriptHandle=(ptrSimGetScriptHandle)(_getProcAddress(lib,"simGetScriptHandle"));
    simSetScriptText=(ptrSimSetScriptText)(_getProcAddress(lib,"simSetScriptText"));
    simGetScriptText=(ptrSimGetScriptText)(_getProcAddress(lib,"simGetScriptText"));
    simGetScriptProperty=(ptrSimGetScriptProperty)(_getProcAddress(lib,"simGetScriptProperty"));
    simAssociateScriptWithObject=(ptrSimAssociateScriptWithObject)(_getProcAddress(lib,"simAssociateScriptWithObject"));
    simGetScript=(ptrSimGetScript)(_getProcAddress(lib,"simGetScript"));
    simGetScriptAssociatedWithObject=(ptrSimGetScriptAssociatedWithObject)(_getProcAddress(lib,"simGetScriptAssociatedWithObject"));
    simGetCustomizationScriptAssociatedWithObject=(ptrSimGetCustomizationScriptAssociatedWithObject)(_getProcAddress(lib,"simGetCustomizationScriptAssociatedWithObject"));
    simGetObjectAssociatedWithScript=(ptrSimGetObjectAssociatedWithScript)(_getProcAddress(lib,"simGetObjectAssociatedWithScript"));
    simGetScriptName=(ptrSimGetScriptName)(_getProcAddress(lib,"simGetScriptName"));
    simHandleMainScript=(ptrSimHandleMainScript)(_getProcAddress(lib,"simHandleMainScript"));
    simResetScript=(ptrSimResetScript)(_getProcAddress(lib,"simResetScript"));
    simAddScript=(ptrSimAddScript)(_getProcAddress(lib,"simAddScript"));
    simRemoveScript=(ptrSimRemoveScript)(_getProcAddress(lib,"simRemoveScript"));
    simRefreshDialogs=(ptrSimRefreshDialogs)(_getProcAddress(lib,"simRefreshDialogs"));
    simGetCollisionHandle=(ptrSimGetCollisionHandle)(_getProcAddress(lib,"simGetCollisionHandle"));
    simGetDistanceHandle=(ptrSimGetDistanceHandle)(_getProcAddress(lib,"simGetDistanceHandle"));
    simGetIkGroupHandle=(ptrSimGetIkGroupHandle)(_getProcAddress(lib,"simGetIkGroupHandle"));
    simResetCollision=(ptrSimResetCollision)(_getProcAddress(lib,"simResetCollision"));
    simResetDistance=(ptrSimResetDistance)(_getProcAddress(lib,"simResetDistance"));
    simResetProximitySensor=(ptrSimResetProximitySensor)(_getProcAddress(lib,"simResetProximitySensor"));
    simResetMill=(ptrSimResetMill)(_getProcAddress(lib,"simResetMill"));
    simCheckProximitySensor=(ptrSimCheckProximitySensor)(_getProcAddress(lib,"simCheckProximitySensor"));
    simCheckProximitySensorEx=(ptrSimCheckProximitySensorEx)(_getProcAddress(lib,"simCheckProximitySensorEx"));
    simCheckProximitySensorEx2=(ptrSimCheckProximitySensorEx2)(_getProcAddress(lib,"simCheckProximitySensorEx2"));
    simCreateBuffer=(ptrSimCreateBuffer)(_getProcAddress(lib,"simCreateBuffer"));
    simReleaseBuffer=(ptrSimReleaseBuffer)(_getProcAddress(lib,"simReleaseBuffer"));
    simCheckCollision=(ptrSimCheckCollision)(_getProcAddress(lib,"simCheckCollision"));
    simCheckCollisionEx=(ptrSimCheckCollisionEx)(_getProcAddress(lib,"simCheckCollisionEx"));
    simCheckDistance=(ptrSimCheckDistance)(_getProcAddress(lib,"simCheckDistance"));
    simGetObjectConfiguration=(ptrSimGetObjectConfiguration)(_getProcAddress(lib,"simGetObjectConfiguration"));
    simSetObjectConfiguration=(ptrSimSetObjectConfiguration)(_getProcAddress(lib,"simSetObjectConfiguration"));
    simGetConfigurationTree=(ptrSimGetConfigurationTree)(_getProcAddress(lib,"simGetConfigurationTree"));
    simSetConfigurationTree=(ptrSimSetConfigurationTree)(_getProcAddress(lib,"simSetConfigurationTree"));
    simSetSimulationTimeStep=(ptrSimSetSimulationTimeStep)(_getProcAddress(lib,"simSetSimulationTimeStep"));
    simGetSimulationTimeStep=(ptrSimGetSimulationTimeStep)(_getProcAddress(lib,"simGetSimulationTimeStep"));
    simGetRealTimeSimulation=(ptrSimGetRealTimeSimulation)(_getProcAddress(lib,"simGetRealTimeSimulation"));
    simIsRealTimeSimulationStepNeeded=(ptrSimIsRealTimeSimulationStepNeeded)(_getProcAddress(lib,"simIsRealTimeSimulationStepNeeded"));
    simAdjustRealTimeTimer=(ptrSimAdjustRealTimeTimer)(_getProcAddress(lib,"simAdjustRealTimeTimer"));
    simGetSimulationPassesPerRenderingPass=(ptrSimGetSimulationPassesPerRenderingPass)(_getProcAddress(lib,"simGetSimulationPassesPerRenderingPass"));
    simAdvanceSimulationByOneStep=(ptrSimAdvanceSimulationByOneStep)(_getProcAddress(lib,"simAdvanceSimulationByOneStep"));
    simStartSimulation=(ptrSimStartSimulation)(_getProcAddress(lib,"simStartSimulation"));
    simStopSimulation=(ptrSimStopSimulation)(_getProcAddress(lib,"simStopSimulation"));
    simPauseSimulation=(ptrSimPauseSimulation)(_getProcAddress(lib,"simPauseSimulation"));
    simBroadcastMessage=(ptrSimBroadcastMessage)(_getProcAddress(lib,"simBroadcastMessage"));
    simGetModuleName=(ptrSimGetModuleName)(_getProcAddress(lib,"simGetModuleName"));
    simFloatingViewAdd=(ptrSimFloatingViewAdd)(_getProcAddress(lib,"simFloatingViewAdd"));
    simFloatingViewRemove=(ptrSimFloatingViewRemove)(_getProcAddress(lib,"simFloatingViewRemove"));
    simAdjustView=(ptrSimAdjustView)(_getProcAddress(lib,"simAdjustView"));
    simSetLastError=(ptrSimSetLastError)(_getProcAddress(lib,"simSetLastError"));
    simHandleGraph=(ptrSimHandleGraph)(_getProcAddress(lib,"simHandleGraph"));
    simResetGraph=(ptrSimResetGraph)(_getProcAddress(lib,"simResetGraph"));
    simSetNavigationMode=(ptrSimSetNavigationMode)(_getProcAddress(lib,"simSetNavigationMode"));
    simGetNavigationMode=(ptrSimGetNavigationMode)(_getProcAddress(lib,"simGetNavigationMode"));
    simSetPage=(ptrSimSetPage)(_getProcAddress(lib,"simSetPage"));
    simGetPage=(ptrSimGetPage)(_getProcAddress(lib,"simGetPage"));
    simDisplayDialog=(ptrSimDisplayDialog)(_getProcAddress(lib,"simDisplayDialog"));
    simGetDialogResult=(ptrSimGetDialogResult)(_getProcAddress(lib,"simGetDialogResult"));
    simGetDialogInput=(ptrSimGetDialogInput)(_getProcAddress(lib,"simGetDialogInput"));
    simEndDialog=(ptrSimEndDialog)(_getProcAddress(lib,"simEndDialog"));
    simRegisterScriptCallbackFunction=(ptrSimRegisterScriptCallbackFunction)(_getProcAddress(lib,"simRegisterScriptCallbackFunction"));
    simRegisterScriptVariable=(ptrSimRegisterScriptVariable)(_getProcAddress(lib,"simRegisterScriptVariable"));
    simSetJointTargetVelocity=(ptrSimSetJointTargetVelocity)(_getProcAddress(lib,"simSetJointTargetVelocity"));
    simGetJointTargetVelocity=(ptrSimGetJointTargetVelocity)(_getProcAddress(lib,"simGetJointTargetVelocity"));
    simSetPathTargetNominalVelocity=(ptrSimSetPathTargetNominalVelocity)(_getProcAddress(lib,"simSetPathTargetNominalVelocity"));
    simGetScriptRawBuffer=(ptrSimGetScriptRawBuffer)(_getProcAddress(lib,"simGetScriptRawBuffer"));
    simSetScriptRawBuffer=(ptrSimSetScriptRawBuffer)(_getProcAddress(lib,"simSetScriptRawBuffer"));
    simReleaseScriptRawBuffer=(ptrSimReleaseScriptRawBuffer)(_getProcAddress(lib,"simReleaseScriptRawBuffer"));
    simCopyPasteObjects=(ptrSimCopyPasteObjects)(_getProcAddress(lib,"simCopyPasteObjects"));
    simScaleSelectedObjects=(ptrSimScaleSelectedObjects)(_getProcAddress(lib,"simScaleSelectedObjects"));
    simScaleObjects=(ptrSimScaleObjects)(_getProcAddress(lib,"simScaleObjects"));
    simDeleteSelectedObjects=(ptrSimDeleteSelectedObjects)(_getProcAddress(lib,"simDeleteSelectedObjects"));
    simGetObjectUniqueIdentifier=(ptrSimGetObjectUniqueIdentifier)(_getProcAddress(lib,"simGetObjectUniqueIdentifier"));
    simGetNameSuffix=(ptrSimGetNameSuffix)(_getProcAddress(lib,"simGetNameSuffix"));
    simSendData=(ptrSimSendData)(_getProcAddress(lib,"simSendData"));
    simReceiveData=(ptrSimReceiveData)(_getProcAddress(lib,"simReceiveData"));
    simSetGraphUserData=(ptrSimSetGraphUserData)(_getProcAddress(lib,"simSetGraphUserData"));
    simSetNameSuffix=(ptrSimSetNameSuffix)(_getProcAddress(lib,"simSetNameSuffix"));
    simAddDrawingObject=(ptrSimAddDrawingObject)(_getProcAddress(lib,"simAddDrawingObject"));
    simRemoveDrawingObject=(ptrSimRemoveDrawingObject)(_getProcAddress(lib,"simRemoveDrawingObject"));
    simAddDrawingObjectItem=(ptrSimAddDrawingObjectItem)(_getProcAddress(lib,"simAddDrawingObjectItem"));
    simAddParticleObject=(ptrSimAddParticleObject)(_getProcAddress(lib,"simAddParticleObject"));
    simRemoveParticleObject=(ptrSimRemoveParticleObject)(_getProcAddress(lib,"simRemoveParticleObject"));
    simAddParticleObjectItem=(ptrSimAddParticleObjectItem)(_getProcAddress(lib,"simAddParticleObjectItem"));
    simGetObjectSizeFactor=(ptrSimGetObjectSizeFactor)(_getProcAddress(lib,"simGetObjectSizeFactor"));
    simAnnounceSceneContentChange=(ptrSimAnnounceSceneContentChange)(_getProcAddress(lib,"simAnnounceSceneContentChange"));
    simResetMilling=(ptrSimResetMilling)(_getProcAddress(lib,"simResetMilling"));
    simApplyMilling=(ptrSimApplyMilling)(_getProcAddress(lib,"simApplyMilling"));
    simSetIntegerSignal=(ptrSimSetIntegerSignal)(_getProcAddress(lib,"simSetIntegerSignal"));
    simGetIntegerSignal=(ptrSimGetIntegerSignal)(_getProcAddress(lib,"simGetIntegerSignal"));
    simClearIntegerSignal=(ptrSimClearIntegerSignal)(_getProcAddress(lib,"simClearIntegerSignal"));
    simSetFloatSignal=(ptrSimSetFloatSignal)(_getProcAddress(lib,"simSetFloatSignal"));
    simGetFloatSignal=(ptrSimGetFloatSignal)(_getProcAddress(lib,"simGetFloatSignal"));
    simClearFloatSignal=(ptrSimClearFloatSignal)(_getProcAddress(lib,"simClearFloatSignal"));
    simSetDoubleSignal=(ptrSimSetDoubleSignal)(_getProcAddress(lib,"simSetDoubleSignal"));
    simGetDoubleSignal=(ptrSimGetDoubleSignal)(_getProcAddress(lib,"simGetDoubleSignal"));
    simClearDoubleSignal=(ptrSimClearDoubleSignal)(_getProcAddress(lib,"simClearDoubleSignal"));
    simSetStringSignal=(ptrSimSetStringSignal)(_getProcAddress(lib,"simSetStringSignal"));
    simGetStringSignal=(ptrSimGetStringSignal)(_getProcAddress(lib,"simGetStringSignal"));
    simClearStringSignal=(ptrSimClearStringSignal)(_getProcAddress(lib,"simClearStringSignal"));
    simGetSignalName=(ptrSimGetSignalName)(_getProcAddress(lib,"simGetSignalName"));
    simSetObjectProperty=(ptrSimSetObjectProperty)(_getProcAddress(lib,"simSetObjectProperty"));
    simGetObjectProperty=(ptrSimGetObjectProperty)(_getProcAddress(lib,"simGetObjectProperty"));
    simSetObjectSpecialProperty=(ptrSimSetObjectSpecialProperty)(_getProcAddress(lib,"simSetObjectSpecialProperty"));
    simGetObjectSpecialProperty=(ptrSimGetObjectSpecialProperty)(_getProcAddress(lib,"simGetObjectSpecialProperty"));
    simGetPositionOnPath=(ptrSimGetPositionOnPath)(_getProcAddress(lib,"simGetPositionOnPath"));
    simGetDataOnPath=(ptrSimGetDataOnPath)(_getProcAddress(lib,"simGetDataOnPath"));
    simGetOrientationOnPath=(ptrSimGetOrientationOnPath)(_getProcAddress(lib,"simGetOrientationOnPath"));
    simGetClosestPositionOnPath=(ptrSimGetClosestPositionOnPath)(_getProcAddress(lib,"simGetClosestPositionOnPath"));
    simReadForceSensor=(ptrSimReadForceSensor)(_getProcAddress(lib,"simReadForceSensor"));
    simBreakForceSensor=(ptrSimBreakForceSensor)(_getProcAddress(lib,"simBreakForceSensor"));
    simGetShapeVertex=(ptrSimGetShapeVertex)(_getProcAddress(lib,"simGetShapeVertex"));
    simGetShapeTriangle=(ptrSimGetShapeTriangle)(_getProcAddress(lib,"simGetShapeTriangle"));
    simSetLightParameters=(ptrSimSetLightParameters)(_getProcAddress(lib,"simSetLightParameters"));
    simGetLightParameters=(ptrSimGetLightParameters)(_getProcAddress(lib,"simGetLightParameters"));
    simGetVelocity=(ptrSimGetVelocity)(_getProcAddress(lib,"simGetVelocity"));
    simGetObjectVelocity=(ptrSimGetObjectVelocity)(_getProcAddress(lib,"simGetObjectVelocity"));
    simAddForceAndTorque=(ptrSimAddForceAndTorque)(_getProcAddress(lib,"simAddForceAndTorque"));
    simAddForce=(ptrSimAddForce)(_getProcAddress(lib,"simAddForce"));
    simSetExplicitHandling=(ptrSimSetExplicitHandling)(_getProcAddress(lib,"simSetExplicitHandling"));
    simGetExplicitHandling=(ptrSimGetExplicitHandling)(_getProcAddress(lib,"simGetExplicitHandling"));
    simGetLinkDummy=(ptrSimGetLinkDummy)(_getProcAddress(lib,"simGetLinkDummy"));
    simSetLinkDummy=(ptrSimSetLinkDummy)(_getProcAddress(lib,"simSetLinkDummy"));
    simSetModelProperty=(ptrSimSetModelProperty)(_getProcAddress(lib,"simSetModelProperty"));
    simGetModelProperty=(ptrSimGetModelProperty)(_getProcAddress(lib,"simGetModelProperty"));
    simSetShapeColor=(ptrSimSetShapeColor)(_getProcAddress(lib,"simSetShapeColor"));
    simGetShapeColor=(ptrSimGetShapeColor)(_getProcAddress(lib,"simGetShapeColor"));
    simResetDynamicObject=(ptrSimResetDynamicObject)(_getProcAddress(lib,"simResetDynamicObject"));
    simSetJointMode=(ptrSimSetJointMode)(_getProcAddress(lib,"simSetJointMode"));
    simGetJointMode=(ptrSimGetJointMode)(_getProcAddress(lib,"simGetJointMode"));
    simSerialOpen=(ptrSimSerialOpen)(_getProcAddress(lib,"simSerialOpen"));
    simSerialClose=(ptrSimSerialClose)(_getProcAddress(lib,"simSerialClose"));
    simSerialSend=(ptrSimSerialSend)(_getProcAddress(lib,"simSerialSend"));
    simSerialRead=(ptrSimSerialRead)(_getProcAddress(lib,"simSerialRead"));
    simSerialCheck=(ptrSimSerialCheck)(_getProcAddress(lib,"simSerialCheck"));
    simGetContactInfo=(ptrSimGetContactInfo)(_getProcAddress(lib,"simGetContactInfo"));
    simSetThreadIsFree=(ptrSimSetThreadIsFree)(_getProcAddress(lib,"simSetThreadIsFree"));
    simTubeOpen=(ptrSimTubeOpen)(_getProcAddress(lib,"simTubeOpen"));
    simTubeClose=(ptrSimTubeClose)(_getProcAddress(lib,"simTubeClose"));
    simTubeWrite=(ptrSimTubeWrite)(_getProcAddress(lib,"simTubeWrite"));
    simTubeRead=(ptrSimTubeRead)(_getProcAddress(lib,"simTubeRead"));
    simTubeStatus=(ptrSimTubeStatus)(_getProcAddress(lib,"simTubeStatus"));
    simAuxiliaryConsoleOpen=(ptrSimAuxiliaryConsoleOpen)(_getProcAddress(lib,"simAuxiliaryConsoleOpen"));
    simAuxiliaryConsoleClose=(ptrSimAuxiliaryConsoleClose)(_getProcAddress(lib,"simAuxiliaryConsoleClose"));
    simAuxiliaryConsoleShow=(ptrSimAuxiliaryConsoleShow)(_getProcAddress(lib,"simAuxiliaryConsoleShow"));
    simAuxiliaryConsolePrint=(ptrSimAuxiliaryConsolePrint)(_getProcAddress(lib,"simAuxiliaryConsolePrint"));
    simImportShape=(ptrSimImportShape)(_getProcAddress(lib,"simImportShape"));
    simImportMesh=(ptrSimImportMesh)(_getProcAddress(lib,"simImportMesh"));
    simExportMesh=(ptrSimExportMesh)(_getProcAddress(lib,"simExportMesh"));
    simCreateMeshShape=(ptrSimCreateMeshShape)(_getProcAddress(lib,"simCreateMeshShape"));
    simCreatePureShape=(ptrSimCreatePureShape)(_getProcAddress(lib,"simCreatePureShape"));
    simCreateHeightfieldShape=(ptrSimCreateHeightfieldShape)(_getProcAddress(lib,"simCreateHeightfieldShape"));
    simGetShapeMesh=(ptrSimGetShapeMesh)(_getProcAddress(lib,"simGetShapeMesh"));
    simAddBanner=(ptrSimAddBanner)(_getProcAddress(lib,"simAddBanner"));
    simRemoveBanner=(ptrSimRemoveBanner)(_getProcAddress(lib,"simRemoveBanner"));
    simCreateJoint=(ptrSimCreateJoint)(_getProcAddress(lib,"simCreateJoint"));
    simCreateDummy=(ptrSimCreateDummy)(_getProcAddress(lib,"simCreateDummy"));
    simCreateProximitySensor=(ptrSimCreateProximitySensor)(_getProcAddress(lib,"simCreateProximitySensor"));
    simCreatePath=(ptrSimCreatePath)(_getProcAddress(lib,"simCreatePath"));
    simInsertPathCtrlPoints=(ptrSimInsertPathCtrlPoints)(_getProcAddress(lib,"simInsertPathCtrlPoints"));
    simCutPathCtrlPoints=(ptrSimCutPathCtrlPoints)(_getProcAddress(lib,"simCutPathCtrlPoints"));
    simCreateForceSensor=(ptrSimCreateForceSensor)(_getProcAddress(lib,"simCreateForceSensor"));
    simCreateVisionSensor=(ptrSimCreateVisionSensor)(_getProcAddress(lib,"simCreateVisionSensor"));
    simGetObjectIntParameter=(ptrSimGetObjectIntParameter)(_getProcAddress(lib,"simGetObjectIntParameter"));
    simSetObjectIntParameter=(ptrSimSetObjectIntParameter)(_getProcAddress(lib,"simSetObjectIntParameter"));
    simGetObjectInt32Parameter=(ptrSimGetObjectInt32Parameter)(_getProcAddress(lib,"simGetObjectInt32Parameter"));
    simSetObjectInt32Parameter=(ptrSimSetObjectInt32Parameter)(_getProcAddress(lib,"simSetObjectInt32Parameter"));
    simGetObjectFloatParameter=(ptrSimGetObjectFloatParameter)(_getProcAddress(lib,"simGetObjectFloatParameter"));
    simSetObjectFloatParameter=(ptrSimSetObjectFloatParameter)(_getProcAddress(lib,"simSetObjectFloatParameter"));
    simGetObjectStringParameter=(ptrSimGetObjectStringParameter)(_getProcAddress(lib,"simGetObjectStringParameter"));
    simSetObjectStringParameter=(ptrSimSetObjectStringParameter)(_getProcAddress(lib,"simSetObjectStringParameter"));
    simSetSimulationPassesPerRenderingPass=(ptrSimSetSimulationPassesPerRenderingPass)(_getProcAddress(lib,"simSetSimulationPassesPerRenderingPass"));
    simGetRotationAxis=(ptrSimGetRotationAxis)(_getProcAddress(lib,"simGetRotationAxis"));
    simRotateAroundAxis=(ptrSimRotateAroundAxis)(_getProcAddress(lib,"simRotateAroundAxis"));
    simGetJointForce=(ptrSimGetJointForce)(_getProcAddress(lib,"simGetJointForce"));
    simGetJointMaxForce=(ptrSimGetJointMaxForce)(_getProcAddress(lib,"simGetJointMaxForce"));
    simSetArrayParameter=(ptrSimSetArrayParameter)(_getProcAddress(lib,"simSetArrayParameter"));
    simGetArrayParameter=(ptrSimGetArrayParameter)(_getProcAddress(lib,"simGetArrayParameter"));
    simSetIkGroupProperties=(ptrSimSetIkGroupProperties)(_getProcAddress(lib,"simSetIkGroupProperties"));
    simSetIkElementProperties=(ptrSimSetIkElementProperties)(_getProcAddress(lib,"simSetIkElementProperties"));
    simCameraFitToView=(ptrSimCameraFitToView)(_getProcAddress(lib,"simCameraFitToView"));
    simPersistentDataWrite=(ptrSimPersistentDataWrite)(_getProcAddress(lib,"simPersistentDataWrite"));
    simPersistentDataRead=(ptrSimPersistentDataRead)(_getProcAddress(lib,"simPersistentDataRead"));
    simIsHandleValid=(ptrSimIsHandleValid)(_getProcAddress(lib,"simIsHandleValid"));
    simHandleVisionSensor=(ptrSimHandleVisionSensor)(_getProcAddress(lib,"simHandleVisionSensor"));
    simReadVisionSensor=(ptrSimReadVisionSensor)(_getProcAddress(lib,"simReadVisionSensor"));
    simResetVisionSensor=(ptrSimResetVisionSensor)(_getProcAddress(lib,"simResetVisionSensor"));
    simCheckVisionSensor=(ptrSimCheckVisionSensor)(_getProcAddress(lib,"simCheckVisionSensor"));
    simCheckVisionSensorEx=(ptrSimCheckVisionSensorEx)(_getProcAddress(lib,"simCheckVisionSensorEx"));
    simGetVisionSensorResolution=(ptrSimGetVisionSensorResolution)(_getProcAddress(lib,"simGetVisionSensorResolution"));
    simGetVisionSensorImage=(ptrSimGetVisionSensorImage)(_getProcAddress(lib,"simGetVisionSensorImage"));
    simGetVisionSensorCharImage=(ptrSimGetVisionSensorCharImage)(_getProcAddress(lib,"simGetVisionSensorCharImage"));
    simSetVisionSensorImage=(ptrSimSetVisionSensorImage)(_getProcAddress(lib,"simSetVisionSensorImage"));
    simSetVisionSensorCharImage=(ptrSimSetVisionSensorCharImage)(_getProcAddress(lib,"simSetVisionSensorCharImage"));
    simGetVisionSensorDepthBuffer=(ptrSimGetVisionSensorDepthBuffer)(_getProcAddress(lib,"simGetVisionSensorDepthBuffer"));
    simGetObjectQuaternion=(ptrSimGetObjectQuaternion)(_getProcAddress(lib,"simGetObjectQuaternion"));
    simSetObjectQuaternion=(ptrSimSetObjectQuaternion)(_getProcAddress(lib,"simSetObjectQuaternion"));
    simRMLPosition=(ptrSimRMLPosition)(_getProcAddress(lib,"simRMLPosition"));
    simRMLVelocity=(ptrSimRMLVelocity)(_getProcAddress(lib,"simRMLVelocity"));
    simRMLPos=(ptrSimRMLPos)(_getProcAddress(lib,"simRMLPos"));
    simRMLVel=(ptrSimRMLVel)(_getProcAddress(lib,"simRMLVel"));
    simRMLStep=(ptrSimRMLStep)(_getProcAddress(lib,"simRMLStep"));
    simRMLRemove=(ptrSimRMLRemove)(_getProcAddress(lib,"simRMLRemove"));
    simBuildMatrixQ=(ptrSimBuildMatrixQ)(_getProcAddress(lib,"simBuildMatrixQ"));
    simGetQuaternionFromMatrix=(ptrSimGetQuaternionFromMatrix)(_getProcAddress(lib,"simGetQuaternionFromMatrix"));
    simFileDialog=(ptrSimFileDialog)(_getProcAddress(lib,"simFileDialog"));
    simMsgBox=(ptrSimMsgBox)(_getProcAddress(lib,"simMsgBox"));
    simSetShapeMassAndInertia=(ptrSimSetShapeMassAndInertia)(_getProcAddress(lib,"simSetShapeMassAndInertia"));
    simGetShapeMassAndInertia=(ptrSimGetShapeMassAndInertia)(_getProcAddress(lib,"simGetShapeMassAndInertia"));
    simGroupShapes=(ptrSimGroupShapes)(_getProcAddress(lib,"simGroupShapes"));
    simUngroupShape=(ptrSimUngroupShape)(_getProcAddress(lib,"simUngroupShape"));
    simConvexDecompose=(ptrSimConvexDecompose)(_getProcAddress(lib,"simConvexDecompose"));
    simGetIkGroupMatrix=(ptrSimGetIkGroupMatrix)(_getProcAddress(lib,"simGetIkGroupMatrix"));
    simAddGhost=(ptrSimAddGhost)(_getProcAddress(lib,"simAddGhost"));
    simModifyGhost=(ptrSimModifyGhost)(_getProcAddress(lib,"simModifyGhost"));
    simQuitSimulator=(ptrSimQuitSimulator)(_getProcAddress(lib,"simQuitSimulator"));
    simGetThreadId=(ptrSimGetThreadId)(_getProcAddress(lib,"simGetThreadId"));
    simLockResources=(ptrSimLockResources)(_getProcAddress(lib,"simLockResources"));
    simUnlockResources=(ptrSimUnlockResources)(_getProcAddress(lib,"simUnlockResources"));
    simEnableEventCallback=(ptrSimEnableEventCallback)(_getProcAddress(lib,"simEnableEventCallback"));
    simSetShapeMaterial=(ptrSimSetShapeMaterial)(_getProcAddress(lib,"simSetShapeMaterial"));
    simGetTextureId=(ptrSimGetTextureId)(_getProcAddress(lib,"simGetTextureId"));
    simReadTexture=(ptrSimReadTexture)(_getProcAddress(lib,"simReadTexture"));
    simWriteTexture=(ptrSimWriteTexture)(_getProcAddress(lib,"simWriteTexture"));
    simCreateTexture=(ptrSimCreateTexture)(_getProcAddress(lib,"simCreateTexture"));
    simWriteCustomDataBlock=(ptrSimWriteCustomDataBlock)(_getProcAddress(lib,"simWriteCustomDataBlock"));
    simReadCustomDataBlock=(ptrSimReadCustomDataBlock)(_getProcAddress(lib,"simReadCustomDataBlock"));
    simReadCustomDataBlockTags=(ptrSimReadCustomDataBlockTags)(_getProcAddress(lib,"simReadCustomDataBlockTags"));
    simAddPointCloud=(ptrSimAddPointCloud)(_getProcAddress(lib,"simAddPointCloud"));
    simModifyPointCloud=(ptrSimModifyPointCloud)(_getProcAddress(lib,"simModifyPointCloud"));
    simGetShapeGeomInfo=(ptrSimGetShapeGeomInfo)(_getProcAddress(lib,"simGetShapeGeomInfo"));
    simGetObjectsInTree=(ptrSimGetObjectsInTree)(_getProcAddress(lib,"simGetObjectsInTree"));
    simSetObjectSizeValues=(ptrSimSetObjectSizeValues)(_getProcAddress(lib,"simSetObjectSizeValues"));
    simGetObjectSizeValues=(ptrSimGetObjectSizeValues)(_getProcAddress(lib,"simGetObjectSizeValues"));
    simScaleObject=(ptrSimScaleObject)(_getProcAddress(lib,"simScaleObject"));
    simSetShapeTexture=(ptrSimSetShapeTexture)(_getProcAddress(lib,"simSetShapeTexture"));
    simGetShapeTextureId=(ptrSimGetShapeTextureId)(_getProcAddress(lib,"simGetShapeTextureId"));
    simGetCollectionObjects=(ptrSimGetCollectionObjects)(_getProcAddress(lib,"simGetCollectionObjects"));
    simSetScriptAttribute=(ptrSimSetScriptAttribute)(_getProcAddress(lib,"simSetScriptAttribute"));
    simGetScriptAttribute=(ptrSimGetScriptAttribute)(_getProcAddress(lib,"simGetScriptAttribute"));
    simReorientShapeBoundingBox=(ptrSimReorientShapeBoundingBox)(_getProcAddress(lib,"simReorientShapeBoundingBox"));
    simSwitchThread=(ptrSimSwitchThread)(_getProcAddress(lib,"simSwitchThread"));
    simCreateIkGroup=(ptrSimCreateIkGroup)(_getProcAddress(lib,"simCreateIkGroup"));
    simRemoveIkGroup=(ptrSimRemoveIkGroup)(_getProcAddress(lib,"simRemoveIkGroup"));
    simCreateIkElement=(ptrSimCreateIkElement)(_getProcAddress(lib,"simCreateIkElement"));
    simCreateCollection=(ptrSimCreateCollection)(_getProcAddress(lib,"simCreateCollection"));
    simAddObjectToCollection=(ptrSimAddObjectToCollection)(_getProcAddress(lib,"simAddObjectToCollection"));
    simSaveImage=(ptrSimSaveImage)(_getProcAddress(lib,"simSaveImage"));
    simLoadImage=(ptrSimLoadImage)(_getProcAddress(lib,"simLoadImage"));
    simGetScaledImage=(ptrSimGetScaledImage)(_getProcAddress(lib,"simGetScaledImage"));
    simTransformImage=(ptrSimTransformImage)(_getProcAddress(lib,"simTransformImage"));
    simGetQHull=(ptrSimGetQHull)(_getProcAddress(lib,"simGetQHull"));
    simGetDecimatedMesh=(ptrSimGetDecimatedMesh)(_getProcAddress(lib,"simGetDecimatedMesh"));
    simExportIk=(ptrSimExportIk)(_getProcAddress(lib,"simExportIk"));
    simCallScriptFunctionEx=(ptrSimCallScriptFunctionEx)(_getProcAddress(lib,"simCallScriptFunctionEx"));
    simComputeJacobian=(ptrSimComputeJacobian)(_getProcAddress(lib,"simComputeJacobian"));
    simGetConfigForTipPose=(ptrSimGetConfigForTipPose)(_getProcAddress(lib,"simGetConfigForTipPose"));
    simGenerateIkPath=(ptrSimGenerateIkPath)(_getProcAddress(lib,"simGenerateIkPath"));
    simGetExtensionString=(ptrSimGetExtensionString)(_getProcAddress(lib,"simGetExtensionString"));
    simComputeMassAndInertia=(ptrSimComputeMassAndInertia)(_getProcAddress(lib,"simComputeMassAndInertia"));
    simCreateStack=(ptrSimCreateStack)(_getProcAddress(lib,"simCreateStack"));
    simReleaseStack=(ptrSimReleaseStack)(_getProcAddress(lib,"simReleaseStack"));
    simCopyStack=(ptrSimCopyStack)(_getProcAddress(lib,"simCopyStack"));
    simPushNullOntoStack=(ptrSimPushNullOntoStack)(_getProcAddress(lib,"simPushNullOntoStack"));
    simPushBoolOntoStack=(ptrSimPushBoolOntoStack)(_getProcAddress(lib,"simPushBoolOntoStack"));
    simPushInt32OntoStack=(ptrSimPushInt32OntoStack)(_getProcAddress(lib,"simPushInt32OntoStack"));
    simPushFloatOntoStack=(ptrSimPushFloatOntoStack)(_getProcAddress(lib,"simPushFloatOntoStack"));
    simPushDoubleOntoStack=(ptrSimPushDoubleOntoStack)(_getProcAddress(lib,"simPushDoubleOntoStack"));
    simPushStringOntoStack=(ptrSimPushStringOntoStack)(_getProcAddress(lib,"simPushStringOntoStack"));
    simPushUInt8TableOntoStack=(ptrSimPushUInt8TableOntoStack)(_getProcAddress(lib,"simPushUInt8TableOntoStack"));
    simPushInt32TableOntoStack=(ptrSimPushInt32TableOntoStack)(_getProcAddress(lib,"simPushInt32TableOntoStack"));
    simPushFloatTableOntoStack=(ptrSimPushFloatTableOntoStack)(_getProcAddress(lib,"simPushFloatTableOntoStack"));
    simPushDoubleTableOntoStack=(ptrSimPushDoubleTableOntoStack)(_getProcAddress(lib,"simPushDoubleTableOntoStack"));
    simPushTableOntoStack=(ptrSimPushTableOntoStack)(_getProcAddress(lib,"simPushTableOntoStack"));
    simInsertDataIntoStackTable=(ptrSimInsertDataIntoStackTable)(_getProcAddress(lib,"simInsertDataIntoStackTable"));
    simGetStackSize=(ptrSimGetStackSize)(_getProcAddress(lib,"simGetStackSize"));
    simPopStackItem=(ptrSimPopStackItem)(_getProcAddress(lib,"simPopStackItem"));
    simMoveStackItemToTop=(ptrSimMoveStackItemToTop)(_getProcAddress(lib,"simMoveStackItemToTop"));
    simIsStackValueNull=(ptrSimIsStackValueNull)(_getProcAddress(lib,"simIsStackValueNull"));
    simGetStackBoolValue=(ptrSimGetStackBoolValue)(_getProcAddress(lib,"simGetStackBoolValue"));
    simGetStackInt32Value=(ptrSimGetStackInt32Value)(_getProcAddress(lib,"simGetStackInt32Value"));
    simGetStackFloatValue=(ptrSimGetStackFloatValue)(_getProcAddress(lib,"simGetStackFloatValue"));
    simGetStackDoubleValue=(ptrSimGetStackDoubleValue)(_getProcAddress(lib,"simGetStackDoubleValue"));
    simGetStackStringValue=(ptrSimGetStackStringValue)(_getProcAddress(lib,"simGetStackStringValue"));
    simGetStackTableInfo=(ptrSimGetStackTableInfo)(_getProcAddress(lib,"simGetStackTableInfo"));
    simGetStackUInt8Table=(ptrSimGetStackUInt8Table)(_getProcAddress(lib,"simGetStackUInt8Table"));
    simGetStackInt32Table=(ptrSimGetStackInt32Table)(_getProcAddress(lib,"simGetStackInt32Table"));
    simGetStackFloatTable=(ptrSimGetStackFloatTable)(_getProcAddress(lib,"simGetStackFloatTable"));
    simGetStackDoubleTable=(ptrSimGetStackDoubleTable)(_getProcAddress(lib,"simGetStackDoubleTable"));
    simUnfoldStackTable=(ptrSimUnfoldStackTable)(_getProcAddress(lib,"simUnfoldStackTable"));
    simDebugStack=(ptrSimDebugStack)(_getProcAddress(lib,"simDebugStack"));
    simSetScriptVariable=(ptrSimSetScriptVariable)(_getProcAddress(lib,"simSetScriptVariable"));
    simGetEngineFloatParameter=(ptrSimGetEngineFloatParameter)(_getProcAddress(lib,"simGetEngineFloatParameter"));
    simGetEngineInt32Parameter=(ptrSimGetEngineInt32Parameter)(_getProcAddress(lib,"simGetEngineInt32Parameter"));
    simGetEngineBoolParameter=(ptrSimGetEngineBoolParameter)(_getProcAddress(lib,"simGetEngineBoolParameter"));
    simSetEngineFloatParameter=(ptrSimSetEngineFloatParameter)(_getProcAddress(lib,"simSetEngineFloatParameter"));
    simSetEngineInt32Parameter=(ptrSimSetEngineInt32Parameter)(_getProcAddress(lib,"simSetEngineInt32Parameter"));
    simSetEngineBoolParameter=(ptrSimSetEngineBoolParameter)(_getProcAddress(lib,"simSetEngineBoolParameter"));
    simCreateOctree=(ptrSimCreateOctree)(_getProcAddress(lib,"simCreateOctree"));
    simCreatePointCloud=(ptrSimCreatePointCloud)(_getProcAddress(lib,"simCreatePointCloud"));
    simSetPointCloudOptions=(ptrSimSetPointCloudOptions)(_getProcAddress(lib,"simSetPointCloudOptions"));
    simGetPointCloudOptions=(ptrSimGetPointCloudOptions)(_getProcAddress(lib,"simGetPointCloudOptions"));
    simInsertVoxelsIntoOctree=(ptrSimInsertVoxelsIntoOctree)(_getProcAddress(lib,"simInsertVoxelsIntoOctree"));
    simRemoveVoxelsFromOctree=(ptrSimRemoveVoxelsFromOctree)(_getProcAddress(lib,"simRemoveVoxelsFromOctree"));
    simInsertPointsIntoPointCloud=(ptrSimInsertPointsIntoPointCloud)(_getProcAddress(lib,"simInsertPointsIntoPointCloud"));
    simRemovePointsFromPointCloud=(ptrSimRemovePointsFromPointCloud)(_getProcAddress(lib,"simRemovePointsFromPointCloud"));
    simIntersectPointsWithPointCloud=(ptrSimIntersectPointsWithPointCloud)(_getProcAddress(lib,"simIntersectPointsWithPointCloud"));
    simGetOctreeVoxels=(ptrSimGetOctreeVoxels)(_getProcAddress(lib,"simGetOctreeVoxels"));
    simGetPointCloudPoints=(ptrSimGetPointCloudPoints)(_getProcAddress(lib,"simGetPointCloudPoints"));
    simInsertObjectIntoOctree=(ptrSimInsertObjectIntoOctree)(_getProcAddress(lib,"simInsertObjectIntoOctree"));
    simSubtractObjectFromOctree=(ptrSimSubtractObjectFromOctree)(_getProcAddress(lib,"simSubtractObjectFromOctree"));
    simInsertObjectIntoPointCloud=(ptrSimInsertObjectIntoPointCloud)(_getProcAddress(lib,"simInsertObjectIntoPointCloud"));
    simSubtractObjectFromPointCloud=(ptrSimSubtractObjectFromPointCloud)(_getProcAddress(lib,"simSubtractObjectFromPointCloud"));
    simCheckOctreePointOccupancy=(ptrSimCheckOctreePointOccupancy)(_getProcAddress(lib,"simCheckOctreePointOccupancy"));
    simOpenTextEditor=(ptrSimOpenTextEditor)(_getProcAddress(lib,"simOpenTextEditor"));
    simPackTable=(ptrSimPackTable)(_getProcAddress(lib,"simPackTable"));
    simUnpackTable=(ptrSimUnpackTable)(_getProcAddress(lib,"simUnpackTable"));
    simSetReferencedHandles=(ptrSimSetReferencedHandles)(_getProcAddress(lib,"simSetReferencedHandles"));
    simGetReferencedHandles=(ptrSimGetReferencedHandles)(_getProcAddress(lib,"simGetReferencedHandles"));
    simGetShapeViz=(ptrSimGetShapeViz)(_getProcAddress(lib,"simGetShapeViz"));
    simExecuteScriptString=(ptrSimExecuteScriptString)(_getProcAddress(lib,"simExecuteScriptString"));
    simGetApiFunc=(ptrSimGetApiFunc)(_getProcAddress(lib,"simGetApiFunc"));
    simGetApiInfo=(ptrSimGetApiInfo)(_getProcAddress(lib,"simGetApiInfo"));
    simSetModuleInfo=(ptrSimSetModuleInfo)(_getProcAddress(lib,"simSetModuleInfo"));
    simGetModuleInfo=(ptrSimGetModuleInfo)(_getProcAddress(lib,"simGetModuleInfo"));
    simIsDeprecated=(ptrSimIsDeprecated)(_getProcAddress(lib,"simIsDeprecated"));
    simGetPersistentDataTags=(ptrSimGetPersistentDataTags)(_getProcAddress(lib,"simGetPersistentDataTags"));
    simEventNotification=(ptrSimEventNotification)(_getProcAddress(lib,"simEventNotification"));
    simApplyTexture=(ptrSimApplyTexture)(_getProcAddress(lib,"simApplyTexture"));
    simSetJointDependency=(ptrSimSetJointDependency)(_getProcAddress(lib,"simSetJointDependency"));
    simSetStringNamedParam=(ptrSimSetStringNamedParam)(_getProcAddress(lib,"simSetStringNamedParam"));
    simGetStringNamedParam=(ptrSimGetStringNamedParam)(_getProcAddress(lib,"simGetStringNamedParam"));
    simGetUserParameter=(ptrSimGetUserParameter)(_getProcAddress(lib,"simGetUserParameter"));
    simSetUserParameter=(ptrSimSetUserParameter)(_getProcAddress(lib,"simSetUserParameter"));

    // Following courtesy of Stephen James:
    simExtLaunchUIThread=(ptrSimExtLaunchUIThread)(_getProcAddress(lib,"simExtLaunchUIThread"));
    simExtCanInitSimThread=(ptrSimExtCanInitSimThread)(_getProcAddress(lib,"simExtCanInitSimThread"));
    simExtSimThreadInit=(ptrSimExtSimThreadInit)(_getProcAddress(lib,"simExtSimThreadInit"));
    simExtSimThreadDestroy=(ptrSimExtSimThreadDestroy)(_getProcAddress(lib,"simExtSimThreadDestroy"));
    simExtPostExitRequest=(ptrSimExtPostExitRequest)(_getProcAddress(lib,"simExtPostExitRequest"));
    simExtGetExitRequest=(ptrSimExtGetExitRequest)(_getProcAddress(lib,"simExtGetExitRequest"));
    simExtStep=(ptrSimExtStep)(_getProcAddress(lib,"simExtStep"));
    simExtCallScriptFunction=(ptrSimExtCallScriptFunction)(_getProcAddress(lib,"simExtCallScriptFunction"));

    _simGetContactCallbackCount=(ptr_simGetContactCallbackCount)(_getProcAddress(lib,"_simGetContactCallbackCount"));
    _simGetContactCallback=(ptr_simGetContactCallback)(_getProcAddress(lib,"_simGetContactCallback"));
    _simSetDynamicSimulationIconCode=(ptr_simSetDynamicSimulationIconCode)(_getProcAddress(lib,"_simSetDynamicSimulationIconCode"));
    _simSetDynamicObjectFlagForVisualization=(ptr_simSetDynamicObjectFlagForVisualization)(_getProcAddress(lib,"_simSetDynamicObjectFlagForVisualization"));
    _simGetObjectListSize=(ptr_simGetObjectListSize)(_getProcAddress(lib,"_simGetObjectListSize"));
    _simGetObjectFromIndex=(ptr_simGetObjectFromIndex)(_getProcAddress(lib,"_simGetObjectFromIndex"));
    _simGetObjectID=(ptr_simGetObjectID)(_getProcAddress(lib,"_simGetObjectID"));
    _simGetObjectType=(ptr_simGetObjectType)(_getProcAddress(lib,"_simGetObjectType"));
    _simGetObjectChildren=(ptr_simGetObjectChildren)(_getProcAddress(lib,"_simGetObjectChildren"));
    _simGetGeomProxyFromShape=(ptr_simGetGeomProxyFromShape)(_getProcAddress(lib,"_simGetGeomProxyFromShape"));
    _simGetParentObject=(ptr_simGetParentObject)(_getProcAddress(lib,"_simGetParentObject"));
    _simGetObject=(ptr_simGetObject)(_getProcAddress(lib,"_simGetObject"));
    _simGetIkGroupObject=(ptr_simGetIkGroupObject)(_getProcAddress(lib,"_simGetIkGroupObject"));
    _simMpHandleIkGroupObject=(ptr_simMpHandleIkGroupObject)(_getProcAddress(lib,"_simMpHandleIkGroupObject"));
    _simGetObjectLocalTransformation=(ptr_simGetObjectLocalTransformation)(_getProcAddress(lib,"_simGetObjectLocalTransformation"));
    _simSetObjectLocalTransformation=(ptr_simSetObjectLocalTransformation)(_getProcAddress(lib,"_simSetObjectLocalTransformation"));
    _simSetObjectCumulativeTransformation=(ptr_simSetObjectCumulativeTransformation)(_getProcAddress(lib,"_simSetObjectCumulativeTransformation"));
    _simGetObjectCumulativeTransformation=(ptr_simGetObjectCumulativeTransformation)(_getProcAddress(lib,"_simGetObjectCumulativeTransformation"));
    _simIsShapeDynamicallyStatic=(ptr_simIsShapeDynamicallyStatic)(_getProcAddress(lib,"_simIsShapeDynamicallyStatic"));
    _simGetTreeDynamicProperty=(ptr_simGetTreeDynamicProperty)(_getProcAddress(lib,"_simGetTreeDynamicProperty"));
    _simGetDummyLinkType=(ptr_simGetDummyLinkType)(_getProcAddress(lib,"_simGetDummyLinkType"));
    _simGetJointMode=(ptr_simGetJointMode)(_getProcAddress(lib,"_simGetJointMode"));
    _simIsJointInHybridOperation=(ptr_simIsJointInHybridOperation)(_getProcAddress(lib,"_simIsJointInHybridOperation"));
    _simDisableDynamicTreeForManipulation=(ptr_simDisableDynamicTreeForManipulation)(_getProcAddress(lib,"_simDisableDynamicTreeForManipulation"));
    _simIsShapeDynamicallyRespondable=(ptr_simIsShapeDynamicallyRespondable)(_getProcAddress(lib,"_simIsShapeDynamicallyRespondable"));
    _simGetDynamicCollisionMask=(ptr_simGetDynamicCollisionMask)(_getProcAddress(lib,"_simGetDynamicCollisionMask"));
    _simGetLastParentForLocalGlobalCollidable=(ptr_simGetLastParentForLocalGlobalCollidable)(_getProcAddress(lib,"_simGetLastParentForLocalGlobalCollidable"));
    _simSetShapeIsStaticAndNotRespondableButDynamicTag=(ptr_simSetShapeIsStaticAndNotRespondableButDynamicTag)(_getProcAddress(lib,"_simSetShapeIsStaticAndNotRespondableButDynamicTag"));
    _simGetShapeIsStaticAndNotRespondableButDynamicTag=(ptr_simGetShapeIsStaticAndNotRespondableButDynamicTag)(_getProcAddress(lib,"_simGetShapeIsStaticAndNotRespondableButDynamicTag"));
    _simSetJointPosition=(ptr_simSetJointPosition)(_getProcAddress(lib,"_simSetJointPosition"));
    _simGetJointPosition=(ptr_simGetJointPosition)(_getProcAddress(lib,"_simGetJointPosition"));
    _simSetDynamicMotorPositionControlTargetPosition=(ptr_simSetDynamicMotorPositionControlTargetPosition)(_getProcAddress(lib,"_simSetDynamicMotorPositionControlTargetPosition"));
    _simGetInitialDynamicVelocity=(ptr_simGetInitialDynamicVelocity)(_getProcAddress(lib,"_simGetInitialDynamicVelocity"));
    _simSetInitialDynamicVelocity=(ptr_simSetInitialDynamicVelocity)(_getProcAddress(lib,"_simSetInitialDynamicVelocity"));
    _simGetInitialDynamicAngVelocity=(ptr_simGetInitialDynamicAngVelocity)(_getProcAddress(lib,"_simGetInitialDynamicAngVelocity"));
    _simSetInitialDynamicAngVelocity=(ptr_simSetInitialDynamicAngVelocity)(_getProcAddress(lib,"_simSetInitialDynamicAngVelocity"));
    _simGetStartSleeping=(ptr_simGetStartSleeping)(_getProcAddress(lib,"_simGetStartSleeping"));
    _simGetWasPutToSleepOnce=(ptr_simGetWasPutToSleepOnce)(_getProcAddress(lib,"_simGetWasPutToSleepOnce"));
    _simGetDynamicsFullRefreshFlag=(ptr_simGetDynamicsFullRefreshFlag)(_getProcAddress(lib,"_simGetDynamicsFullRefreshFlag"));
    _simSetDynamicsFullRefreshFlag=(ptr_simSetDynamicsFullRefreshFlag)(_getProcAddress(lib,"_simSetDynamicsFullRefreshFlag"));
    _simSetGeomProxyDynamicsFullRefreshFlag=(ptr_simSetGeomProxyDynamicsFullRefreshFlag)(_getProcAddress(lib,"_simSetGeomProxyDynamicsFullRefreshFlag"));
    _simGetGeomProxyDynamicsFullRefreshFlag=(ptr_simGetGeomProxyDynamicsFullRefreshFlag)(_getProcAddress(lib,"_simGetGeomProxyDynamicsFullRefreshFlag"));
    _simGetParentFollowsDynamic=(ptr_simGetParentFollowsDynamic)(_getProcAddress(lib,"_simGetParentFollowsDynamic"));
    _simSetShapeDynamicVelocity=(ptr_simSetShapeDynamicVelocity)(_getProcAddress(lib,"_simSetShapeDynamicVelocity"));
    _simGetAdditionalForceAndTorque=(ptr_simGetAdditionalForceAndTorque)(_getProcAddress(lib,"_simGetAdditionalForceAndTorque"));
    _simClearAdditionalForceAndTorque=(ptr_simClearAdditionalForceAndTorque)(_getProcAddress(lib,"_simClearAdditionalForceAndTorque"));
    _simGetJointPositionInterval=(ptr_simGetJointPositionInterval)(_getProcAddress(lib,"_simGetJointPositionInterval"));
    _simGetJointType=(ptr_simGetJointType)(_getProcAddress(lib,"_simGetJointType"));
    _simIsForceSensorBroken=(ptr_simIsForceSensorBroken)(_getProcAddress(lib,"_simIsForceSensorBroken"));
    _simGetDynamicForceSensorLocalTransformationPart2=(ptr_simGetDynamicForceSensorLocalTransformationPart2)(_getProcAddress(lib,"_simGetDynamicForceSensorLocalTransformationPart2"));
    _simIsDynamicMotorEnabled=(ptr_simIsDynamicMotorEnabled)(_getProcAddress(lib,"_simIsDynamicMotorEnabled"));
    _simIsDynamicMotorPositionCtrlEnabled=(ptr_simIsDynamicMotorPositionCtrlEnabled)(_getProcAddress(lib,"_simIsDynamicMotorPositionCtrlEnabled"));
    _simIsDynamicMotorTorqueModulationEnabled=(ptr_simIsDynamicMotorTorqueModulationEnabled)(_getProcAddress(lib,"_simIsDynamicMotorTorqueModulationEnabled"));
    _simGetMotorPid=(ptr_simGetMotorPid)(_getProcAddress(lib,"_simGetMotorPid"));
    _simGetDynamicMotorTargetPosition=(ptr_simGetDynamicMotorTargetPosition)(_getProcAddress(lib,"_simGetDynamicMotorTargetPosition"));
    _simGetDynamicMotorTargetVelocity=(ptr_simGetDynamicMotorTargetVelocity)(_getProcAddress(lib,"_simGetDynamicMotorTargetVelocity"));
    _simGetDynamicMotorMaxForce=(ptr_simGetDynamicMotorMaxForce)(_getProcAddress(lib,"_simGetDynamicMotorMaxForce"));
    _simGetDynamicMotorUpperLimitVelocity=(ptr_simGetDynamicMotorUpperLimitVelocity)(_getProcAddress(lib,"_simGetDynamicMotorUpperLimitVelocity"));
    _simSetDynamicMotorReflectedPositionFromDynamicEngine=(ptr_simSetDynamicMotorReflectedPositionFromDynamicEngine)(_getProcAddress(lib,"_simSetDynamicMotorReflectedPositionFromDynamicEngine"));
    _simSetJointSphericalTransformation=(ptr_simSetJointSphericalTransformation)(_getProcAddress(lib,"_simSetJointSphericalTransformation"));
    _simAddForceSensorCumulativeForcesAndTorques=(ptr_simAddForceSensorCumulativeForcesAndTorques)(_getProcAddress(lib,"_simAddForceSensorCumulativeForcesAndTorques"));
    _simAddJointCumulativeForcesOrTorques=(ptr_simAddJointCumulativeForcesOrTorques)(_getProcAddress(lib,"_simAddJointCumulativeForcesOrTorques"));
    _simSetDynamicJointLocalTransformationPart2=(ptr_simSetDynamicJointLocalTransformationPart2)(_getProcAddress(lib,"_simSetDynamicJointLocalTransformationPart2"));
    _simSetDynamicForceSensorLocalTransformationPart2=(ptr_simSetDynamicForceSensorLocalTransformationPart2)(_getProcAddress(lib,"_simSetDynamicForceSensorLocalTransformationPart2"));
    _simSetDynamicJointLocalTransformationPart2IsValid=(ptr_simSetDynamicJointLocalTransformationPart2IsValid)(_getProcAddress(lib,"_simSetDynamicJointLocalTransformationPart2IsValid"));
    _simSetDynamicForceSensorLocalTransformationPart2IsValid=(ptr_simSetDynamicForceSensorLocalTransformationPart2IsValid)(_getProcAddress(lib,"_simSetDynamicForceSensorLocalTransformationPart2IsValid"));
    _simGetGeomWrapFromGeomProxy=(ptr_simGetGeomWrapFromGeomProxy)(_getProcAddress(lib,"_simGetGeomWrapFromGeomProxy"));
    _simGetLocalInertiaFrame=(ptr_simGetLocalInertiaFrame)(_getProcAddress(lib,"_simGetLocalInertiaFrame"));
    _simGetPurePrimitiveType=(ptr_simGetPurePrimitiveType)(_getProcAddress(lib,"_simGetPurePrimitiveType"));
    _simIsGeomWrapGeometric=(ptr_simIsGeomWrapGeometric)(_getProcAddress(lib,"_simIsGeomWrapGeometric"));
    _simIsGeomWrapConvex=(ptr_simIsGeomWrapConvex)(_getProcAddress(lib,"_simIsGeomWrapConvex"));
    _simGetGeometricCount=(ptr_simGetGeometricCount)(_getProcAddress(lib,"_simGetGeometricCount"));
    _simGetAllGeometrics=(ptr_simGetAllGeometrics)(_getProcAddress(lib,"_simGetAllGeometrics"));
    _simGetPurePrimitiveSizes=(ptr_simGetPurePrimitiveSizes)(_getProcAddress(lib,"_simGetPurePrimitiveSizes"));
    _simMakeDynamicAnnouncement=(ptr_simMakeDynamicAnnouncement)(_getProcAddress(lib,"_simMakeDynamicAnnouncement"));
    _simGetVerticesLocalFrame=(ptr_simGetVerticesLocalFrame)(_getProcAddress(lib,"_simGetVerticesLocalFrame"));
    _simGetHeightfieldData=(ptr_simGetHeightfieldData)(_getProcAddress(lib,"_simGetHeightfieldData"));
    _simGetCumulativeMeshes=(ptr_simGetCumulativeMeshes)(_getProcAddress(lib,"_simGetCumulativeMeshes"));
    _simGetMass=(ptr_simGetMass)(_getProcAddress(lib,"_simGetMass"));
    _simGetPrincipalMomentOfInertia=(ptr_simGetPrincipalMomentOfInertia)(_getProcAddress(lib,"_simGetPrincipalMomentOfInertia"));
    _simGetGravity=(ptr_simGetGravity)(_getProcAddress(lib,"_simGetGravity"));
    _simGetTimeDiffInMs=(ptr_simGetTimeDiffInMs)(_getProcAddress(lib,"_simGetTimeDiffInMs"));
    _simDoEntitiesCollide=(ptr_simDoEntitiesCollide)(_getProcAddress(lib,"_simDoEntitiesCollide"));
    _simGetDistanceBetweenEntitiesIfSmaller=(ptr_simGetDistanceBetweenEntitiesIfSmaller)(_getProcAddress(lib,"_simGetDistanceBetweenEntitiesIfSmaller"));
    _simHandleJointControl=(ptr_simHandleJointControl)(_getProcAddress(lib,"_simHandleJointControl"));
    _simHandleCustomContact=(ptr_simHandleCustomContact)(_getProcAddress(lib,"_simHandleCustomContact"));
    _simGetPureHollowScaling=(ptr_simGetPureHollowScaling)(_getProcAddress(lib,"_simGetPureHollowScaling"));
    _simGetJointCallbackCallOrder=(ptr_simGetJointCallbackCallOrder)(_getProcAddress(lib,"_simGetJointCallbackCallOrder"));
    _simDynCallback=(ptr_simDynCallback)(_getProcAddress(lib,"_simDynCallback"));



    // Deprecated begin
    simGetMaterialId=(ptrSimGetMaterialId)(_getProcAddress(lib,"simGetMaterialId"));
    simGetShapeMaterial=(ptrSimGetShapeMaterial)(_getProcAddress(lib,"simGetShapeMaterial"));
    simHandleVarious=(ptrSimHandleVarious)(_getProcAddress(lib,"simHandleVarious"));
    simSerialPortOpen=(ptrSimSerialPortOpen)(_getProcAddress(lib,"simSerialPortOpen"));
    simSerialPortClose=(ptrSimSerialPortClose)(_getProcAddress(lib,"simSerialPortClose"));
    simSerialPortSend=(ptrSimSerialPortSend)(_getProcAddress(lib,"simSerialPortSend"));
    simSerialPortRead=(ptrSimSerialPortRead)(_getProcAddress(lib,"simSerialPortRead"));
    simJointGetForce=(ptrSimJointGetForce)(_getProcAddress(lib,"simJointGetForce"));
    simGetPathPlanningHandle=(ptrSimGetPathPlanningHandle)(_getProcAddress(lib,"simGetPathPlanningHandle"));
    simGetMotionPlanningHandle=(ptrSimGetMotionPlanningHandle)(_getProcAddress(lib,"simGetMotionPlanningHandle"));
    simGetMpConfigForTipPose=(ptrSimGetMpConfigForTipPose)(_getProcAddress(lib,"simGetMpConfigForTipPose"));
    simFindMpPath=(ptrSimFindMpPath)(_getProcAddress(lib,"simFindMpPath"));
    simSimplifyMpPath=(ptrSimSimplifyMpPath)(_getProcAddress(lib,"simSimplifyMpPath"));
    simGetMpConfigTransition=(ptrSimGetMpConfigTransition)(_getProcAddress(lib,"simGetMpConfigTransition"));
    simFindIkPath=(ptrSimFindIkPath)(_getProcAddress(lib,"simFindIkPath"));
    simCreateMotionPlanning=(ptrSimCreateMotionPlanning)(_getProcAddress(lib,"simCreateMotionPlanning"));
    simRemoveMotionPlanning=(ptrSimRemoveMotionPlanning)(_getProcAddress(lib,"simRemoveMotionPlanning"));
    simSearchPath=(ptrSimSearchPath)(_getProcAddress(lib,"simSearchPath"));
    simInitializePathSearch=(ptrSimInitializePathSearch)(_getProcAddress(lib,"simInitializePathSearch"));
    simPerformPathSearchStep=(ptrSimPerformPathSearchStep)(_getProcAddress(lib,"simPerformPathSearchStep"));
    simLockInterface=(ptrSimLockInterface)(_getProcAddress(lib,"simLockInterface"));
    simCopyPasteSelectedObjects=(ptrSimCopyPasteSelectedObjects)(_getProcAddress(lib,"simCopyPasteSelectedObjects"));
    simResetPath=(ptrSimResetPath)(_getProcAddress(lib,"simResetPath"));
    simHandlePath=(ptrSimHandlePath)(_getProcAddress(lib,"simHandlePath"));
    simResetJoint=(ptrSimResetJoint)(_getProcAddress(lib,"simResetJoint"));
    simHandleJoint=(ptrSimHandleJoint)(_getProcAddress(lib,"simHandleJoint"));
    simAppendScriptArrayEntry=(ptrSimAppendScriptArrayEntry)(_getProcAddress(lib,"simAppendScriptArrayEntry"));
    simClearScriptVariable=(ptrSimClearScriptVariable)(_getProcAddress(lib,"simClearScriptVariable"));
    _simGetJointOdeParameters=(ptr_simGetJointOdeParameters)(_getProcAddress(lib,"_simGetJointOdeParameters"));
    _simGetJointBulletParameters=(ptr_simGetJointBulletParameters)(_getProcAddress(lib,"_simGetJointBulletParameters"));
    _simGetOdeMaxContactFrictionCFMandERP=(ptr_simGetOdeMaxContactFrictionCFMandERP)(_getProcAddress(lib,"_simGetOdeMaxContactFrictionCFMandERP"));
    _simGetBulletCollisionMargin=(ptr_simGetBulletCollisionMargin)(_getProcAddress(lib,"_simGetBulletCollisionMargin"));
    _simGetBulletStickyContact=(ptr_simGetBulletStickyContact)(_getProcAddress(lib,"_simGetBulletStickyContact"));
    _simGetBulletRestitution=(ptr_simGetBulletRestitution)(_getProcAddress(lib,"_simGetBulletRestitution"));
    _simGetVortexParameters=(ptr_simGetVortexParameters)(_getProcAddress(lib,"_simGetVortexParameters"));
    _simGetNewtonParameters=(ptr_simGetNewtonParameters)(_getProcAddress(lib,"_simGetNewtonParameters"));
    _simGetDamping=(ptr_simGetDamping)(_getProcAddress(lib,"_simGetDamping"));
    _simGetFriction=(ptr_simGetFriction)(_getProcAddress(lib,"_simGetFriction"));
    simAddSceneCustomData=(ptrSimAddSceneCustomData)(_getProcAddress(lib,"simAddSceneCustomData"));
    simGetSceneCustomDataLength=(ptrSimGetSceneCustomDataLength)(_getProcAddress(lib,"simGetSceneCustomDataLength"));
    simGetSceneCustomData=(ptrSimGetSceneCustomData)(_getProcAddress(lib,"simGetSceneCustomData"));
    simAddObjectCustomData=(ptrSimAddObjectCustomData)(_getProcAddress(lib,"simAddObjectCustomData"));
    simGetObjectCustomDataLength=(ptrSimGetObjectCustomDataLength)(_getProcAddress(lib,"simGetObjectCustomDataLength"));
    simGetObjectCustomData=(ptrSimGetObjectCustomData)(_getProcAddress(lib,"simGetObjectCustomData"));
    simCreateUI=(ptrSimCreateUI)(_getProcAddress(lib,"simCreateUI"));
    simCreateUIButton=(ptrSimCreateUIButton)(_getProcAddress(lib,"simCreateUIButton"));
    simGetUIHandle=(ptrSimGetUIHandle)(_getProcAddress(lib,"simGetUIHandle"));
    simGetUIProperty=(ptrSimGetUIProperty)(_getProcAddress(lib,"simGetUIProperty"));
    simGetUIEventButton=(ptrSimGetUIEventButton)(_getProcAddress(lib,"simGetUIEventButton"));
    simSetUIProperty=(ptrSimSetUIProperty)(_getProcAddress(lib,"simSetUIProperty"));
    simGetUIButtonProperty=(ptrSimGetUIButtonProperty)(_getProcAddress(lib,"simGetUIButtonProperty"));
    simSetUIButtonProperty=(ptrSimSetUIButtonProperty)(_getProcAddress(lib,"simSetUIButtonProperty"));
    simGetUIButtonSize=(ptrSimGetUIButtonSize)(_getProcAddress(lib,"simGetUIButtonSize"));
    simSetUIButtonLabel=(ptrSimSetUIButtonLabel)(_getProcAddress(lib,"simSetUIButtonLabel"));
    simGetUIButtonLabel=(ptrSimGetUIButtonLabel)(_getProcAddress(lib,"simGetUIButtonLabel"));
    simSetUISlider=(ptrSimSetUISlider)(_getProcAddress(lib,"simSetUISlider"));
    simGetUISlider=(ptrSimGetUISlider)(_getProcAddress(lib,"simGetUISlider"));
    simSetUIButtonColor=(ptrSimSetUIButtonColor)(_getProcAddress(lib,"simSetUIButtonColor"));
    simSetUIButtonTexture=(ptrSimSetUIButtonTexture)(_getProcAddress(lib,"simSetUIButtonTexture"));
    simCreateUIButtonArray=(ptrSimCreateUIButtonArray)(_getProcAddress(lib,"simCreateUIButtonArray"));
    simSetUIButtonArrayColor=(ptrSimSetUIButtonArrayColor)(_getProcAddress(lib,"simSetUIButtonArrayColor"));
    simDeleteUIButtonArray=(ptrSimDeleteUIButtonArray)(_getProcAddress(lib,"simDeleteUIButtonArray"));
    simRemoveUI=(ptrSimRemoveUI)(_getProcAddress(lib,"simRemoveUI"));
    simSetUIPosition=(ptrSimSetUIPosition)(_getProcAddress(lib,"simSetUIPosition"));
    simGetUIPosition=(ptrSimGetUIPosition)(_getProcAddress(lib,"simGetUIPosition"));
    simLoadUI=(ptrSimLoadUI)(_getProcAddress(lib,"simLoadUI"));
    simSaveUI=(ptrSimSaveUI)(_getProcAddress(lib,"simSaveUI"));
    simHandleGeneralCallbackScript=(ptrSimHandleGeneralCallbackScript)(_getProcAddress(lib,"simHandleGeneralCallbackScript"));
    simRegisterCustomLuaFunction=(ptrSimRegisterCustomLuaFunction)(_getProcAddress(lib,"simRegisterCustomLuaFunction"));
    simRegisterCustomLuaVariable=(ptrSimRegisterCustomLuaVariable)(_getProcAddress(lib,"simRegisterCustomLuaVariable"));
    simRegisterContactCallback=(ptrSimRegisterContactCallback)(_getProcAddress(lib,"simRegisterContactCallback"));
    simGetMechanismHandle=(ptrSimGetMechanismHandle)(_getProcAddress(lib,"simGetMechanismHandle"));
    simHandleMechanism=(ptrSimHandleMechanism)(_getProcAddress(lib,"simHandleMechanism"));
    simHandleCustomizationScripts=(ptrSimHandleCustomizationScripts)(_getProcAddress(lib,"simHandleCustomizationScripts"));
    simCallScriptFunction=(ptrSimCallScriptFunction)(_getProcAddress(lib,"simCallScriptFunction"));
    simSetVisionSensorFilter=(ptrSimSetVisionSensorFilter)(_getProcAddress(lib,"simSetVisionSensorFilter"));
    simGetVisionSensorFilter=(ptrSimGetVisionSensorFilter)(_getProcAddress(lib,"simGetVisionSensorFilter"));
    simGetScriptSimulationParameter=(ptrSimGetScriptSimulationParameter)(_getProcAddress(lib,"simGetScriptSimulationParameter"));
    simSetScriptSimulationParameter=(ptrSimSetScriptSimulationParameter)(_getProcAddress(lib,"simSetScriptSimulationParameter"));
    simSetJointForce=(ptrSimSetJointForce)(_getProcAddress(lib,"simSetJointForce"));
    // Deprecated end


    char couldNotFind[]="Could not find function";
    if (simRunSimulator==nullptr)
    {
        printf("%s simRunSimulator\n",couldNotFind);
        return 0;
    }
    if (simRunSimulatorEx==nullptr)
    {
        printf("%s simRunSimulatorEx\n",couldNotFind);
        return 0;
    }
    if (simGetSimulatorMessage==nullptr)
    {
        printf("%s simGetSimulatorMessage\n",couldNotFind);
        return 0;
    }
    if (simGetMainWindow==nullptr)
    {
        printf("%s simGetMainWindow\n",couldNotFind);
        return 0;
    }
    if (simGetLastError==nullptr)
    {
        printf("%s simGetLastError\n",couldNotFind);
        return 0;
    }
    if (simLoadModule==nullptr)
    {
        printf("%s simLoadModule\n",couldNotFind);
        return 0;
    }
    if (simUnloadModule==nullptr)
    {
        printf("%s simUnloadModule\n",couldNotFind);
        return 0;
    }
    if (simSendModuleMessage==nullptr)
    {
        printf("%s simSendModuleMessage\n",couldNotFind);
        return 0;
    }
    if (simSetBooleanParameter==nullptr)
    {
        printf("%s simSetBooleanParameter\n",couldNotFind);
        return 0;
    }
    if (simGetBooleanParameter==nullptr)
    {
        printf("%s simGetBooleanParameter\n",couldNotFind);
        return 0;
    }
    if (simSetBoolParameter==nullptr)
    {
        printf("%s simSetBoolParameter\n",couldNotFind);
        return 0;
    }
    if (simGetBoolParameter==nullptr)
    {
        printf("%s simGetBoolParameter\n",couldNotFind);
        return 0;
    }
    if (simSetIntegerParameter==nullptr)
    {
        printf("%s simSetIntegerParameter\n",couldNotFind);
        return 0;
    }
    if (simGetIntegerParameter==nullptr)
    {
        printf("%s simGetIntegerParameter\n",couldNotFind);
        return 0;
    }
    if (simSetInt32Parameter==nullptr)
    {
        printf("%s simSetInt32Parameter\n",couldNotFind);
        return 0;
    }
    if (simGetInt32Parameter==nullptr)
    {
        printf("%s simGetInt32Parameter\n",couldNotFind);
        return 0;
    }
    if (simGetUInt64Parameter==nullptr)
    {
        printf("%s simGetUInt64Parameter\n",couldNotFind);
        return 0;
    }
    if (simSetFloatingParameter==nullptr)
    {
        printf("%s simSetFloatingParameter\n",couldNotFind);
        return 0;
    }
    if (simGetFloatingParameter==nullptr)
    {
        printf("%s simGetFloatingParameter\n",couldNotFind);
        return 0;
    }
    if (simSetFloatParameter==nullptr)
    {
        printf("%s simSetFloatParameter\n",couldNotFind);
        return 0;
    }
    if (simGetFloatParameter==nullptr)
    {
        printf("%s simGetFloatParameter\n",couldNotFind);
        return 0;
    }
    if (simSetStringParameter==nullptr)
    {
        printf("%s simSetStringParameter\n",couldNotFind);
        return 0;
    }
    if (simGetStringParameter==nullptr)
    {
        printf("%s simGetStringParameter\n",couldNotFind);
        return 0;
    }
    if (simGetObjectHandle==nullptr)
    {
        printf("%s simGetObjectHandle\n",couldNotFind);
        return 0;
    }
    if (simRemoveObject==nullptr)
    {
        printf("%s simRemoveObject\n",couldNotFind);
        return 0;
    }
    if (simRemoveModel==nullptr)
    {
        printf("%s simRemoveModel\n",couldNotFind);
        return 0;
    }
    if (simGetObjectName==nullptr)
    {
        printf("%s simGetObjectName\n",couldNotFind);
        return 0;
    }
    if (simGetObjects==nullptr)
    {
        printf("%s simGetObjects\n",couldNotFind);
        return 0;
    }
    if (simSetObjectName==nullptr)
    {
        printf("%s simSetObjectName\n",couldNotFind);
        return 0;
    }
    if (simGetCollectionHandle==nullptr)
    {
        printf("%s simGetCollectionHandle\n",couldNotFind);
        return 0;
    }
    if (simRemoveCollection==nullptr)
    {
        printf("%s simRemoveCollection\n",couldNotFind);
        return 0;
    }
    if (simEmptyCollection==nullptr)
    {
        printf("%s simEmptyCollection\n",couldNotFind);
        return 0;
    }
    if (simGetCollectionName==nullptr)
    {
        printf("%s simGetCollectionName\n",couldNotFind);
        return 0;
    }
    if (simSetCollectionName==nullptr)
    {
        printf("%s simSetCollectionName\n",couldNotFind);
        return 0;
    }
    if (simGetObjectMatrix==nullptr)
    {
        printf("%s simGetObjectMatrix\n",couldNotFind);
        return 0;
    }
    if (simSetObjectMatrix==nullptr)
    {
        printf("%s simSetObjectMatrix\n",couldNotFind);
        return 0;
    }
    if (simGetObjectPosition==nullptr)
    {
        printf("%s simGetObjectPosition\n",couldNotFind);
        return 0;
    }
    if (simSetObjectPosition==nullptr)
    {
        printf("%s simSetObjectPosition\n",couldNotFind);
        return 0;
    }
    if (simGetObjectOrientation==nullptr)
    {
        printf("%s simGetObjectOrientation\n",couldNotFind);
        return 0;
    }
    if (simSetObjectOrientation==nullptr)
    {
        printf("%s simSetObjectOrientation\n",couldNotFind);
        return 0;
    }
    if (simGetJointPosition==nullptr)
    {
        printf("%s simGetJointPosition\n",couldNotFind);
        return 0;
    }
    if (simSetJointPosition==nullptr)
    {
        printf("%s simSetJointPosition\n",couldNotFind);
        return 0;
    }
    if (simSetJointTargetPosition==nullptr)
    {
        printf("%s simSetJointTargetPosition\n",couldNotFind);
        return 0;
    }
    if (simGetJointTargetPosition==nullptr)
    {
        printf("%s simGetJointTargetPosition\n",couldNotFind);
        return 0;
    }
    if (simSetJointMaxForce==nullptr)
    {
        printf("%s simSetJointMaxForce\n",couldNotFind);
        return 0;
    }
    if (simGetPathPosition==nullptr)
    {
        printf("%s simGetPathPosition\n",couldNotFind);
        return 0;
    }
    if (simSetPathPosition==nullptr)
    {
        printf("%s simSetPathPosition\n",couldNotFind);
        return 0;
    }
    if (simGetPathLength==nullptr)
    {
        printf("%s simGetPathLength\n",couldNotFind);
        return 0;
    }
    if (simGetJointMatrix==nullptr)
    {
        printf("%s simGetJointMatrix\n",couldNotFind);
        return 0;
    }
    if (simSetSphericalJointMatrix==nullptr)
    {
        printf("%s simSetSphericalJointMatrix\n",couldNotFind);
        return 0;
    }
    if (simGetJointInterval==nullptr)
    {
        printf("%s simGetJointInterval\n",couldNotFind);
        return 0;
    }
    if (simSetJointInterval==nullptr)
    {
        printf("%s simSetJointInterval\n",couldNotFind);
        return 0;
    }
    if (simGetObjectParent==nullptr)
    {
        printf("%s simGetObjectParent\n",couldNotFind);
        return 0;
    }
    if (simGetObjectChild==nullptr)
    {
        printf("%s simGetObjectChild\n",couldNotFind);
        return 0;
    }
    if (simSetObjectParent==nullptr)
    {
        printf("%s simSetObjectParent\n",couldNotFind);
        return 0;
    }
    if (simGetObjectType==nullptr)
    {
        printf("%s simGetObjectType\n",couldNotFind);
        return 0;
    }
    if (simGetJointType==nullptr)
    {
        printf("%s simGetJointType\n",couldNotFind);
        return 0;
    }
    if (simBuildIdentityMatrix==nullptr)
    {
        printf("%s simBuildIdentityMatrix\n",couldNotFind);
        return 0;
    }
    if (simCopyMatrix==nullptr)
    {
        printf("%s simCopyMatrix\n",couldNotFind);
        return 0;
    }
    if (simBuildMatrix==nullptr)
    {
        printf("%s simBuildMatrix\n",couldNotFind);
        return 0;
    }
    if (simGetEulerAnglesFromMatrix==nullptr)
    {
        printf("%s simGetEulerAnglesFromMatrix\n",couldNotFind);
        return 0;
    }
    if (simInvertMatrix==nullptr)
    {
        printf("%s simInvertMatrix\n",couldNotFind);
        return 0;
    }
    if (simMultiplyMatrices==nullptr)
    {
        printf("%s simMultiplyMatrices\n",couldNotFind);
        return 0;
    }
    if (simInterpolateMatrices==nullptr)
    {
        printf("%s simInterpolateMatrices\n",couldNotFind);
        return 0;
    }
    if (simTransformVector==nullptr)
    {
        printf("%s simTransformVector\n",couldNotFind);
        return 0;
    }
    if (simReservedCommand==nullptr)
    {
        printf("%s simReservedCommand\n",couldNotFind);
        return 0;
    }
    if (simGetSimulationTime==nullptr)
    {
        printf("%s simGetSimulationTime\n",couldNotFind);
        return 0;
    }
    if (simGetSimulationState==nullptr)
    {
        printf("%s simGetSimulationState\n",couldNotFind);
        return 0;
    }
    if (simGetSystemTime==nullptr)
    {
        printf("%s simGetSystemTime\n",couldNotFind);
        return 0;
    }
    if (simGetSystemTimeInMilliseconds==nullptr)
    {
        printf("%s simGetSystemTimeInMilliseconds\n",couldNotFind);
        return 0;
    }
    if (simGetSystemTimeInMs==nullptr)
    {
        printf("%s simGetSystemTimeInMs\n",couldNotFind);
        return 0;
    }
    if (simLoadScene==nullptr)
    {
        printf("%s simLoadScene\n",couldNotFind);
        return 0;
    }
    if (simCloseScene==nullptr)
    {
        printf("%s simCloseScene\n",couldNotFind);
        return 0;
    }
    if (simSaveScene==nullptr)
    {
        printf("%s simSaveScene\n",couldNotFind);
        return 0;
    }
    if (simLoadModel==nullptr)
    {
        printf("%s simLoadModel\n",couldNotFind);
        return 0;
    }
    if (simSaveModel==nullptr)
    {
        printf("%s simSaveModel\n",couldNotFind);
        return 0;
    }
    if (simAddStatusbarMessage==nullptr)
    {
        printf("%s simAddStatusbarMessage\n",couldNotFind);
        return 0;
    }
    if (simAddModuleMenuEntry==nullptr)
    {
        printf("%s simAddModuleMenuEntry\n",couldNotFind);
        return 0;
    }
    if (simSetModuleMenuItemState==nullptr)
    {
        printf("%s simSetModuleMenuItemState\n",couldNotFind);
        return 0;
    }
    if (simDoesFileExist==nullptr)
    {
        printf("%s simDoesFileExist\n",couldNotFind);
        return 0;
    }
    if (simIsObjectInSelection==nullptr)
    {
        printf("%s simIsObjectInSelection\n",couldNotFind);
        return 0;
    }
    if (simAddObjectToSelection==nullptr)
    {
        printf("%s simAddObjectToSelection\n",couldNotFind);
        return 0;
    }
    if (simRemoveObjectFromSelection==nullptr)
    {
        printf("%s simRemoveObjectFromSelection\n",couldNotFind);
        return 0;
    }
    if (simGetObjectSelectionSize==nullptr)
    {
        printf("%s simGetObjectSelectionSize\n",couldNotFind);
        return 0;
    }
    if (simGetObjectLastSelection==nullptr)
    {
        printf("%s simGetObjectLastSelection\n",couldNotFind);
        return 0;
    }
    if (simGetObjectSelection==nullptr)
    {
        printf("%s simGetObjectSelection\n",couldNotFind);
        return 0;
    }
    if (simHandleCollision==nullptr)
    {
        printf("%s simHandleCollision\n",couldNotFind);
        return 0;
    }
    if (simReadCollision==nullptr)
    {
        printf("%s simReadCollision\n",couldNotFind);
        return 0;
    }
    if (simHandleDistance==nullptr)
    {
        printf("%s simHandleDistance\n",couldNotFind);
        return 0;
    }
    if (simReadDistance==nullptr)
    {
        printf("%s simReadDistance\n",couldNotFind);
        return 0;
    }
    if (simHandleProximitySensor==nullptr)
    {
        printf("%s simHandleProximitySensor\n",couldNotFind);
        return 0;
    }
    if (simReadProximitySensor==nullptr)
    {
        printf("%s simReadProximitySensor\n",couldNotFind);
        return 0;
    }
    if (simHandleMill==nullptr)
    {
        printf("%s simHandleMill\n",couldNotFind);
        return 0;
    }
    if (simHandleIkGroup==nullptr)
    {
        printf("%s simHandleIkGroup\n",couldNotFind);
        return 0;
    }
    if (simCheckIkGroup==nullptr)
    {
        printf("%s simCheckIkGroup\n",couldNotFind);
        return 0;
    }
    if (simHandleDynamics==nullptr)
    {
        printf("%s simHandleDynamics\n",couldNotFind);
        return 0;
    }
    if (simGetScriptHandle==nullptr)
    {
        printf("%s simGetScriptHandle\n",couldNotFind);
        return 0;
    }
    if (simSetScriptText==nullptr)
    {
        printf("%s simSetScriptText\n",couldNotFind);
        return 0;
    }
    if (simGetScriptText==nullptr)
    {
        printf("%s simGetScriptText\n",couldNotFind);
        return 0;
    }
    if (simGetScriptProperty==nullptr)
    {
        printf("%s simGetScriptProperty\n",couldNotFind);
        return 0;
    }
    if (simAssociateScriptWithObject==nullptr)
    {
        printf("%s simAssociateScriptWithObject\n",couldNotFind);
        return 0;
    }
    if (simGetScript==nullptr)
    {
        printf("%s simGetScript\n",couldNotFind);
        return 0;
    }
    if (simGetScriptAssociatedWithObject==nullptr)
    {
        printf("%s simGetScriptAssociatedWithObject\n",couldNotFind);
        return 0;
    }
    if (simGetCustomizationScriptAssociatedWithObject==nullptr)
    {
        printf("%s simGetCustomizationScriptAssociatedWithObject\n",couldNotFind);
        return 0;
    }
    if (simGetObjectAssociatedWithScript==nullptr)
    {
        printf("%s simGetObjectAssociatedWithScript\n",couldNotFind);
        return 0;
    }
    if (simGetScriptName==nullptr)
    {
        printf("%s simGetScriptName\n",couldNotFind);
        return 0;
    }
    if (simHandleMainScript==nullptr)
    {
        printf("%s simHandleMainScript\n",couldNotFind);
        return 0;
    }
    if (simResetScript==nullptr)
    {
        printf("%s simResetScript\n",couldNotFind);
        return 0;
    }
    if (simAddScript==nullptr)
    {
        printf("%s simAddScript\n",couldNotFind);
        return 0;
    }
    if (simRemoveScript==nullptr)
    {
        printf("%s simRemoveScript\n",couldNotFind);
        return 0;
    }
    if (simRefreshDialogs==nullptr)
    {
        printf("%s simRefreshDialogs\n",couldNotFind);
        return 0;
    }
    if (simGetCollisionHandle==nullptr)
    {
        printf("%s simGetCollisionHandle\n",couldNotFind);
        return 0;
    }
    if (simGetDistanceHandle==nullptr)
    {
        printf("%s simGetDistanceHandle\n",couldNotFind);
        return 0;
    }
    if (simGetIkGroupHandle==nullptr)
    {
        printf("%s simGetIkGroupHandle\n",couldNotFind);
        return 0;
    }
    if (simResetCollision==nullptr)
    {
        printf("%s simResetCollision\n",couldNotFind);
        return 0;
    }
    if (simResetDistance==nullptr)
    {
        printf("%s simResetDistance\n",couldNotFind);
        return 0;
    }
    if (simResetProximitySensor==nullptr)
    {
        printf("%s simResetProximitySensor\n",couldNotFind);
        return 0;
    }
    if (simResetMill==nullptr)
    {
        printf("%s simResetMill\n",couldNotFind);
        return 0;
    }
    if (simCheckProximitySensor==nullptr)
    {
        printf("%s simCheckProximitySensor\n",couldNotFind);
        return 0;
    }
    if (simCheckProximitySensorEx==nullptr)
    {
        printf("%s simCheckProximitySensorEx\n",couldNotFind);
        return 0;
    }
    if (simCheckProximitySensorEx2==nullptr)
    {
        printf("%s simCheckProximitySensorEx2\n",couldNotFind);
        return 0;
    }
    if (simCreateBuffer==nullptr)
    {
        printf("%s simCreateBuffer\n",couldNotFind);
        return 0;
    }
    if (simReleaseBuffer==nullptr)
    {
        printf("%s simReleaseBuffer\n",couldNotFind);
        return 0;
    }
    if (simCheckCollision==nullptr)
    {
        printf("%s simCheckCollision\n",couldNotFind);
        return 0;
    }
    if (simCheckCollisionEx==nullptr)
    {
        printf("%s simCheckCollisionEx\n",couldNotFind);
        return 0;
    }
    if (simCheckDistance==nullptr)
    {
        printf("%s simCheckDistance\n",couldNotFind);
        return 0;
    }
    if (simGetObjectConfiguration==nullptr)
    {
        printf("%s simGetObjectConfiguration\n",couldNotFind);
        return 0;
    }
    if (simSetObjectConfiguration==nullptr)
    {
        printf("%s simSetObjectConfiguration\n",couldNotFind);
        return 0;
    }
    if (simGetConfigurationTree==nullptr)
    {
        printf("%s simGetConfigurationTree\n",couldNotFind);
        return 0;
    }
    if (simSetConfigurationTree==nullptr)
    {
        printf("%s simSetConfigurationTree\n",couldNotFind);
        return 0;
    }
    if (simSetSimulationTimeStep==nullptr)
    {
        printf("%s simSetSimulationTimeStep\n",couldNotFind);
        return 0;
    }
    if (simGetSimulationTimeStep==nullptr)
    {
        printf("%s simGetSimulationTimeStep\n",couldNotFind);
        return 0;
    }
    if (simGetRealTimeSimulation==nullptr)
    {
        printf("%s simGetRealTimeSimulation\n",couldNotFind);
        return 0;
    }
    if (simIsRealTimeSimulationStepNeeded==nullptr)
    {
        printf("%s simIsRealTimeSimulationStepNeeded\n",couldNotFind);
        return 0;
    }
    if (simAdjustRealTimeTimer==nullptr)
    {
        printf("%s simAdjustRealTimeTimer\n",couldNotFind);
        return 0;
    }
    if (simGetSimulationPassesPerRenderingPass==nullptr)
    {
        printf("%s simGetSimulationPassesPerRenderingPass\n",couldNotFind);
        return 0;
    }
    if (simAdvanceSimulationByOneStep==nullptr)
    {
        printf("%s simAdvanceSimulationByOneStep\n",couldNotFind);
        return 0;
    }
    if (simStartSimulation==nullptr)
    {
        printf("%s simStartSimulation\n",couldNotFind);
        return 0;
    }
    if (simStopSimulation==nullptr)
    {
        printf("%s simStopSimulation\n",couldNotFind);
        return 0;
    }
    if (simPauseSimulation==nullptr)
    {
        printf("%s simPauseSimulation\n",couldNotFind);
        return 0;
    }
    if (simBroadcastMessage==nullptr)
    {
        printf("%s simBroadcastMessage\n",couldNotFind);
        return 0;
    }
    if (simGetModuleName==nullptr)
    {
        printf("%s simGetModuleName\n",couldNotFind);
        return 0;
    }
    if (simFloatingViewAdd==nullptr)
    {
        printf("%s simFloatingViewAdd\n",couldNotFind);
        return 0;
    }
    if (simFloatingViewRemove==nullptr)
    {
        printf("%s simFloatingViewRemove\n",couldNotFind);
        return 0;
    }
    if (simAdjustView==nullptr)
    {
        printf("%s simAdjustView\n",couldNotFind);
        return 0;
    }
    if (simSetLastError==nullptr)
    {
        printf("%s simSetLastError\n",couldNotFind);
        return 0;
    }
    if (simHandleGraph==nullptr)
    {
        printf("%s simHandleGraph\n",couldNotFind);
        return 0;
    }
    if (simResetGraph==nullptr)
    {
        printf("%s simResetGraph\n",couldNotFind);
        return 0;
    }
    if (simSetNavigationMode==nullptr)
    {
        printf("%s simSetNavigationMode\n",couldNotFind);
        return 0;
    }
    if (simGetNavigationMode==nullptr)
    {
        printf("%s simGetNavigationMode\n",couldNotFind);
        return 0;
    }
    if (simSetPage==nullptr)
    {
        printf("%s simSetPage\n",couldNotFind);
        return 0;
    }
    if (simGetPage==nullptr)
    {
        printf("%s simGetPage\n",couldNotFind);
        return 0;
    }
    if (simDisplayDialog==nullptr)
    {
        printf("%s simDisplayDialog\n",couldNotFind);
        return 0;
    }
    if (simGetDialogResult==nullptr)
    {
        printf("%s simGetDialogResult\n",couldNotFind);
        return 0;
    }
    if (simGetDialogInput==nullptr)
    {
        printf("%s simGetDialogInput\n",couldNotFind);
        return 0;
    }
    if (simEndDialog==nullptr)
    {
        printf("%s simEndDialog\n",couldNotFind);
        return 0;
    }
    if (simRegisterScriptCallbackFunction==nullptr)
    {
        printf("%s simRegisterScriptCallbackFunction\n",couldNotFind);
        return 0;
    }
    if (simRegisterScriptVariable==nullptr)
    {
        printf("%s simRegisterScriptVariable\n",couldNotFind);
        return 0;
    }
    if (simSetJointTargetVelocity==nullptr)
    {
        printf("%s simSetJointTargetVelocity\n",couldNotFind);
        return 0;
    }
    if (simGetJointTargetVelocity==nullptr)
    {
        printf("%s simGetJointTargetVelocity\n",couldNotFind);
        return 0;
    }
    if (simSetPathTargetNominalVelocity==nullptr)
    {
        printf("%s simSetPathTargetNominalVelocity\n",couldNotFind);
        return 0;
    }
    if (simGetScriptRawBuffer==nullptr)
    {
        printf("%s simGetScriptRawBuffer\n",couldNotFind);
        return 0;
    }
    if (simSetScriptRawBuffer==nullptr)
    {
        printf("%s simSetScriptRawBuffer\n",couldNotFind);
        return 0;
    }
    if (simReleaseScriptRawBuffer==nullptr)
    {
        printf("%s simReleaseScriptRawBuffer\n",couldNotFind);
        return 0;
    }
    if (simCopyPasteObjects==nullptr)
    {
        printf("%s simCopyPasteObjects\n",couldNotFind);
        return 0;
    }
    if (simScaleSelectedObjects==nullptr)
    {
        printf("%s simScaleSelectedObjects\n",couldNotFind);
        return 0;
    }
    if (simScaleObjects==nullptr)
    {
        printf("%s simScaleObjects\n",couldNotFind);
        return 0;
    }
    if (simDeleteSelectedObjects==nullptr)
    {
        printf("%s simDeleteSelectedObjects\n",couldNotFind);
        return 0;
    }
    if (simGetObjectUniqueIdentifier==nullptr)
    {
        printf("%s simGetObjectUniqueIdentifier\n",couldNotFind);
        return 0;
    }
    if (simGetNameSuffix==nullptr)
    {
        printf("%s simGetNameSuffix\n",couldNotFind);
        return 0;
    }
    if (simSendData==nullptr)
    {
        printf("%s simSendData\n",couldNotFind);
        return 0;
    }
    if (simReceiveData==nullptr)
    {
        printf("%s simReceiveData\n",couldNotFind);
        return 0;
    }
    if (simSetGraphUserData==nullptr)
    {
        printf("%s simSetGraphUserData\n",couldNotFind);
        return 0;
    }
    if (simSetNameSuffix==nullptr)
    {
        printf("%s simSetNameSuffix\n",couldNotFind);
        return 0;
    }
    if (simAddDrawingObject==nullptr)
    {
        printf("%s simAddDrawingObject\n",couldNotFind);
        return 0;
    }
    if (simRemoveDrawingObject==nullptr)
    {
        printf("%s simRemoveDrawingObject\n",couldNotFind);
        return 0;
    }
    if (simAddDrawingObjectItem==nullptr)
    {
        printf("%s simAddDrawingObjectItem\n",couldNotFind);
        return 0;
    }
    if (simAddParticleObject==nullptr)
    {
        printf("%s simAddParticleObject\n",couldNotFind);
        return 0;
    }
    if (simRemoveParticleObject==nullptr)
    {
        printf("%s simRemoveParticleObject\n",couldNotFind);
        return 0;
    }
    if (simAddParticleObjectItem==nullptr)
    {
        printf("%s simAddParticleObjectItem\n",couldNotFind);
        return 0;
    }
    if (simGetObjectSizeFactor==nullptr)
    {
        printf("%s simGetObjectSizeFactor\n",couldNotFind);
        return 0;
    }
    if (simAnnounceSceneContentChange==nullptr)
    {
        printf("%s simAnnounceSceneContentChange\n",couldNotFind);
        return 0;
    }
    if (simResetMilling==nullptr)
    {
        printf("%s simResetMilling\n",couldNotFind);
        return 0;
    }
    if (simApplyMilling==nullptr)
    {
        printf("%s simApplyMilling\n",couldNotFind);
        return 0;
    }
    if (simSetIntegerSignal==nullptr)
    {
        printf("%s simSetIntegerSignal\n",couldNotFind);
        return 0;
    }
    if (simGetIntegerSignal==nullptr)
    {
        printf("%s simGetIntegerSignal\n",couldNotFind);
        return 0;
    }
    if (simClearIntegerSignal==nullptr)
    {
        printf("%s simClearIntegerSignal\n",couldNotFind);
        return 0;
    }
    if (simSetFloatSignal==nullptr)
    {
        printf("%s simSetFloatSignal\n",couldNotFind);
        return 0;
    }
    if (simGetFloatSignal==nullptr)
    {
        printf("%s simGetFloatSignal\n",couldNotFind);
        return 0;
    }
    if (simClearFloatSignal==nullptr)
    {
        printf("%s simClearFloatSignal\n",couldNotFind);
        return 0;
    }
    if (simSetDoubleSignal==nullptr)
    {
        printf("%s simSetDoubleSignal\n",couldNotFind);
        return 0;
    }
    if (simGetDoubleSignal==nullptr)
    {
        printf("%s simGetDoubleSignal\n",couldNotFind);
        return 0;
    }
    if (simClearDoubleSignal==nullptr)
    {
        printf("%s simClearDoubleSignal\n",couldNotFind);
        return 0;
    }
    if (simSetStringSignal==nullptr)
    {
        printf("%s simSetStringSignal\n",couldNotFind);
        return 0;
    }
    if (simGetStringSignal==nullptr)
    {
        printf("%s simGetStringSignal\n",couldNotFind);
        return 0;
    }
    if (simClearStringSignal==nullptr)
    {
        printf("%s simClearStringSignal\n",couldNotFind);
        return 0;
    }
    if (simGetSignalName==nullptr)
    {
        printf("%s simGetSignalName\n",couldNotFind);
        return 0;
    }
    if (simSetObjectProperty==nullptr)
    {
        printf("%s simSetObjectProperty\n",couldNotFind);
        return 0;
    }
    if (simGetObjectProperty==nullptr)
    {
        printf("%s simGetObjectProperty\n",couldNotFind);
        return 0;
    }
    if (simSetObjectSpecialProperty==nullptr)
    {
        printf("%s simSetObjectSpecialProperty\n",couldNotFind);
        return 0;
    }
    if (simGetObjectSpecialProperty==nullptr)
    {
        printf("%s simGetObjectSpecialProperty\n",couldNotFind);
        return 0;
    }
    if (simGetPositionOnPath==nullptr)
    {
        printf("%s simGetPositionOnPath\n",couldNotFind);
        return 0;
    }
    if (simGetDataOnPath==nullptr)
    {
        printf("%s simGetDataOnPath\n",couldNotFind);
        return 0;
    }
    if (simGetOrientationOnPath==nullptr)
    {
        printf("%s simGetOrientationOnPath\n",couldNotFind);
        return 0;
    }
    if (simGetClosestPositionOnPath==nullptr)
    {
        printf("%s simGetClosestPositionOnPath\n",couldNotFind);
        return 0;
    }
    if (simReadForceSensor==nullptr)
    {
        printf("%s simReadForceSensor\n",couldNotFind);
        return 0;
    }
    if (simBreakForceSensor==nullptr)
    {
        printf("%s simBreakForceSensor\n",couldNotFind);
        return 0;
    }
    if (simGetShapeVertex==nullptr)
    {
        printf("%s simGetShapeVertex\n",couldNotFind);
        return 0;
    }
    if (simGetShapeTriangle==nullptr)
    {
        printf("%s simGetShapeTriangle\n",couldNotFind);
        return 0;
    }
    if (simSetLightParameters==nullptr)
    {
        printf("%s simSetLightParameters\n",couldNotFind);
        return 0;
    }
    if (simGetLightParameters==nullptr)
    {
        printf("%s simGetLightParameters\n",couldNotFind);
        return 0;
    }
    if (simGetVelocity==nullptr)
    {
        printf("%s simGetVelocity\n",couldNotFind);
        return 0;
    }
    if (simGetObjectVelocity==nullptr)
    {
        printf("%s simGetObjectVelocity\n",couldNotFind);
        return 0;
    }
    if (simAddForceAndTorque==nullptr)
    {
        printf("%s simAddForceAndTorque\n",couldNotFind);
        return 0;
    }
    if (simAddForce==nullptr)
    {
        printf("%s simAddForce\n",couldNotFind);
        return 0;
    }
    if (simSetExplicitHandling==nullptr)
    {
        printf("%s simSetExplicitHandling\n",couldNotFind);
        return 0;
    }
    if (simGetExplicitHandling==nullptr)
    {
        printf("%s simGetExplicitHandling\n",couldNotFind);
        return 0;
    }
    if (simGetLinkDummy==nullptr)
    {
        printf("%s simGetLinkDummy\n",couldNotFind);
        return 0;
    }
    if (simSetLinkDummy==nullptr)
    {
        printf("%s simSetLinkDummy\n",couldNotFind);
        return 0;
    }
    if (simSetModelProperty==nullptr)
    {
        printf("%s simSetModelProperty\n",couldNotFind);
        return 0;
    }
    if (simGetModelProperty==nullptr)
    {
        printf("%s simGetModelProperty\n",couldNotFind);
        return 0;
    }
    if (simSetShapeColor==nullptr)
    {
        printf("%s simSetShapeColor\n",couldNotFind);
        return 0;
    }
    if (simGetShapeColor==nullptr)
    {
        printf("%s simGetShapeColor\n",couldNotFind);
        return 0;
    }
    if (simResetDynamicObject==nullptr)
    {
        printf("%s simResetDynamicObject\n",couldNotFind);
        return 0;
    }
    if (simSetJointMode==nullptr)
    {
        printf("%s simSetJointMode\n",couldNotFind);
        return 0;
    }
    if (simGetJointMode==nullptr)
    {
        printf("%s simGetJointMode\n",couldNotFind);
        return 0;
    }
    if (simSerialOpen==nullptr)
    {
        printf("%s simSerialOpen\n",couldNotFind);
        return 0;
    }
    if (simSerialClose==nullptr)
    {
        printf("%s simSerialClose\n",couldNotFind);
        return 0;
    }
    if (simSerialSend==nullptr)
    {
        printf("%s simSerialSend\n",couldNotFind);
        return 0;
    }
    if (simSerialRead==nullptr)
    {
        printf("%s simSerialRead\n",couldNotFind);
        return 0;
    }
    if (simSerialCheck==nullptr)
    {
        printf("%s simSerialCheck\n",couldNotFind);
        return 0;
    }
    if (simGetContactInfo==nullptr)
    {
        printf("%s simGetContactInfo\n",couldNotFind);
        return 0;
    }
    if (simSetThreadIsFree==nullptr)
    {
        printf("%s simSetThreadIsFree\n",couldNotFind);
        return 0;
    }
    if (simTubeOpen==nullptr)
    {
        printf("%s simTubeOpen\n",couldNotFind);
        return 0;
    }
    if (simTubeClose==nullptr)
    {
        printf("%s simTubeClose\n",couldNotFind);
        return 0;
    }
    if (simTubeWrite==nullptr)
    {
        printf("%s simTubeWrite\n",couldNotFind);
        return 0;
    }
    if (simTubeRead==nullptr)
    {
        printf("%s simTubeRead\n",couldNotFind);
        return 0;
    }
    if (simTubeStatus==nullptr)
    {
        printf("%s simTubeStatus\n",couldNotFind);
        return 0;
    }
    if (simAuxiliaryConsoleOpen==nullptr)
    {
        printf("%s simAuxiliaryConsoleOpen\n",couldNotFind);
        return 0;
    }
    if (simAuxiliaryConsoleClose==nullptr)
    {
        printf("%s simAuxiliaryConsoleClose\n",couldNotFind);
        return 0;
    }
    if (simAuxiliaryConsoleShow==nullptr)
    {
        printf("%s simAuxiliaryConsoleShow\n",couldNotFind);
        return 0;
    }
    if (simAuxiliaryConsolePrint==nullptr)
    {
        printf("%s simAuxiliaryConsolePrint\n",couldNotFind);
        return 0;
    }
    if (simImportShape==nullptr)
    {
        printf("%s simImportShape\n",couldNotFind);
        return 0;
    }
    if (simImportMesh==nullptr)
    {
        printf("%s simImportMesh\n",couldNotFind);
        return 0;
    }
    if (simExportMesh==nullptr)
    {
        printf("%s simExportMesh\n",couldNotFind);
        return 0;
    }
    if (simCreateMeshShape==nullptr)
    {
        printf("%s simCreateMeshShape\n",couldNotFind);
        return 0;
    }
    if (simCreatePureShape==nullptr)
    {
        printf("%s simCreatePureShape\n",couldNotFind);
        return 0;
    }
    if (simCreateHeightfieldShape==nullptr)
    {
        printf("%s simCreateHeightfieldShape\n",couldNotFind);
        return 0;
    }
    if (simGetShapeMesh==nullptr)
    {
        printf("%s simGetShapeMesh\n",couldNotFind);
        return 0;
    }
    if (simAddBanner==nullptr)
    {
        printf("%s simAddBanner\n",couldNotFind);
        return 0;
    }
    if (simRemoveBanner==nullptr)
    {
        printf("%s simRemoveBanner\n",couldNotFind);
        return 0;
    }
    if (simCreateJoint==nullptr)
    {
        printf("%s simCreateJoint\n",couldNotFind);
        return 0;
    }
    if (simCreateDummy==nullptr)
    {
        printf("%s simCreateDummy\n",couldNotFind);
        return 0;
    }
    if (simCreateProximitySensor==nullptr)
    {
        printf("%s simCreateProximitySensor\n",couldNotFind);
        return 0;
    }
    if (simCreatePath==nullptr)
    {
        printf("%s simCreatePath\n",couldNotFind);
        return 0;
    }
    if (simInsertPathCtrlPoints==nullptr)
    {
        printf("%s simInsertPathCtrlPoints\n",couldNotFind);
        return 0;
    }
    if (simCutPathCtrlPoints==nullptr)
    {
        printf("%s simCutPathCtrlPoints\n",couldNotFind);
        return 0;
    }
    if (simCreateVisionSensor==nullptr)
    {
        printf("%s simCreateVisionSensor\n",couldNotFind);
        return 0;
    }
    if (simCreateForceSensor==nullptr)
    {
        printf("%s simCreateForceSensor\n",couldNotFind);
        return 0;
    }
    if (simGetObjectIntParameter==nullptr)
    {
        printf("%s simGetObjectIntParameter\n",couldNotFind);
        return 0;
    }
    if (simSetObjectIntParameter==nullptr)
    {
        printf("%s simSetObjectIntParameter\n",couldNotFind);
        return 0;
    }
    if (simGetObjectInt32Parameter==nullptr)
    {
        printf("%s simGetObjectInt32Parameter\n",couldNotFind);
        return 0;
    }
    if (simSetObjectInt32Parameter==nullptr)
    {
        printf("%s simSetObjectInt32Parameter\n",couldNotFind);
        return 0;
    }
    if (simGetObjectFloatParameter==nullptr)
    {
        printf("%s simGetObjectFloatParameter\n",couldNotFind);
        return 0;
    }
    if (simSetObjectFloatParameter==nullptr)
    {
        printf("%s simSetObjectFloatParameter\n",couldNotFind);
        return 0;
    }
    if (simGetObjectStringParameter==nullptr)
    {
        printf("%s simGetObjectStringParameter\n",couldNotFind);
        return 0;
    }
    if (simSetObjectStringParameter==nullptr)
    {
        printf("%s simSetObjectStringParameter\n",couldNotFind);
        return 0;
    }
    if (simSetSimulationPassesPerRenderingPass==nullptr)
    {
        printf("%s simSetSimulationPassesPerRenderingPass\n",couldNotFind);
        return 0;
    }
    if (simGetRotationAxis==nullptr)
    {
        printf("%s simGetRotationAxis\n",couldNotFind);
        return 0;
    }
    if (simRotateAroundAxis==nullptr)
    {
        printf("%s simRotateAroundAxis\n",couldNotFind);
        return 0;
    }
    if (simGetJointForce==nullptr)
    {
        printf("%s simGetJointForce\n",couldNotFind);
        return 0;
    }
    if (simGetJointMaxForce==nullptr)
    {
        printf("%s simGetJointMaxForce\n",couldNotFind);
        return 0;
    }
    if (simSetArrayParameter==nullptr)
    {
        printf("%s simSetArrayParameter\n",couldNotFind);
        return 0;
    }
    if (simGetArrayParameter==nullptr)
    {
        printf("%s simGetArrayParameter\n",couldNotFind);
        return 0;
    }
    if (simSetIkGroupProperties==nullptr)
    {
        printf("%s simSetIkGroupProperties\n",couldNotFind);
        return 0;
    }
    if (simSetIkElementProperties==nullptr)
    {
        printf("%s simSetIkElementProperties\n",couldNotFind);
        return 0;
    }
    if (simCameraFitToView==nullptr)
    {
        printf("%s simCameraFitToView\n",couldNotFind);
        return 0;
    }
    if (simPersistentDataWrite==nullptr)
    {
        printf("%s simPersistentDataWrite\n",couldNotFind);
        return 0;
    }
    if (simPersistentDataRead==nullptr)
    {
        printf("%s simPersistentDataRead\n",couldNotFind);
        return 0;
    }
    if (simIsHandleValid==nullptr)
    {
        printf("%s simIsHandleValid\n",couldNotFind);
        return 0;
    }
    if (simHandleVisionSensor==nullptr)
    {
        printf("%s simHandleVisionSensor\n",couldNotFind);
        return 0;
    }
    if (simReadVisionSensor==nullptr)
    {
        printf("%s simReadVisionSensor\n",couldNotFind);
        return 0;
    }
    if (simResetVisionSensor==nullptr)
    {
        printf("%s simResetVisionSensor\n",couldNotFind);
        return 0;
    }
    if (simCheckVisionSensor==nullptr)
    {
        printf("%s simCheckVisionSensor\n",couldNotFind);
        return 0;
    }
    if (simCheckVisionSensorEx==nullptr)
    {
        printf("%s simCheckVisionSensorEx\n",couldNotFind);
        return 0;
    }
    if (simGetVisionSensorResolution==nullptr)
    {
        printf("%s simGetVisionSensorResolution\n",couldNotFind);
        return 0;
    }
    if (simGetVisionSensorImage==nullptr)
    {
        printf("%s simGetVisionSensorImage\n",couldNotFind);
        return 0;
    }
    if (simGetVisionSensorCharImage==nullptr)
    {
        printf("%s simGetVisionSensorCharImage\n",couldNotFind);
        return 0;
    }
    if (simSetVisionSensorImage==nullptr)
    {
        printf("%s simSetVisionSensorImage\n",couldNotFind);
        return 0;
    }
    if (simSetVisionSensorCharImage==nullptr)
    {
        printf("%s simSetVisionSensorCharImage\n",couldNotFind);
        return 0;
    }
    if (simGetVisionSensorDepthBuffer==nullptr)
    {
        printf("%s simGetVisionSensorDepthBuffer\n",couldNotFind);
        return 0;
    }
    if (simGetObjectQuaternion==nullptr)
    {
        printf("%s simGetObjectQuaternion\n",couldNotFind);
        return 0;
    }
    if (simSetObjectQuaternion==nullptr)
    {
        printf("%s simSetObjectQuaternion\n",couldNotFind);
        return 0;
    }
    if (simRMLPosition==nullptr)
    {
        printf("%s simRMLPosition\n",couldNotFind);
        return 0;
    }
    if (simRMLVelocity==nullptr)
    {
        printf("%s simRMLVelocity\n",couldNotFind);
        return 0;
    }
    if (simRMLPos==nullptr)
    {
        printf("%s simRMLPos\n",couldNotFind);
        return 0;
    }
    if (simRMLVel==nullptr)
    {
        printf("%s simRMLVel\n",couldNotFind);
        return 0;
    }
    if (simRMLStep==nullptr)
    {
        printf("%s simRMLStep\n",couldNotFind);
        return 0;
    }
    if (simRMLRemove==nullptr)
    {
        printf("%s simRMLRemove\n",couldNotFind);
        return 0;
    }
    if (simBuildMatrixQ==nullptr)
    {
        printf("%s simBuildMatrixQ\n",couldNotFind);
        return 0;
    }
    if (simGetQuaternionFromMatrix==nullptr)
    {
        printf("%s simGetQuaternionFromMatrix\n",couldNotFind);
        return 0;
    }
    if (simFileDialog==nullptr)
    {
        printf("%s simFileDialog\n",couldNotFind);
        return 0;
    }
    if (simMsgBox==nullptr)
    {
        printf("%s simMsgBox\n",couldNotFind);
        return 0;
    }
    if (simSetShapeMassAndInertia==nullptr)
    {
        printf("%s simSetShapeMassAndInertia\n",couldNotFind);
        return 0;
    }
    if (simGetShapeMassAndInertia==nullptr)
    {
        printf("%s simGetShapeMassAndInertia\n",couldNotFind);
        return 0;
    }
    if (simGroupShapes==nullptr)
    {
        printf("%s simGroupShapes\n",couldNotFind);
        return 0;
    }
    if (simUngroupShape==nullptr)
    {
        printf("%s simUngroupShape\n",couldNotFind);
        return 0;
    }
    if (simConvexDecompose==nullptr)
    {
        printf("%s simConvexDecompose\n",couldNotFind);
        return 0;
    }
    if (simGetIkGroupMatrix==nullptr)
    {
        printf("%s simGetIkGroupMatrix\n",couldNotFind);
        return 0;
    }
    if (simAddGhost==nullptr)
    {
        printf("%s simAddGhost\n",couldNotFind);
        return 0;
    }
    if (simModifyGhost==nullptr)
    {
        printf("%s simModifyGhost\n",couldNotFind);
        return 0;
    }
    if (simQuitSimulator==nullptr)
    {
        printf("%s simQuitSimulator\n",couldNotFind);
        return 0;
    }
    if (simGetThreadId==nullptr)
    {
        printf("%s simGetThreadId\n",couldNotFind);
        return 0;
    }
    if (simLockResources==nullptr)
    {
        printf("%s simLockResources\n",couldNotFind);
        return 0;
    }
    if (simUnlockResources==nullptr)
    {
        printf("%s simUnlockResources\n",couldNotFind);
        return 0;
    }
    if (simEnableEventCallback==nullptr)
    {
        printf("%s simEnableEventCallback\n",couldNotFind);
        return 0;
    }
    if (simSetShapeMaterial==nullptr)
    {
        printf("%s simSetShapeMaterial\n",couldNotFind);
        return 0;
    }
    if (simGetTextureId==nullptr)
    {
        printf("%s simGetTextureId\n",couldNotFind);
        return 0;
    }
    if (simReadTexture==nullptr)
    {
        printf("%s simReadTexture\n",couldNotFind);
        return 0;
    }
    if (simWriteTexture==nullptr)
    {
        printf("%s simWriteTexture\n",couldNotFind);
        return 0;
    }
    if (simCreateTexture==nullptr)
    {
        printf("%s simCreateTexture\n",couldNotFind);
        return 0;
    }
    if (simWriteCustomDataBlock==nullptr)
    {
        printf("%s simWriteCustomDataBlock\n",couldNotFind);
        return 0;
    }
    if (simReadCustomDataBlock==nullptr)
    {
        printf("%s simReadCustomDataBlock\n",couldNotFind);
        return 0;
    }
    if (simReadCustomDataBlockTags==nullptr)
    {
        printf("%s simReadCustomDataBlockTags\n",couldNotFind);
        return 0;
    }
    if (simAddPointCloud==nullptr)
    {
        printf("%s simAddPointCloud\n",couldNotFind);
        return 0;
    }
    if (simModifyPointCloud==nullptr)
    {
        printf("%s simModifyPointCloud\n",couldNotFind);
        return 0;
    }
    if (simGetShapeGeomInfo==nullptr)
    {
        printf("%s simGetShapeGeomInfo\n",couldNotFind);
        return 0;
    }
    if (simGetObjectsInTree==nullptr)
    {
        printf("%s simGetObjectsInTree\n",couldNotFind);
        return 0;
    }
    if (simSetObjectSizeValues==nullptr)
    {
        printf("%s simSetObjectSizeValues\n",couldNotFind);
        return 0;
    }
    if (simGetObjectSizeValues==nullptr)
    {
        printf("%s simGetObjectSizeValues\n",couldNotFind);
        return 0;
    }
    if (simScaleObject==nullptr)
    {
        printf("%s simScaleObject\n",couldNotFind);
        return 0;
    }
    if (simSetShapeTexture==nullptr)
    {
        printf("%s simSetShapeTexture\n",couldNotFind);
        return 0;
    }
    if (simGetShapeTextureId==nullptr)
    {
        printf("%s simGetShapeTextureId\n",couldNotFind);
        return 0;
    }
    if (simGetCollectionObjects==nullptr)
    {
        printf("%s simGetCollectionObjects\n",couldNotFind);
        return 0;
    }
    if (simSetScriptAttribute==nullptr)
    {
        printf("%s simSetScriptAttribute\n",couldNotFind);
        return 0;
    }
    if (simGetScriptAttribute==nullptr)
    {
        printf("%s simGetScriptAttribute\n",couldNotFind);
        return 0;
    }
    if (simReorientShapeBoundingBox==nullptr)
    {
        printf("%s simReorientShapeBoundingBox\n",couldNotFind);
        return 0;
    }
    if (simSwitchThread==nullptr)
    {
        printf("%s simSwitchThread\n",couldNotFind);
        return 0;
    }
    if (simCreateIkGroup==nullptr)
    {
        printf("%s simCreateIkGroup\n",couldNotFind);
        return 0;
    }
    if (simRemoveIkGroup==nullptr)
    {
        printf("%s simRemoveIkGroup\n",couldNotFind);
        return 0;
    }
    if (simCreateIkElement==nullptr)
    {
        printf("%s simCreateIkElement\n",couldNotFind);
        return 0;
    }
    if (simCreateCollection==nullptr)
    {
        printf("%s simCreateCollection\n",couldNotFind);
        return 0;
    }
    if (simAddObjectToCollection==nullptr)
    {
        printf("%s simAddObjectToCollection\n",couldNotFind);
        return 0;
    }
    if (simSaveImage==nullptr)
    {
        printf("%s simSaveImage\n",couldNotFind);
        return 0;
    }
    if (simLoadImage==nullptr)
    {
        printf("%s simLoadImage\n",couldNotFind);
        return 0;
    }
    if (simGetScaledImage==nullptr)
    {
        printf("%s simGetScaledImage\n",couldNotFind);
        return 0;
    }
    if (simTransformImage==nullptr)
    {
        printf("%s simTransformImage\n",couldNotFind);
        return 0;
    }
    if (simGetQHull==nullptr)
    {
        printf("%s simGetQHull\n",couldNotFind);
        return 0;
    }
    if (simGetDecimatedMesh==nullptr)
    {
        printf("%s simGetDecimatedMesh\n",couldNotFind);
        return 0;
    }
    if (simExportIk==nullptr)
    {
        printf("%s simExportIk\n",couldNotFind);
        return 0;
    }
    if (simCallScriptFunctionEx==nullptr)
    {
        printf("%s simCallScriptFunctionEx\n",couldNotFind);
        return 0;
    }
    if (simComputeJacobian==nullptr)
    {
        printf("%s simComputeJacobian\n",couldNotFind);
        return 0;
    }
    if (simGetConfigForTipPose==nullptr)
    {
        printf("%s simGetConfigForTipPose\n",couldNotFind);
        return 0;
    }
    if (simGenerateIkPath==nullptr)
    {
        printf("%s simGenerateIkPath\n",couldNotFind);
        return 0;
    }
    if (simGetExtensionString==nullptr)
    {
        printf("%s simGetExtensionString\n",couldNotFind);
        return 0;
    }
    if (simComputeMassAndInertia==nullptr)
    {
        printf("%s simComputeMassAndInertia\n",couldNotFind);
        return 0;
    }
    if (simCreateStack==nullptr)
    {
        printf("%s simCreateStack\n",couldNotFind);
        return 0;
    }
    if (simReleaseStack==nullptr)
    {
        printf("%s simReleaseStack\n",couldNotFind);
        return 0;
    }
    if (simCopyStack==nullptr)
    {
        printf("%s simCopyStack\n",couldNotFind);
        return 0;
    }
    if (simPushNullOntoStack==nullptr)
    {
        printf("%s simPushNullOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushBoolOntoStack==nullptr)
    {
        printf("%s simPushBoolOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushInt32OntoStack==nullptr)
    {
        printf("%s simPushInt32OntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushFloatOntoStack==nullptr)
    {
        printf("%s simPushFloatOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushDoubleOntoStack==nullptr)
    {
        printf("%s simPushDoubleOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushStringOntoStack==nullptr)
    {
        printf("%s simPushStringOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushUInt8TableOntoStack==nullptr)
    {
        printf("%s simPushUInt8TableOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushInt32TableOntoStack==nullptr)
    {
        printf("%s simPushInt32TableOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushFloatTableOntoStack==nullptr)
    {
        printf("%s simPushFloatTableOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushDoubleTableOntoStack==nullptr)
    {
        printf("%s simPushDoubleTableOntoStack\n",couldNotFind);
        return 0;
    }
    if (simPushTableOntoStack==nullptr)
    {
        printf("%s simPushTableOntoStack\n",couldNotFind);
        return 0;
    }
    if (simInsertDataIntoStackTable==nullptr)
    {
        printf("%s simInsertDataIntoStackTable\n",couldNotFind);
        return 0;
    }
    if (simGetStackSize==nullptr)
    {
        printf("%s simGetStackSize\n",couldNotFind);
        return 0;
    }
    if (simPopStackItem==nullptr)
    {
        printf("%s simPopStackItem\n",couldNotFind);
        return 0;
    }
    if (simMoveStackItemToTop==nullptr)
    {
        printf("%s simMoveStackItemToTop\n",couldNotFind);
        return 0;
    }
    if (simIsStackValueNull==nullptr)
    {
        printf("%s simIsStackValueNull\n",couldNotFind);
        return 0;
    }
    if (simGetStackBoolValue==nullptr)
    {
        printf("%s simGetStackBoolValue\n",couldNotFind);
        return 0;
    }
    if (simGetStackInt32Value==nullptr)
    {
        printf("%s simGetStackInt32Value\n",couldNotFind);
        return 0;
    }
    if (simGetStackFloatValue==nullptr)
    {
        printf("%s simGetStackFloatValue\n",couldNotFind);
        return 0;
    }
    if (simGetStackDoubleValue==nullptr)
    {
        printf("%s simGetStackDoubleValue\n",couldNotFind);
        return 0;
    }
    if (simGetStackStringValue==nullptr)
    {
        printf("%s simGetStackStringValue\n",couldNotFind);
        return 0;
    }
    if (simGetStackTableInfo==nullptr)
    {
        printf("%s simGetStackTableInfo\n",couldNotFind);
        return 0;
    }
    if (simGetStackUInt8Table==nullptr)
    {
        printf("%s simGetStackUInt8Table\n",couldNotFind);
        return 0;
    }
    if (simGetStackInt32Table==nullptr)
    {
        printf("%s simGetStackInt32Table\n",couldNotFind);
        return 0;
    }
    if (simGetStackFloatTable==nullptr)
    {
        printf("%s simGetStackFloatTable\n",couldNotFind);
        return 0;
    }
    if (simGetStackDoubleTable==nullptr)
    {
        printf("%s simGetStackDoubleTable\n",couldNotFind);
        return 0;
    }
    if (simUnfoldStackTable==nullptr)
    {
        printf("%s simUnfoldStackTable\n",couldNotFind);
        return 0;
    }
    if (simDebugStack==nullptr)
    {
        printf("%s simDebugStack\n",couldNotFind);
        return 0;
    }
    if (simSetScriptVariable==nullptr)
    {
        printf("%s simSetScriptVariable\n",couldNotFind);
        return 0;
    }
    if (simGetEngineFloatParameter==nullptr)
    {
        printf("%s simGetEngineFloatParameter\n",couldNotFind);
        return 0;
    }
    if (simGetEngineInt32Parameter==nullptr)
    {
        printf("%s simGetEngineInt32Parameter\n",couldNotFind);
        return 0;
    }
    if (simGetEngineBoolParameter==nullptr)
    {
        printf("%s simGetEngineBoolParameter\n",couldNotFind);
        return 0;
    }
    if (simSetEngineFloatParameter==nullptr)
    {
        printf("%s simSetEngineFloatParameter\n",couldNotFind);
        return 0;
    }
    if (simSetEngineInt32Parameter==nullptr)
    {
        printf("%s simSetEngineInt32Parameter\n",couldNotFind);
        return 0;
    }
    if (simSetEngineBoolParameter==nullptr)
    {
        printf("%s simSetEngineBoolParameter\n",couldNotFind);
        return 0;
    }
    if (simCreateOctree==nullptr)
    {
        printf("%s simCreateOctree\n",couldNotFind);
        return 0;
    }
    if (simCreatePointCloud==nullptr)
    {
        printf("%s simCreatePointCloud\n",couldNotFind);
        return 0;
    }
    if (simSetPointCloudOptions==nullptr)
    {
        printf("%s simSetPointCloudOptions\n",couldNotFind);
        return 0;
    }
    if (simGetPointCloudOptions==nullptr)
    {
        printf("%s simGetPointCloudOptions\n",couldNotFind);
        return 0;
    }
    if (simInsertVoxelsIntoOctree==nullptr)
    {
        printf("%s simInsertVoxelsIntoOctree\n",couldNotFind);
        return 0;
    }
    if (simRemoveVoxelsFromOctree==nullptr)
    {
        printf("%s simRemoveVoxelsFromOctree\n",couldNotFind);
        return 0;
    }
    if (simInsertPointsIntoPointCloud==nullptr)
    {
        printf("%s simInsertPointsIntoPointCloud\n",couldNotFind);
        return 0;
    }
    if (simRemovePointsFromPointCloud==nullptr)
    {
        printf("%s simRemovePointsFromPointCloud\n",couldNotFind);
        return 0;
    }
    if (simIntersectPointsWithPointCloud==nullptr)
    {
        printf("%s simIntersectPointsWithPointCloud\n",couldNotFind);
        return 0;
    }
    if (simGetOctreeVoxels==nullptr)
    {
        printf("%s simGetOctreeVoxels\n",couldNotFind);
        return 0;
    }
    if (simGetPointCloudPoints==nullptr)
    {
        printf("%s simGetPointCloudPoints\n",couldNotFind);
        return 0;
    }
    if (simInsertObjectIntoOctree==nullptr)
    {
        printf("%s simInsertObjectIntoOctree\n",couldNotFind);
        return 0;
    }
    if (simSubtractObjectFromOctree==nullptr)
    {
        printf("%s simSubtractObjectFromOctree\n",couldNotFind);
        return 0;
    }
    if (simInsertObjectIntoPointCloud==nullptr)
    {
        printf("%s simInsertObjectIntoPointCloud\n",couldNotFind);
        return 0;
    }
    if (simSubtractObjectFromPointCloud==nullptr)
    {
        printf("%s simSubtractObjectFromPointCloud\n",couldNotFind);
        return 0;
    }
    if (simCheckOctreePointOccupancy==nullptr)
    {
        printf("%s simCheckOctreePointOccupancy\n",couldNotFind);
        return 0;
    }
    if (simOpenTextEditor==nullptr)
    {
        printf("%s simOpenTextEditor\n",couldNotFind);
        return 0;
    }
    if (simPackTable==nullptr)
    {
        printf("%s simPackTable\n",couldNotFind);
        return 0;
    }
    if (simUnpackTable==nullptr)
    {
        printf("%s simUnpackTable\n",couldNotFind);
        return 0;
    }
    if (simSetReferencedHandles==nullptr)
    {
        printf("%s simSetReferencedHandles\n",couldNotFind);
        return 0;
    }
    if (simGetReferencedHandles==nullptr)
    {
        printf("%s simGetReferencedHandles\n",couldNotFind);
        return 0;
    }
    if (simGetShapeViz==nullptr)
    {
        printf("%s simGetShapeViz\n",couldNotFind);
        return 0;
    }
    if (simExecuteScriptString==nullptr)
    {
        printf("%s simExecuteScriptString\n",couldNotFind);
        return 0;
    }
    if (simGetApiFunc==nullptr)
    {
        printf("%s simGetApiFunc\n",couldNotFind);
        return 0;
    }
    if (simGetApiInfo==nullptr)
    {
        printf("%s simGetApiInfo\n",couldNotFind);
        return 0;
    }
    if (simSetModuleInfo==nullptr)
    {
        printf("%s simSetModuleInfo\n",couldNotFind);
        return 0;
    }
    if (simGetModuleInfo==nullptr)
    {
        printf("%s simGetModuleInfo\n",couldNotFind);
        return 0;
    }
    if (simIsDeprecated==nullptr)
    {
        printf("%s simIsDeprecated\n",couldNotFind);
        return 0;
    }
    if (simGetPersistentDataTags==nullptr)
    {
        printf("%s simGetPersistentDataTags\n",couldNotFind);
        return 0;
    }
    if (simEventNotification==nullptr)
    {
        printf("%s simEventNotification\n",couldNotFind);
        return 0;
    }
    if (simApplyTexture==nullptr)
    {
        printf("%s simApplyTexture\n",couldNotFind);
        return 0;
    }
    if (simSetJointDependency==nullptr)
    {
        printf("%s simSetJointDependency\n",couldNotFind);
        return 0;
    }
    if (simSetStringNamedParam==nullptr)
    {
        printf("%s simSetStringNamedParam\n",couldNotFind);
        return 0;
    }
    if (simGetStringNamedParam==nullptr)
    {
        printf("%s simGetStringNamedParam\n",couldNotFind);
        return 0;
    }
    if (simGetUserParameter==nullptr)
    {
        printf("%s simGetUserParameter\n",couldNotFind);
        return 0;
    }
    if (simSetUserParameter==nullptr)
    {
        printf("%s simSetUserParameter\n",couldNotFind);
        return 0;
    }


    // Following courtesy of Stephen James:
    if (simExtLaunchUIThread==nullptr)
    {
        printf("%s simExtLaunchUIThread\n",couldNotFind);
        return 0;
    }
    if (simExtCanInitSimThread==nullptr)
    {
        printf("%s simExtCanInitSimThread\n",couldNotFind);
        return 0;
    }
    if (simExtSimThreadInit==nullptr)
    {
        printf("%s simExtSimThreadInit\n",couldNotFind);
        return 0;
    }
    if (simExtSimThreadDestroy==nullptr)
    {
        printf("%s simExtSimThreadDestroy\n",couldNotFind);
        return 0;
    }
    if (simExtPostExitRequest==nullptr)
    {
        printf("%s simExtPostExitRequest\n",couldNotFind);
        return 0;
    }
    if (simExtGetExitRequest==nullptr)
    {
        printf("%s simExtGetExitRequest\n",couldNotFind);
        return 0;
    }
    if (simExtStep==nullptr)
    {
        printf("%s simExtStep\n",couldNotFind);
        return 0;
    }
    if (simExtCallScriptFunction==nullptr)
    {
        printf("%s simExtCallScriptFunction\n",couldNotFind);
        return 0;
    }


    if (_simGetContactCallbackCount==nullptr)
    {
        printf("%s _simGetContactCallbackCount\n",couldNotFind);
        return 0;
    }
    if (_simGetContactCallback==nullptr)
    {
        printf("%s _simGetContactCallback\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicSimulationIconCode==nullptr)
    {
        printf("%s _simSetDynamicSimulationIconCode\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicObjectFlagForVisualization==nullptr)
    {
        printf("%s _simSetDynamicObjectFlagForVisualization\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectListSize==nullptr)
    {
        printf("%s _simGetObjectListSize\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectFromIndex==nullptr)
    {
        printf("%s _simGetObjectFromIndex\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectID==nullptr)
    {
        printf("%s _simGetObjectID\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectType==nullptr)
    {
        printf("%s _simGetObjectType\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectChildren==nullptr)
    {
        printf("%s _simGetObjectChildren\n",couldNotFind);
        return 0;
    }
    if (_simGetGeomProxyFromShape==nullptr)
    {
        printf("%s _simGetGeomProxyFromShape\n",couldNotFind);
        return 0;
    }
    if (_simGetParentObject==nullptr)
    {
        printf("%s _simGetParentObject\n",couldNotFind);
        return 0;
    }
    if (_simGetObject==nullptr)
    {
        printf("%s _simGetObject\n",couldNotFind);
        return 0;
    }
    if (_simGetIkGroupObject==nullptr)
    {
        printf("%s _simGetIkGroupObject\n",couldNotFind);
        return 0;
    }
    if (_simMpHandleIkGroupObject==nullptr)
    {
        printf("%s _simMpHandleIkGroupObject\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectLocalTransformation==nullptr)
    {
        printf("%s _simGetObjectLocalTransformation\n",couldNotFind);
        return 0;
    }
    if (_simSetObjectLocalTransformation==nullptr)
    {
        printf("%s _simSetObjectLocalTransformation\n",couldNotFind);
        return 0;
    }
    if (_simSetObjectCumulativeTransformation==nullptr)
    {
        printf("%s _simSetObjectCumulativeTransformation\n",couldNotFind);
        return 0;
    }
    if (_simGetObjectCumulativeTransformation==nullptr)
    {
        printf("%s _simGetObjectCumulativeTransformation\n",couldNotFind);
        return 0;
    }
    if (_simIsShapeDynamicallyStatic==nullptr)
    {
        printf("%s _simIsShapeDynamicallyStatic\n",couldNotFind);
        return 0;
    }
    if (_simGetTreeDynamicProperty==nullptr)
    {
        printf("%s _simGetTreeDynamicProperty\n",couldNotFind);
        return 0;
    }
    if (_simGetDummyLinkType==nullptr)
    {
        printf("%s _simGetDummyLinkType\n",couldNotFind);
        return 0;
    }
    if (_simGetJointMode==nullptr)
    {
        printf("%s _simGetJointMode\n",couldNotFind);
        return 0;
    }
    if (_simIsJointInHybridOperation==nullptr)
    {
        printf("%s _simIsJointInHybridOperation\n",couldNotFind);
        return 0;
    }
    if (_simDisableDynamicTreeForManipulation==nullptr)
    {
        printf("%s _simDisableDynamicTreeForManipulation\n",couldNotFind);
        return 0;
    }
    if (_simIsShapeDynamicallyRespondable==nullptr)
    {
        printf("%s _simIsShapeDynamicallyRespondable\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicCollisionMask==nullptr)
    {
        printf("%s _simGetDynamicCollisionMask\n",couldNotFind);
        return 0;
    }
    if (_simGetLastParentForLocalGlobalCollidable==nullptr)
    {
        printf("%s _simGetLastParentForLocalGlobalCollidable\n",couldNotFind);
        return 0;
    }
    if (_simSetShapeIsStaticAndNotRespondableButDynamicTag==nullptr)
    {
        printf("%s _simSetShapeIsStaticAndNotRespondableButDynamicTag\n",couldNotFind);
        return 0;
    }
    if (_simGetShapeIsStaticAndNotRespondableButDynamicTag==nullptr)
    {
        printf("%s _simGetShapeIsStaticAndNotRespondableButDynamicTag\n",couldNotFind);
        return 0;
    }
    if (_simSetJointPosition==nullptr)
    {
        printf("%s _simSetJointPosition\n",couldNotFind);
        return 0;
    }
    if (_simGetJointPosition==nullptr)
    {
        printf("%s _simGetJointPosition\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicMotorPositionControlTargetPosition==nullptr)
    {
        printf("%s _simSetDynamicMotorPositionControlTargetPosition\n",couldNotFind);
        return 0;
    }
    if (_simGetInitialDynamicVelocity==nullptr)
    {
        printf("%s _simGetInitialDynamicVelocity\n",couldNotFind);
        return 0;
    }
    if (_simSetInitialDynamicVelocity==nullptr)
    {
        printf("%s _simSetInitialDynamicVelocity\n",couldNotFind);
        return 0;
    }
    if (_simGetInitialDynamicAngVelocity==nullptr)
    {
        printf("%s _simGetInitialDynamicAngVelocity\n",couldNotFind);
        return 0;
    }
    if (_simSetInitialDynamicAngVelocity==nullptr)
    {
        printf("%s _simSetInitialDynamicAngVelocity\n",couldNotFind);
        return 0;
    }
    if (_simGetStartSleeping==nullptr)
    {
        printf("%s _simGetStartSleeping\n",couldNotFind);
        return 0;
    }
    if (_simGetWasPutToSleepOnce==nullptr)
    {
        printf("%s _simGetWasPutToSleepOnce\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicsFullRefreshFlag==nullptr)
    {
        printf("%s _simGetDynamicsFullRefreshFlag\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicsFullRefreshFlag==nullptr)
    {
        printf("%s _simSetDynamicsFullRefreshFlag\n",couldNotFind);
        return 0;
    }
    if (_simSetGeomProxyDynamicsFullRefreshFlag==nullptr)
    {
        printf("%s _simSetGeomProxyDynamicsFullRefreshFlag\n",couldNotFind);
        return 0;
    }
    if (_simGetGeomProxyDynamicsFullRefreshFlag==nullptr)
    {
        printf("%s _simGetGeomProxyDynamicsFullRefreshFlag\n",couldNotFind);
        return 0;
    }
    if (_simGetParentFollowsDynamic==nullptr)
    {
        printf("%s _simGetParentFollowsDynamic\n",couldNotFind);
        return 0;
    }
    if (_simSetShapeDynamicVelocity==nullptr)
    {
        printf("%s _simSetShapeDynamicVelocity\n",couldNotFind);
        return 0;
    }
    if (_simGetAdditionalForceAndTorque==nullptr)
    {
        printf("%s _simGetAdditionalForceAndTorque\n",couldNotFind);
        return 0;
    }
    if (_simClearAdditionalForceAndTorque==nullptr)
    {
        printf("%s _simClearAdditionalForceAndTorque\n",couldNotFind);
        return 0;
    }
    if (_simGetJointPositionInterval==nullptr)
    {
        printf("%s _simGetJointPositionInterval\n",couldNotFind);
        return 0;
    }
    if (_simGetJointType==nullptr)
    {
        printf("%s _simGetJointType\n",couldNotFind);
        return 0;
    }
    if (_simIsForceSensorBroken==nullptr)
    {
        printf("%s _simIsForceSensorBroken\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicForceSensorLocalTransformationPart2==nullptr)
    {
        printf("%s _simGetDynamicForceSensorLocalTransformationPart2\n",couldNotFind);
        return 0;
    }
    if (_simIsDynamicMotorEnabled==nullptr)
    {
        printf("%s _simIsDynamicMotorEnabled\n",couldNotFind);
        return 0;
    }
    if (_simIsDynamicMotorPositionCtrlEnabled==nullptr)
    {
        printf("%s _simIsDynamicMotorPositionCtrlEnabled\n",couldNotFind);
        return 0;
    }
    if (_simIsDynamicMotorTorqueModulationEnabled==nullptr)
    {
        printf("%s _simIsDynamicMotorTorqueModulationEnabled\n",couldNotFind);
        return 0;
    }
    if (_simGetMotorPid==nullptr)
    {
        printf("%s _simGetMotorPid\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicMotorTargetPosition==nullptr)
    {
        printf("%s _simGetDynamicMotorTargetPosition\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicMotorTargetVelocity==nullptr)
    {
        printf("%s _simGetDynamicMotorTargetVelocity\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicMotorMaxForce==nullptr)
    {
        printf("%s _simGetDynamicMotorMaxForce\n",couldNotFind);
        return 0;
    }
    if (_simGetDynamicMotorUpperLimitVelocity==nullptr)
    {
        printf("%s _simGetDynamicMotorUpperLimitVelocity\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicMotorReflectedPositionFromDynamicEngine==nullptr)
    {
        printf("%s _simSetDynamicMotorReflectedPositionFromDynamicEngine\n",couldNotFind);
        return 0;
    }
    if (_simSetJointSphericalTransformation==nullptr)
    {
        printf("%s _simSetJointSphericalTransformation\n",couldNotFind);
        return 0;
    }
    if (_simAddForceSensorCumulativeForcesAndTorques==nullptr)
    {
        printf("%s _simAddForceSensorCumulativeForcesAndTorques\n",couldNotFind);
        return 0;
    }
    if (_simAddJointCumulativeForcesOrTorques==nullptr)
    {
        printf("%s _simAddJointCumulativeForcesOrTorques\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicJointLocalTransformationPart2==nullptr)
    {
        printf("%s _simSetDynamicJointLocalTransformationPart2\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicForceSensorLocalTransformationPart2==nullptr)
    {
        printf("%s _simSetDynamicForceSensorLocalTransformationPart2\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicJointLocalTransformationPart2IsValid==nullptr)
    {
        printf("%s _simSetDynamicJointLocalTransformationPart2IsValid\n",couldNotFind);
        return 0;
    }
    if (_simSetDynamicForceSensorLocalTransformationPart2IsValid==nullptr)
    {
        printf("%s _simSetDynamicForceSensorLocalTransformationPart2IsValid\n",couldNotFind);
        return 0;
    }
    if (_simGetGeomWrapFromGeomProxy==nullptr)
    {
        printf("%s _simGetGeomWrapFromGeomProxy\n",couldNotFind);
        return 0;
    }
    if (_simGetLocalInertiaFrame==nullptr)
    {
        printf("%s _simGetLocalInertiaFrame\n",couldNotFind);
        return 0;
    }
    if (_simGetPurePrimitiveType==nullptr)
    {
        printf("%s _simGetPurePrimitiveType\n",couldNotFind);
        return 0;
    }
    if (_simIsGeomWrapGeometric==nullptr)
    {
        printf("%s _simIsGeomWrapGeometric\n",couldNotFind);
        return 0;
    }
    if (_simIsGeomWrapConvex==nullptr)
    {
        printf("%s _simIsGeomWrapConvex\n",couldNotFind);
        return 0;
    }
    if (_simGetGeometricCount==nullptr)
    {
        printf("%s _simGetGeometricCount\n",couldNotFind);
        return 0;
    }
    if (_simGetAllGeometrics==nullptr)
    {
        printf("%s _simGetAllGeometrics\n",couldNotFind);
        return 0;
    }
    if (_simGetPurePrimitiveSizes==nullptr)
    {
        printf("%s _simGetPurePrimitiveSizes\n",couldNotFind);
        return 0;
    }
    if (_simMakeDynamicAnnouncement==nullptr)
    {
        printf("%s _simMakeDynamicAnnouncement\n",couldNotFind);
        return 0;
    }
    if (_simGetVerticesLocalFrame==nullptr)
    {
        printf("%s _simGetVerticesLocalFrame\n",couldNotFind);
        return 0;
    }
    if (_simGetHeightfieldData==nullptr)
    {
        printf("%s _simGetHeightfieldData\n",couldNotFind);
        return 0;
    }
    if (_simGetCumulativeMeshes==nullptr)
    {
        printf("%s _simGetCumulativeMeshes\n",couldNotFind);
        return 0;
    }
    if (_simGetMass==nullptr)
    {
        printf("%s _simGetMass\n",couldNotFind);
        return 0;
    }
    if (_simGetPrincipalMomentOfInertia==nullptr)
    {
        printf("%s _simGetPrincipalMomentOfInertia\n",couldNotFind);
        return 0;
    }
    if (_simGetGravity==nullptr)
    {
        printf("%s _simGetGravity\n",couldNotFind);
        return 0;
    }
    if (_simGetTimeDiffInMs==nullptr)
    {
        printf("%s _simGetTimeDiffInMs\n",couldNotFind);
        return 0;
    }
    if (_simDoEntitiesCollide==nullptr)
    {
        printf("%s _simDoEntitiesCollide\n",couldNotFind);
        return 0;
    }
    if (_simGetDistanceBetweenEntitiesIfSmaller==nullptr)
    {
        printf("%s _simGetDistanceBetweenEntitiesIfSmaller\n",couldNotFind);
        return 0;
    }
    if (_simHandleJointControl==nullptr)
    {
        printf("%s _simHandleJointControl\n",couldNotFind);
        return 0;
    }
    if (_simHandleCustomContact==nullptr)
    {
        printf("%s _simHandleCustomContact\n",couldNotFind);
        return 0;
    }
    if (_simGetPureHollowScaling==nullptr)
    {
        printf("%s _simGetPureHollowScaling\n",couldNotFind);
        return 0;
    }
    if (_simGetJointCallbackCallOrder==nullptr)
    {
        printf("%s _simGetJointCallbackCallOrder\n",couldNotFind);
        return 0;
    }
    if (_simDynCallback==nullptr)
    {
        printf("%s _simDynCallback\n",couldNotFind);
        return 0;
    }




    // Deprecated begin
    if (simGetMaterialId==nullptr)
    {
        printf("%s simGetMaterialId\n",couldNotFind);
        return 0;
    }
    if (simGetShapeMaterial==nullptr)
    {
        printf("%s simGetShapeMaterial\n",couldNotFind);
        return 0;
    }
    if (simHandleVarious==nullptr)
    {
        printf("%s simHandleVarious\n",couldNotFind);
        return 0;
    }
    if (simSerialPortOpen==nullptr)
    {
        printf("%s simSerialPortOpen\n",couldNotFind);
        return 0;
    }
    if (simSerialPortClose==nullptr)
    {
        printf("%s simSerialPortClose\n",couldNotFind);
        return 0;
    }
    if (simSerialPortSend==nullptr)
    {
        printf("%s simSerialPortSend\n",couldNotFind);
        return 0;
    }
    if (simSerialPortRead==nullptr)
    {
        printf("%s simSerialPortRead\n",couldNotFind);
        return 0;
    }
    if (simJointGetForce==nullptr)
    {
        printf("%s simJointGetForce\n",couldNotFind);
        return 0;
    }
    if (simGetPathPlanningHandle==nullptr)
    {
        printf("%s simGetPathPlanningHandle\n",couldNotFind);
        return 0;
    }
    if (simGetMotionPlanningHandle==nullptr)
    {
        printf("%s simGetMotionPlanningHandle\n",couldNotFind);
        return 0;
    }
    if (simGetMpConfigForTipPose==nullptr)
    {
        printf("%s simGetMpConfigForTipPose\n",couldNotFind);
        return 0;
    }
    if (simFindMpPath==nullptr)
    {
        printf("%s simFindMpPath\n",couldNotFind);
        return 0;
    }
    if (simSimplifyMpPath==nullptr)
    {
        printf("%s simSimplifyMpPath\n",couldNotFind);
        return 0;
    }
    if (simGetMpConfigTransition==nullptr)
    {
        printf("%s simGetMpConfigTransition\n",couldNotFind);
        return 0;
    }
    if (simFindIkPath==nullptr)
    {
        printf("%s simFindIkPath\n",couldNotFind);
        return 0;
    }
    if (simCreateMotionPlanning==nullptr)
    {
        printf("%s simCreateMotionPlanning\n",couldNotFind);
        return 0;
    }
    if (simRemoveMotionPlanning==nullptr)
    {
        printf("%s simRemoveMotionPlanning\n",couldNotFind);
        return 0;
    }
    if (simSearchPath==nullptr)
    {
        printf("%s simSearchPath\n",couldNotFind);
        return 0;
    }
    if (simInitializePathSearch==nullptr)
    {
        printf("%s simInitializePathSearch\n",couldNotFind);
        return 0;
    }
    if (simPerformPathSearchStep==nullptr)
    {
        printf("%s simPerformPathSearchStep\n",couldNotFind);
        return 0;
    }
    if (simLockInterface==nullptr)
    {
        printf("%s simLockInterface\n",couldNotFind);
        return 0;
    }
    if (simCopyPasteSelectedObjects==nullptr)
    {
        printf("%s simCopyPasteSelectedObjects\n",couldNotFind);
        return 0;
    }
    if (simResetPath==nullptr)
    {
        printf("%s simResetPath\n",couldNotFind);
        return 0;
    }
    if (simHandlePath==nullptr)
    {
        printf("%s simHandlePath\n",couldNotFind);
        return 0;
    }
    if (simResetJoint==nullptr)
    {
        printf("%s simResetJoint\n",couldNotFind);
        return 0;
    }
    if (simHandleJoint==nullptr)
    {
        printf("%s simHandleJoint\n",couldNotFind);
        return 0;
    }
    if (simAppendScriptArrayEntry==nullptr)
    {
        printf("%s simAppendScriptArrayEntry\n",couldNotFind);
        return 0;
    }
    if (simClearScriptVariable==nullptr)
    {
        printf("%s simClearScriptVariable\n",couldNotFind);
        return 0;
    }
    if (_simGetJointOdeParameters==nullptr)
    {
        printf("%s _simGetJointOdeParameters\n",couldNotFind);
        return 0;
    }
    if (_simGetJointBulletParameters==nullptr)
    {
        printf("%s _simGetJointBulletParameters\n",couldNotFind);
        return 0;
    }
    if (_simGetOdeMaxContactFrictionCFMandERP==nullptr)
    {
        printf("%s _simGetOdeMaxContactFrictionCFMandERP\n",couldNotFind);
        return 0;
    }
    if (_simGetBulletCollisionMargin==nullptr)
    {
        printf("%s _simGetBulletCollisionMargin\n",couldNotFind);
        return 0;
    }
    if (_simGetBulletStickyContact==nullptr)
    {
        printf("%s _simGetBulletStickyContact\n",couldNotFind);
        return 0;
    }
    if (_simGetBulletRestitution==nullptr)
    {
        printf("%s _simGetBulletRestitution\n",couldNotFind);
        return 0;
    }
    if (_simGetVortexParameters==nullptr)
    {
        printf("%s _simGetVortexParameters\n",couldNotFind);
        return 0;
    }
    if (_simGetNewtonParameters==nullptr)
    {
        printf("%s _simGetNewtonParameters\n",couldNotFind);
        return 0;
    }
    if (_simGetDamping==nullptr)
    {
        printf("%s _simGetDamping\n",couldNotFind);
        return 0;
    }
    if (_simGetFriction==nullptr)
    {
        printf("%s _simGetFriction\n",couldNotFind);
        return 0;
    }
    if (simAddSceneCustomData==nullptr)
    {
        printf("%s simAddSceneCustomData\n",couldNotFind);
        return 0;
    }
    if (simGetSceneCustomDataLength==nullptr)
    {
        printf("%s simGetSceneCustomDataLength\n",couldNotFind);
        return 0;
    }
    if (simGetSceneCustomData==nullptr)
    {
        printf("%s simGetSceneCustomData\n",couldNotFind);
        return 0;
    }
    if (simAddObjectCustomData==nullptr)
    {
        printf("%s simAddObjectCustomData\n",couldNotFind);
        return 0;
    }
    if (simGetObjectCustomDataLength==nullptr)
    {
        printf("%s simGetObjectCustomDataLength\n",couldNotFind);
        return 0;
    }
    if (simGetObjectCustomData==nullptr)
    {
        printf("%s simGetObjectCustomData\n",couldNotFind);
        return 0;
    }
    if (simCreateUI==nullptr)
    {
        printf("%s simCreateUI\n",couldNotFind);
        return 0;
    }
    if (simCreateUIButton==nullptr)
    {
        printf("%s simCreateUIButton\n",couldNotFind);
        return 0;
    }
    if (simGetUIHandle==nullptr)
    {
        printf("%s simGetUIHandle\n",couldNotFind);
        return 0;
    }
    if (simGetUIProperty==nullptr)
    {
        printf("%s simGetUIProperty\n",couldNotFind);
        return 0;
    }
    if (simGetUIEventButton==nullptr)
    {
        printf("%s simGetUIEventButton\n",couldNotFind);
        return 0;
    }
    if (simSetUIProperty==nullptr)
    {
        printf("%s simSetUIProperty\n",couldNotFind);
        return 0;
    }
    if (simGetUIButtonProperty==nullptr)
    {
        printf("%s simGetUIButtonProperty\n",couldNotFind);
        return 0;
    }
    if (simSetUIButtonProperty==nullptr)
    {
        printf("%s simSetUIButtonProperty\n",couldNotFind);
        return 0;
    }
    if (simGetUIButtonSize==nullptr)
    {
        printf("%s simGetUIButtonSize\n",couldNotFind);
        return 0;
    }
    if (simSetUIButtonLabel==nullptr)
    {
        printf("%s simSetUIButtonLabel\n",couldNotFind);
        return 0;
    }
    if (simGetUIButtonLabel==nullptr)
    {
        printf("%s simGetUIButtonLabel\n",couldNotFind);
        return 0;
    }
    if (simSetUISlider==nullptr)
    {
        printf("%s simSetUISlider\n",couldNotFind);
        return 0;
    }
    if (simGetUISlider==nullptr)
    {
        printf("%s simGetUISlider\n",couldNotFind);
        return 0;
    }
    if (simSetUIButtonColor==nullptr)
    {
        printf("%s simSetUIButtonColor\n",couldNotFind);
        return 0;
    }
    if (simSetUIButtonTexture==nullptr)
    {
        printf("%s simSetUIButtonTexture\n",couldNotFind);
        return 0;
    }
    if (simCreateUIButtonArray==nullptr)
    {
        printf("%s simCreateUIButtonArray\n",couldNotFind);
        return 0;
    }
    if (simSetUIButtonArrayColor==nullptr)
    {
        printf("%s simSetUIButtonArrayColor\n",couldNotFind);
        return 0;
    }
    if (simDeleteUIButtonArray==nullptr)
    {
        printf("%s simDeleteUIButtonArray\n",couldNotFind);
        return 0;
    }
    if (simRemoveUI==nullptr)
    {
        printf("%s simRemoveUI\n",couldNotFind);
        return 0;
    }
    if (simSetUIPosition==nullptr)
    {
        printf("%s simSetUIPosition\n",couldNotFind);
        return 0;
    }
    if (simGetUIPosition==nullptr)
    {
        printf("%s simGetUIPosition\n",couldNotFind);
        return 0;
    }
    if (simLoadUI==nullptr)
    {
        printf("%s simLoadUI\n",couldNotFind);
        return 0;
    }
    if (simSaveUI==nullptr)
    {
        printf("%s simSaveUI\n",couldNotFind);
        return 0;
    }
    if (simHandleGeneralCallbackScript==nullptr)
    {
        printf("%s simHandleGeneralCallbackScript\n",couldNotFind);
        return 0;
    }
    if (simRegisterCustomLuaFunction==nullptr)
    {
        printf("%s simRegisterCustomLuaFunction\n",couldNotFind);
        return 0;
    }
    if (simRegisterCustomLuaVariable==nullptr)
    {
        printf("%s simRegisterCustomLuaVariable\n",couldNotFind);
        return 0;
    }
    if (simRegisterContactCallback==nullptr)
    {
        printf("%s simRegisterContactCallback\n",couldNotFind);
        return 0;
    }
    if (simGetMechanismHandle==nullptr)
    {
        printf("%s simGetMechanismHandle\n",couldNotFind);
        return 0;
    }
    if (simHandleMechanism==nullptr)
    {
        printf("%s simHandleMechanism\n",couldNotFind);
        return 0;
    }
    if (simHandleCustomizationScripts==nullptr)
    {
        printf("%s simHandleCustomizationScripts\n",couldNotFind);
        return 0;
    }
    if (simCallScriptFunction==nullptr)
    {
        printf("%s simCallScriptFunction\n",couldNotFind);
        return 0;
    }
    if (simSetVisionSensorFilter==nullptr)
    {
        printf("%s simSetVisionSensorFilter\n",couldNotFind);
        return 0;
    }
    if (simGetVisionSensorFilter==nullptr)
    {
        printf("%s simGetVisionSensorFilter\n",couldNotFind);
        return 0;
    }
    if (simGetScriptSimulationParameter==nullptr)
    {
        printf("%s simGetScriptSimulationParameter\n",couldNotFind);
        return 0;
    }
    if (simSetScriptSimulationParameter==nullptr)
    {
        printf("%s simSetScriptSimulationParameter\n",couldNotFind);
        return 0;
    }
    if (simSetJointForce==nullptr)
    {
        printf("%s simSetJointForce\n",couldNotFind);
        return 0;
    }
    // Deprecated end

    return 1;
}

#endif // SIM_LIBRARY
</t>
<t tx="leo.20220407205631.97">@path ./v-rep_plugin/coppelia/common/
#include "socketInConnection.h"
#define HEADER_LENGTH 6 // byte1=id1, byte2=id2, byte3+byte4=packetSize, byte5+byte6=packetsLeftToRead

CSocketInConnection::CSocketInConnection(int theConnectionPort,unsigned short maxPacketSize/*=250*/,char headerID1/*=59*/,char headerID2/*=57*/)
{
    _socketConnectionPort=theConnectionPort;
    _socketConnectWasOk=false;
    _headerByte1=headerID1;
    _headerByte2=headerID2;
    _maxPacketSize=maxPacketSize;

    memset(&amp;_socketLocal,0,sizeof(struct sockaddr_in));
#if defined (__linux) || defined (__APPLE__)
    _socketServer=-1;
    _socketClient=-1;
#endif /* __linux || __APPLE__ */
}

CSocketInConnection::~CSocketInConnection()
{
    if (_socketConnectWasOk)
    {
#ifdef _WIN32
        shutdown(_socketClient,SD_BOTH);
        closesocket(_socketServer);
        WSACleanup();
#elif defined (__linux) || defined (__APPLE__)
        if (_socketServer!=-1)
        {
            close(_socketServer);
        }
        if (_socketClient!=-1)
        {
            close(_socketClient);
        }
#endif
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205631.98">bool CSocketInConnection::connectToClient()
{
#ifdef _WIN32
    // 1. connect to port:
    if (WSAStartup(0x101,&amp;_socketWsaData)!=0)
        return(false);   // WSAStartup failed.
#endif /* _WIN32 */

    _socketLocal.sin_family=AF_INET;
    _socketLocal.sin_addr.s_addr=INADDR_ANY;
    _socketLocal.sin_port=htons((u_short)_socketConnectionPort);
    _socketServer=socket(AF_INET,SOCK_STREAM,0);
    if (_socketServer==INVALID_SOCKET)
        return(false); // socket failed.

    if (bind(_socketServer,(struct sockaddr*)&amp;_socketLocal,sizeof(_socketLocal))!=0)
        return(false); // bind failed.

    if (listen(_socketServer,10)!=0)
        return(false); // listen failed.

    // 2. accept client:
    struct sockaddr_in from;
    int fromlen=sizeof(from);

    _socketClient=accept(_socketServer,(struct sockaddr*) &amp;from, (_socklen *) &amp;fromlen);
    _socketConnectedMachineIP=inet_ntoa(from.sin_addr);
    FD_ZERO(&amp;_socketTheSet);
    FD_SET(_socketClient,&amp;_socketTheSet);
    _socketConnectWasOk=true;
    return(true);
}

</t>
<t tx="leo.20220407205631.99">char* CSocketInConnection::receiveData(int&amp; dataSize)
{ // Returns the data size if &gt;0, 0=we had a read time out, -1=we have an error
    if (!_socketConnectWasOk)
    {
        dataSize=-1; // error
        return(NULL);
    }
    std::vector&lt;char&gt; receivedData;
    while (true)
    {
        std::vector&lt;char&gt; inDat;
        int result=_receiveSimplePacket(inDat);
        if (result&lt;0)
        {
            dataSize=result+1; // error or read time-out
            return(NULL);
        }
        receivedData.insert(receivedData.end(),inDat.begin(),inDat.end());
        if (result==0)
        { // success
            dataSize=int(receivedData.size());
            char* retBuff=new char[dataSize];
            for (int i=0;i&lt;dataSize;i++)
                retBuff[i]=receivedData[i];
            return(retBuff);
        }
    }
}

</t>
<t tx="leo.20220407205632.1">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackNumber.h"
#include &lt;sstream&gt;

CStackNumber::CStackNumber(double n)
{
    _objectType=STACK_NUMBER;
    _value=n;
}

CStackNumber::~CStackNumber()
{
}

std::string CStackNumber::toString() const
{
    std::stringstream ss;
    ss &lt;&lt; _value;
    return(ss.str());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.10">void CStackObject::buildItemOntoStack(int stackId,CStackObject* obj)
{
    if (obj-&gt;getObjectType()==STACK_NULL)
        simPushNullOntoStack(stackId); // NULL
    else if (obj-&gt;getObjectType()==STACK_BOOL)
        simPushBoolOntoStack(stackId,((CStackBool*)obj)-&gt;getValue()); // Bool
    else if (obj-&gt;getObjectType()==STACK_NUMBER)
        simPushDoubleOntoStack(stackId,((CStackNumber*)obj)-&gt;getValue()); // number
    else if (obj-&gt;getObjectType()==STACK_STRING)
    { // string
        std::string str(((CStackString*)obj)-&gt;getValue());
        simPushStringOntoStack(stackId,str.c_str(),int(str.length()));
    }
    else if (obj-&gt;getObjectType()==STACK_ARRAY)
    {
        CStackArray* arr=(CStackArray*)obj;
        if (arr-&gt;getSize()==0)
            simPushTableOntoStack(stackId); // empty array
        else if (arr-&gt;getSize()&gt;0)
        {
            if (arr-&gt;isNumberArray())
               simPushDoubleTableOntoStack(stackId,&amp;arr-&gt;getDoubles()-&gt;at(0),int(arr-&gt;getDoubles()-&gt;size())); // number array
            else
            { // mixed array
                simPushTableOntoStack(stackId);
                const std::vector&lt;CStackObject*&gt;* objs=arr-&gt;getObjects();
                for (size_t i=0;i&lt;objs-&gt;size();i++)
                {
                    simPushInt32OntoStack(stackId,int(i+1)); // the key
                    CStackObject::buildItemOntoStack(stackId,objs-&gt;at(i)); // the value
                    simInsertDataIntoStackTable(stackId);
                }
            }
        }
    }
    else if (obj-&gt;getObjectType()==STACK_MAP)
    {
        CStackMap* map=(CStackMap*)obj;
        std::map&lt;std::string,CStackObject*&gt;* keyValues=map-&gt;getKeyValuePairs();
        simPushTableOntoStack(stackId);
        for (std::map&lt;std::string,CStackObject*&gt;::iterator it=keyValues-&gt;begin();it!=keyValues-&gt;end();it++)
        {
            simPushStringOntoStack(stackId,it-&gt;first.c_str(),0); // the key
            CStackObject::buildItemOntoStack(stackId,it-&gt;second); // the value
            simInsertDataIntoStackTable(stackId);
        }
    }
}

CStackObject* CStackObject::buildItemFromTopStackPosition(int stackId)
{ // this also clears the item from the stack
    CStackObject* retVal=NULL;
    simBool bv;
    double dv;
    if (1==simIsStackValueNull(stackId))
    { // NULL
        retVal=new CStackNull();
        simPopStackItem(stackId,1);
    }
    else if (1==simGetStackBoolValue(stackId,&amp;bv))
    { // bool
        retVal=new CStackBool(bv!=0);
        simPopStackItem(stackId,1);
    }
    else if (1==simGetStackDoubleValue(stackId,&amp;dv))
    { // number
        retVal=new CStackNumber(dv);
        simPopStackItem(stackId,1);
    }
    else
    {
        int sl;
        char* str=simGetStackStringValue(stackId,&amp;sl);
        if (str!=NULL)
        { // string
            retVal=new CStackString(str,sl);
            simReleaseBuffer(str);
            simPopStackItem(stackId,1);
        }
        else
        { // the item is not a NULL, bool, number or string. So it must be an array or a map:
            int s=simGetStackTableInfo(stackId,0);
            if (s==sim_stack_table_circular_ref)
            { // A map/array in a circular reference
                CStackArray* arr=new CStackArray();
                arr-&gt;setCircularRef();
                retVal=arr;
                simPopStackItem(stackId,1);
            }
            else if (s==sim_stack_table_empty)
            { // Empty Array
                retVal=new CStackArray();
                simPopStackItem(stackId,1);
            }
            else if (s&gt;0)
            { // Array
                if (1==simGetStackTableInfo(stackId,2))
                { // Array of numbers:
                    CStackArray* arr=new CStackArray();
                    std::vector&lt;double&gt; numbers;
                    numbers.resize(s);
                    simGetStackDoubleTable(stackId,&amp;numbers[0],s);
                    arr-&gt;setDoubleArray(&amp;numbers[0],s);
                    retVal=arr;
                    simPopStackItem(stackId,1);
                }
                else
                { // Array of items that are not all numbers
                    CStackArray* arr=new CStackArray();
                    int oi=simGetStackSize(stackId)-1;
                    simUnfoldStackTable(stackId); // This puts value-key pairs onto the stack
                    s=(simGetStackSize(stackId)-oi)/2;
                    for (int i=0;i&lt;s;i++)
                    {
                        simMoveStackItemToTop(stackId,oi); // that's the key
                        simPopStackItem(stackId,1);
                        simMoveStackItemToTop(stackId,oi); // that's the value
                        arr-&gt;appendTopStackItem(stackId); // will also pop it
                    }
                    retVal=arr;
                }
            }
            else if (s==sim_stack_table_map)
            { // Map
                CStackMap* map=new CStackMap();
                int oi=simGetStackSize(stackId)-1;
                simUnfoldStackTable(stackId); // This puts value-key pairs onto the stack
                s=(simGetStackSize(stackId)-oi)/2;
                for (int i=0;i&lt;s;i++)
                {
                    simMoveStackItemToTop(stackId,oi); // that's the key
                    char* str=simGetStackStringValue(stackId,NULL);
                    bool isbool=simGetStackBoolValue(stackId,&amp;bv)==1;
                    bool isnum=simGetStackDoubleValue(stackId,&amp;dv)==1;
                    simPopStackItem(stackId,1);
                    simMoveStackItemToTop(stackId,oi); // that's the value
                    if(isnum)
                        map-&gt;appendTopStackItem(int(dv),stackId); // will also pop it
                    else if(isbool)
                        map-&gt;appendTopStackItem(bv,stackId); // will also pop it
                    else
                        map-&gt;appendTopStackItem(str,stackId); // will also pop it
                    if(str) simReleaseBuffer(str);
                }
                retVal=map;
            }
        }
    }
    return(retVal);
}

CStackNull* CStackObject::asNull()
{
    if(_objectType==STACK_NULL) return(static_cast&lt;CStackNull*&gt;(this));
    else return(NULL);
}

CStackNumber* CStackObject::asNumber()
{
    if(_objectType==STACK_NUMBER) return(static_cast&lt;CStackNumber*&gt;(this));
    else return(NULL);
}

CStackBool* CStackObject::asBool()
{
    if(_objectType==STACK_BOOL) return(static_cast&lt;CStackBool*&gt;(this));
    else return(NULL);
}

CStackString* CStackObject::asString()
{
    if(_objectType==STACK_STRING) return(static_cast&lt;CStackString*&gt;(this));
    else return(NULL);
}

CStackArray* CStackObject::asArray()
{
    if(_objectType==STACK_ARRAY) return(static_cast&lt;CStackArray*&gt;(this));
    else return(NULL);
}

CStackMap* CStackObject::asMap()
{
    if(_objectType==STACK_MAP) return(static_cast&lt;CStackMap*&gt;(this));
    else return(NULL);
}

std::string CStackObject::getObjectTypeString() const
{
    switch(_objectType)
    {
    case STACK_NULL: return "null";
    case STACK_NUMBER: return "number";
    case STACK_BOOL: return "bool";
    case STACK_STRING: return "string";
    case STACK_ARRAY: return "array";
    case STACK_MAP: return "map";
    default: return "object";
    }
}

</t>
<t tx="leo.20220407205632.100">@path ./v-rep_plugin/include/
#ifndef V_REPEXT_VECTOR_CONCURRENT_QUEUE
#define V_REPEXT_VECTOR_CONCURRENT_QUEUE

#include &lt;deque&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;
#include &lt;condition_variable&gt;

/*!
 * \brief The VectorConcurrentQueue class
 * Consider template if required other vector types
 */
template &lt;typename T&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.101">class VectorConcurrentQueue {
public:
    VectorConcurrentQueue();

    bool empty();
    int size();
    void clear();
    void push_front(const std::vector&lt;T&gt; &amp;t);
    void push_back(const std::vector&lt;T&gt; &amp;t);
    std::vector&lt;T&gt; back();
    std::vector&lt;T&gt; at(size_t index);
    void pop_back();

private:
    std::deque&lt; std::vector&lt;T&gt; &gt; m_deque;
    std::mutex m_mutex;
    std::condition_variable m_cond;
};

template &lt;typename T&gt;
VectorConcurrentQueue&lt;T&gt;::VectorConcurrentQueue()
{}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205632.102">bool VectorConcurrentQueue&lt;T&gt;::empty()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    bool empty = m_deque.empty();
    lk.unlock();
    return empty;
}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205632.103">int VectorConcurrentQueue&lt;T&gt;::size()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    size_t sz = m_deque.size();
    lk.unlock();
    return sz;
}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205632.104">void VectorConcurrentQueue&lt;T&gt;::clear()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.clear();
    lk.unlock();
}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205632.105">void VectorConcurrentQueue&lt;T&gt;::push_front(const std::vector&lt;T&gt; &amp;t)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_front(t);
    lk.unlock();
    m_cond.notify_one();
}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205632.106">void VectorConcurrentQueue&lt;T&gt;::push_back(const std::vector&lt;T&gt; &amp;t)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_back(t);
    lk.unlock();
    m_cond.notify_one();
}

template &lt;typename T&gt;
std::vector&lt;T&gt; VectorConcurrentQueue&lt;T&gt;::back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.back();
}

template&lt;typename T&gt;
std::vector&lt;T&gt; VectorConcurrentQueue&lt;T&gt;::at(size_t index)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.at(index);	
}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205632.107">void VectorConcurrentQueue&lt;T&gt;::pop_back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    m_deque.pop_back();
}



#endif //V_REPEXT_VECTOR_CONCURRENT_QUEUE
</t>
<t tx="leo.20220407205632.108"></t>
<t tx="leo.20220407205632.109">@path ./v-rep_plugin/spdlog/

//
// Copyright(c) 2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

//
// Async logging using global thread pool
// All loggers created here share same global thread pool.
// Each log message is pushed to a queue along withe a shared pointer to the
// logger.
// If a logger deleted while having pending messages in the queue, it's actual
// destruction will defer
// until all its messages are processed by the thread pool.
// This is because each message in the queue holds a shared_ptr to the
// originating logger.

#include "spdlog/async_logger.h"
#include "spdlog/details/registry.h"
#include "spdlog/details/thread_pool.h"

#include &lt;memory&gt;
#include &lt;mutex&gt;

namespace spdlog {

namespace details {
static const size_t default_async_q_size = 8192;
}

// async logger factory - creates async loggers backed with thread pool.
// if a global thread pool doesn't already exist, create it with default queue
// size of 8192 items and single thread.
template&lt;async_overflow_policy OverflowPolicy = async_overflow_policy::block&gt;
struct async_factory_impl
{
    template&lt;typename Sink, typename... SinkArgs&gt;
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.11">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackString.h"
#include &lt;sstream&gt;

CStackString::CStackString(const char* str,int l)
{
    _objectType=STACK_STRING;
    if (l&gt;0)
        _value.assign(str,str+l);
}

CStackString::~CStackString()
{
}

std::string CStackString::toString() const
{
    std::stringstream ss;
    ss &lt;&lt; "\"";
    for(size_t i = 0; i &lt; _value.size(); ++i)
    {
        char c = _value[i];
        if(c == '"') ss &lt;&lt; "\\\"";
        else if(c == '\\') ss &lt;&lt; "\\\\";
        else if(c == '\n') ss &lt;&lt; "\\n";
        else if(c == '\r') ss &lt;&lt; "\\r";
        else if(c == '\t') ss &lt;&lt; "\\t";
        else ss &lt;&lt; c;
    }
    ss &lt;&lt; "\"";
    return(ss.str());
}

std::string CStackString::getValue()
{
    return(_value);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.110">    static std::shared_ptr&lt;async_logger&gt; create(std::string logger_name, SinkArgs &amp;&amp;... args)
    {
        auto &amp;registry_inst = details::registry::instance();

        // create global thread pool if not already exists..
        std::lock_guard&lt;std::recursive_mutex&gt; tp_lock(registry_inst.tp_mutex());
        auto tp = registry_inst.get_tp();
        if (tp == nullptr)
        {
            tp = std::make_shared&lt;details::thread_pool&gt;(details::default_async_q_size, 1);
            registry_inst.set_tp(tp);
        }

        auto sink = std::make_shared&lt;Sink&gt;(std::forward&lt;SinkArgs&gt;(args)...);
        auto new_logger = std::make_shared&lt;async_logger&gt;(std::move(logger_name), std::move(sink), std::move(tp), OverflowPolicy);
        registry_inst.initialize_logger(new_logger);
        return new_logger;
    }
};

using async_factory = async_factory_impl&lt;async_overflow_policy::block&gt;;
using async_factory_nonblock = async_factory_impl&lt;async_overflow_policy::overrun_oldest&gt;;

template&lt;typename Sink, typename... SinkArgs&gt;
inline std::shared_ptr&lt;spdlog::logger&gt; create_async(std::string logger_name, SinkArgs &amp;&amp;... sink_args)
{
    return async_factory::create&lt;Sink&gt;(std::move(logger_name), std::forward&lt;SinkArgs&gt;(sink_args)...);
}

template&lt;typename Sink, typename... SinkArgs&gt;
inline std::shared_ptr&lt;spdlog::logger&gt; create_async_nb(std::string logger_name, SinkArgs &amp;&amp;... sink_args)
{
    return async_factory_nonblock::create&lt;Sink&gt;(std::move(logger_name), std::forward&lt;SinkArgs&gt;(sink_args)...);
}

// set global thread pool.
inline void init_thread_pool(size_t q_size, size_t thread_count)
{
    auto tp = std::make_shared&lt;details::thread_pool&gt;(q_size, thread_count);
    details::registry::instance().set_tp(std::move(tp));
}

// get the global thread pool.
inline std::shared_ptr&lt;spdlog::details::thread_pool&gt; thread_pool()
{
    return details::registry::instance().get_tp();
}
} // namespace spdlog
</t>
<t tx="leo.20220407205632.111">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

// Very fast asynchronous logger (millions of logs per second on an average
// desktop)
// Uses pre allocated lockfree queue for maximum throughput even under large
// number of threads.
// Creates a single back thread to pop messages from the queue and log them.
//
// Upon each log write the logger:
//    1. Checks if its log level is enough to log the message
//    2. Push a new copy of the message to a queue (or block the caller until
//    space is available in the queue)
//    3. will throw spdlog_ex upon log exceptions
// Upon destruction, logs all remaining messages in the queue before
// destructing..

#include "spdlog/common.h"
#include "spdlog/logger.h"

#include &lt;chrono&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

namespace spdlog {

// Async overflow policy - block by default.
enum class async_overflow_policy
{
    block,         // Block until message can be enqueued
    overrun_oldest // Discard oldest message in the queue if full when trying to
                   // add new item.
};

namespace details {
class thread_pool;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.112">class async_logger final : public std::enable_shared_from_this&lt;async_logger&gt;, public logger
{
    friend class details::thread_pool;

public:
    template&lt;typename It&gt;
    async_logger(std::string logger_name, It begin, It end, std::weak_ptr&lt;details::thread_pool&gt; tp,
        async_overflow_policy overflow_policy = async_overflow_policy::block);

    async_logger(std::string logger_name, sinks_init_list sinks_list, std::weak_ptr&lt;details::thread_pool&gt; tp,
        async_overflow_policy overflow_policy = async_overflow_policy::block);

    async_logger(std::string logger_name, sink_ptr single_sink, std::weak_ptr&lt;details::thread_pool&gt; tp,
        async_overflow_policy overflow_policy = async_overflow_policy::block);

    std::shared_ptr&lt;logger&gt; clone(std::string new_name) override;

protected:
    void sink_it_(details::log_msg &amp;msg) override;
    void flush_() override;

    void backend_log_(const details::log_msg &amp;incoming_log_msg);
    void backend_flush_();

private:
    std::weak_ptr&lt;details::thread_pool&gt; thread_pool_;
    async_overflow_policy overflow_policy_;
};
} // namespace spdlog

#include "details/async_logger_impl.h"
</t>
<t tx="leo.20220407205632.113">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include "spdlog/tweakme.h"

#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;initializer_list&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;type_traits&gt;
#include &lt;unordered_map&gt;

#if defined(SPDLOG_WCHAR_FILENAMES) || defined(SPDLOG_WCHAR_TO_UTF8_SUPPORT)
#include &lt;codecvt&gt;
#include &lt;locale&gt;
#endif

#include "spdlog/details/null_mutex.h"

#include "spdlog/fmt/fmt.h"

// visual studio upto 2013 does not support noexcept nor constexpr
#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1900)
#define SPDLOG_NOEXCEPT throw()
#define SPDLOG_CONSTEXPR
#else
#define SPDLOG_NOEXCEPT noexcept
#define SPDLOG_CONSTEXPR constexpr
#endif

#if defined(__GNUC__) || defined(__clang__)
#define SPDLOG_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define SPDLOG_DEPRECATED __declspec(deprecated)
#else
#define SPDLOG_DEPRECATED
#endif

// disable thread local on msvc 2013
#ifndef SPDLOG_NO_TLS
#if (defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt; 1900))
#define SPDLOG_NO_TLS 1
#endif
#endif


// Get the basename of __FILE__ (at compile time if possible) 
#if FMT_HAS_FEATURE(__builtin_strrchr) 
#define SPDLOG_STRRCHR(str, sep) __builtin_strrchr(str, sep)
#else
#define SPDLOG_STRRCHR(str, sep) strrchr(str, sep)
#endif //__builtin_strrchr not defined

#ifdef _WIN32
#define SPDLOG_FILE_BASENAME(file) SPDLOG_STRRCHR("\\" file, '\\') + 1
#else
#define SPDLOG_FILE_BASENAME(file) SPDLOG_STRRCHR("/" file, '/') + 1
#endif

namespace spdlog {

class formatter;

namespace sinks {
class sink;
}

using log_clock = std::chrono::system_clock;
using sink_ptr = std::shared_ptr&lt;sinks::sink&gt;;
using sinks_init_list = std::initializer_list&lt;sink_ptr&gt;;
using log_err_handler = std::function&lt;void(const std::string &amp;err_msg)&gt;;

// string_view type - either std::string_view or fmt::string_view (pre c++17)
#if defined(FMT_USE_STD_STRING_VIEW)
using string_view_t = std::string_view;
#else
using string_view_t = fmt::string_view;
#endif

#if defined(SPDLOG_NO_ATOMIC_LEVELS)
using level_t = details::null_atomic_int;
#else
using level_t = std::atomic&lt;int&gt;;
#endif

#define SPDLOG_LEVEL_TRACE 0
#define SPDLOG_LEVEL_DEBUG 1
#define SPDLOG_LEVEL_INFO 2
#define SPDLOG_LEVEL_WARN 3
#define SPDLOG_LEVEL_ERROR 4
#define SPDLOG_LEVEL_CRITICAL 5
#define SPDLOG_LEVEL_OFF 6

#if !defined(SPDLOG_ACTIVE_LEVEL)
#define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_INFO
#endif

// Log level enum
namespace level {
enum level_enum
{
    trace = SPDLOG_LEVEL_TRACE,
    debug = SPDLOG_LEVEL_DEBUG,
    info = SPDLOG_LEVEL_INFO,
    warn = SPDLOG_LEVEL_WARN,
    err = SPDLOG_LEVEL_ERROR,
    critical = SPDLOG_LEVEL_CRITICAL,
    off = SPDLOG_LEVEL_OFF,
};

#if !defined(SPDLOG_LEVEL_NAMES)
#define SPDLOG_LEVEL_NAMES                                                                                                                 \
    {                                                                                                                                      \
        "trace", "debug", "info", "warning", "error", "critical", "off"                                                                    \
    }
#endif

static string_view_t level_string_views[] SPDLOG_LEVEL_NAMES;
static const char *short_level_names[]{"T", "D", "I", "W", "E", "C", "O"};

inline string_view_t &amp;to_string_view(spdlog::level::level_enum l) SPDLOG_NOEXCEPT
{
    return level_string_views[l];
}

inline const char *to_short_c_str(spdlog::level::level_enum l) SPDLOG_NOEXCEPT
{
    return short_level_names[l];
}

inline spdlog::level::level_enum from_str(const std::string &amp;name) SPDLOG_NOEXCEPT
{
    int level = 0;
    for (const auto &amp;level_str : level_string_views)
    {
        if (level_str == name)
        {
            return static_cast&lt;level::level_enum&gt;(level);
        }
        level++;
    }
    return level::off;
}

using level_hasher = std::hash&lt;int&gt;;
} // namespace level

//
// Pattern time - specific time getting to use for pattern_formatter.
// local time by default
//
enum class pattern_time_type
{
    local, // log localtime
    utc    // log utc
};

//
// Log exception
//
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.114">class spdlog_ex : public std::exception
{
public:
    explicit spdlog_ex(std::string msg)
        : msg_(std::move(msg))
    {
    }

    spdlog_ex(const std::string &amp;msg, int last_errno)
    {
        fmt::memory_buffer outbuf;
        fmt::format_system_error(outbuf, last_errno, msg);
        msg_ = fmt::to_string(outbuf);
    }

    @others
};

//
// wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)
//
#if defined(_WIN32) &amp;&amp; defined(SPDLOG_WCHAR_FILENAMES)
using filename_t = std::wstring;
#else
using filename_t = std::string;
#endif

struct source_loc
{
    SPDLOG_CONSTEXPR source_loc()
        : filename{""}
        , line{0}
    {
    }
    SPDLOG_CONSTEXPR source_loc(const char *filename, int line)
        : filename{filename}
        , line{static_cast&lt;uint32_t&gt;(line)}
    {
    }

    SPDLOG_CONSTEXPR bool empty() const SPDLOG_NOEXCEPT
    {
        return line == 0;
    }
    const char *filename;
    uint32_t line;
};

namespace details {
// make_unique support for pre c++14

#if __cplusplus &gt;= 201402L // C++14 and beyond
using std::make_unique;
#else
template&lt;typename T, typename... Args&gt;
std::unique_ptr&lt;T&gt; make_unique(Args &amp;&amp;... args)
{
    static_assert(!std::is_array&lt;T&gt;::value, "arrays not supported");
    return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));
}
#endif
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205632.115">    const char *what() const SPDLOG_NOEXCEPT override
    {
        return msg_.c_str();
    }

private:
    std::string msg_;
</t>
<t tx="leo.20220407205632.116">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include "fmt/fmt.h"
#include "spdlog/details/log_msg.h"

namespace spdlog {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.117">class formatter
{
public:
    virtual ~formatter() = default;
    virtual void format(const details::log_msg &amp;msg, fmt::memory_buffer &amp;dest) = 0;
    virtual std::unique_ptr&lt;formatter&gt; clone() const = 0;
};
} // namespace spdlog
</t>
<t tx="leo.20220407205632.118">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015-2108 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

// Thread safe logger (except for set_pattern(..), set_formatter(..) and
// set_error_handler())
// Has name, log level, vector of std::shared sink pointers and formatter
// Upon each log write the logger:
// 1. Checks if its log level is enough to log the message and if yes:
// 2. Call the underlying sinks to do the job.
// 3. Each sink use its own private copy of a formatter to format the message
// and send to its destination.
//
// The use of private formatter per sink provides the opportunity to cache some
// formatted data,
// and support customize format per each sink.

#include "spdlog/common.h"
#include "spdlog/formatter.h"
#include "spdlog/sinks/sink.h"

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace spdlog {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.119">class logger
{
public:
    logger(std::string name, sink_ptr single_sink);
    logger(std::string name, sinks_init_list sinks);

    template&lt;typename It&gt;
    logger(std::string name, It begin, It end);

    virtual ~logger();

    logger(const logger &amp;) = delete;
    logger &amp;operator=(const logger &amp;) = delete;

    template&lt;typename... Args&gt;
    void log(level::level_enum lvl, const char *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void log(source_loc loc, level::level_enum lvl, const char *fmt, const Args &amp;... args);

    void log(level::level_enum lvl, const char *msg);

    void log(source_loc loc, level::level_enum lvl, const char *msg);

    template&lt;typename... Args&gt;
    void trace(const char *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void debug(const char *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void info(const char *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void warn(const char *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void error(const char *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void critical(const char *fmt, const Args &amp;... args);

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
#ifndef _WIN32
#error SPDLOG_WCHAR_TO_UTF8_SUPPORT only supported on windows
#else
    template&lt;typename... Args&gt;
    void log(level::level_enum lvl, const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void log(source_loc source, level::level_enum lvl, const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void trace(const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void debug(const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void info(const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void warn(const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void error(const wchar_t *fmt, const Args &amp;... args);

    template&lt;typename... Args&gt;
    void critical(const wchar_t *fmt, const Args &amp;... args);
#endif // _WIN32
#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT

    // T can be statically converted to string_view
    template&lt;class T, typename std::enable_if&lt;std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type * = nullptr&gt;
    void log(level::level_enum lvl, const T &amp;);

    // T can be statically converted to string_view
    template&lt;class T, typename std::enable_if&lt;std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type * = nullptr&gt;
    void log(source_loc loc, level::level_enum lvl, const T &amp;);

    // T cannot be statically converted to string_view
    template&lt;class T, typename std::enable_if&lt;!std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type * = nullptr&gt;
    void log(level::level_enum lvl, const T &amp;);

    // T cannot be statically converted to string_view
    template&lt;class T, typename std::enable_if&lt;!std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type * = nullptr&gt;
    void log(source_loc loc, level::level_enum lvl, const T &amp;);

    template&lt;typename T&gt;
    void trace(const T &amp;msg);

    template&lt;typename T&gt;
    void debug(const T &amp;msg);

    template&lt;typename T&gt;
    void info(const T &amp;msg);

    template&lt;typename T&gt;
    void warn(const T &amp;msg);

    template&lt;typename T&gt;
    void error(const T &amp;msg);

    template&lt;typename T&gt;
    void critical(const T &amp;msg);

    bool should_log(level::level_enum msg_level) const;
    void set_level(level::level_enum log_level);

    static level::level_enum default_level();
    level::level_enum level() const;
    const std::string &amp;name() const;

    // set formatting for the sinks in this logger.
    // each sink will get a seperate instance of the formatter object.
    void set_formatter(std::unique_ptr&lt;formatter&gt; formatter);
    void set_pattern(std::string pattern, pattern_time_type time_type = pattern_time_type::local);

    // flush functions
    void flush();
    void flush_on(level::level_enum log_level);
    level::level_enum flush_level() const;

    // sinks
    const std::vector&lt;sink_ptr&gt; &amp;sinks() const;
    std::vector&lt;sink_ptr&gt; &amp;sinks();

    // error handler
    void set_error_handler(log_err_handler err_handler);
    log_err_handler error_handler() const;

    // create new logger with same sinks and configuration.
    virtual std::shared_ptr&lt;logger&gt; clone(std::string logger_name);

protected:
    virtual void sink_it_(details::log_msg &amp;msg);
    virtual void flush_();

    bool should_flush_(const details::log_msg &amp;msg);

    // default error handler.
    // print the error to stderr with the max rate of 1 message/minute.
    void default_err_handler_(const std::string &amp;msg);

    // increment the message count (only if defined(SPDLOG_ENABLE_MESSAGE_COUNTER))
    void incr_msg_counter_(details::log_msg &amp;msg);

    const std::string name_;
    std::vector&lt;sink_ptr&gt; sinks_;
    spdlog::level_t level_{spdlog::logger::default_level()};
    spdlog::level_t flush_level_{level::off};
    log_err_handler err_handler_{[this](const std::string &amp;msg) { this-&gt;default_err_handler_(msg); }};
    std::atomic&lt;time_t&gt; last_err_time_{0};
    std::atomic&lt;size_t&gt; msg_counter_{1};
};
} // namespace spdlog

#include "details/logger_impl.h"
</t>
<t tx="leo.20220407205632.12">void CStackString::setValue(const char* str,int l)
{
    if (l&gt;0)
        _value.assign(str,str+l);
    else
        _value.clear();
}

CStackObject* CStackString::copyYourself()
{
    CStackString* retVal=new CStackString(_value.c_str(),int(_value.length()));
    return(retVal);
}
</t>
<t tx="leo.20220407205632.120">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015-2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//
// spdlog main header file.
// see example.cpp for usage example

#ifndef SPDLOG_H
#define SPDLOG_H
#pragma once

#include "spdlog/common.h"
#include "spdlog/details/registry.h"
#include "spdlog/logger.h"
#include "spdlog/version.h"

#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

namespace spdlog {

// Default logger factory-  creates synchronous loggers
struct synchronous_factory
{
    template&lt;typename Sink, typename... SinkArgs&gt;
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.121">    static std::shared_ptr&lt;spdlog::logger&gt; create(std::string logger_name, SinkArgs &amp;&amp;... args)
    {
        auto sink = std::make_shared&lt;Sink&gt;(std::forward&lt;SinkArgs&gt;(args)...);
        auto new_logger = std::make_shared&lt;logger&gt;(std::move(logger_name), std::move(sink));
        details::registry::instance().initialize_logger(new_logger);
        return new_logger;
    }
};

using default_factory = synchronous_factory;

// Create and register a logger with a templated sink type
// The logger's level, formatter and flush level will be set according the
// global settings.
// Example:
// spdlog::create&lt;daily_file_sink_st&gt;("logger_name", "dailylog_filename", 11, 59);
template&lt;typename Sink, typename... SinkArgs&gt;
inline std::shared_ptr&lt;spdlog::logger&gt; create(std::string logger_name, SinkArgs &amp;&amp;... sink_args)
{
    return default_factory::create&lt;Sink&gt;(std::move(logger_name), std::forward&lt;SinkArgs&gt;(sink_args)...);
}

// Return an existing logger or nullptr if a logger with such name doesn't
// exist.
// example: spdlog::get("my_logger")-&gt;info("hello {}", "world");
inline std::shared_ptr&lt;logger&gt; get(const std::string &amp;name)
{
    return details::registry::instance().get(name);
}

// Set global formatter. Each sink in each logger will get a clone of this object
inline void set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; formatter)
{
    details::registry::instance().set_formatter(std::move(formatter));
}

// Set global format string.
// example: spdlog::set_pattern("%Y-%m-%d %H:%M:%S.%e %l : %v");
inline void set_pattern(std::string pattern, pattern_time_type time_type = pattern_time_type::local)
{
    set_formatter(std::unique_ptr&lt;spdlog::formatter&gt;(new pattern_formatter(std::move(pattern), time_type)));
}

// Set global logging level
inline void set_level(level::level_enum log_level)
{
    details::registry::instance().set_level(log_level);
}

// Set global flush level
inline void flush_on(level::level_enum log_level)
{
    details::registry::instance().flush_on(log_level);
}

// Start/Restart a periodic flusher thread
// Warning: Use only if all your loggers are thread safe!
inline void flush_every(std::chrono::seconds interval)
{
    details::registry::instance().flush_every(interval);
}

// Set global error handler
inline void set_error_handler(log_err_handler handler)
{
    details::registry::instance().set_error_handler(std::move(handler));
}

// Register the given logger with the given name
inline void register_logger(std::shared_ptr&lt;logger&gt; logger)
{
    details::registry::instance().register_logger(std::move(logger));
}

// Apply a user defined function on all registered loggers
// Example:
// spdlog::apply_all([&amp;](std::shared_ptr&lt;spdlog::logger&gt; l) {l-&gt;flush();});
inline void apply_all(const std::function&lt;void(std::shared_ptr&lt;logger&gt;)&gt; &amp;fun)
{
    details::registry::instance().apply_all(fun);
}

// Drop the reference to the given logger
inline void drop(const std::string &amp;name)
{
    details::registry::instance().drop(name);
}

// Drop all references from the registry
inline void drop_all()
{
    details::registry::instance().drop_all();
}

// stop any running threads started by spdlog and clean registry loggers
inline void shutdown()
{
    details::registry::instance().shutdown();
}

// Automatic registration of loggers when using spdlog::create() or spdlog::create_async
inline void set_automatic_registration(bool automatic_registation)
{
    details::registry::instance().set_automatic_registration(automatic_registation);
}

// API for using default logger (stdout_color_mt),
// e.g: spdlog::info("Message {}", 1);
//
// The default logger object can be accessed using the spdlog::default_logger():
// For example, to add another sink to it:
// spdlog::default_logger()-&gt;sinks()-&gt;push_back(some_sink);
//
// The default logger can replaced using spdlog::set_default_logger(new_logger).
// For example, to replace it with a file logger.
//
// IMPORTANT:
// The default API is thread safe (for _mt loggers), but:
// set_default_logger() *should not* be used concurrently with the default API.
// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.

inline std::shared_ptr&lt;spdlog::logger&gt; default_logger()
{
    return details::registry::instance().default_logger();
}

inline spdlog::logger *default_logger_raw()
{
    return details::registry::instance().get_default_raw();
}

inline void set_default_logger(std::shared_ptr&lt;spdlog::logger&gt; default_logger)
{
    details::registry::instance().set_default_logger(std::move(default_logger));
}

template&lt;typename... Args&gt;
inline void log(source_loc source, level::level_enum lvl, const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;log(source, lvl, fmt, args...);
}

template&lt;typename... Args&gt;
inline void log(level::level_enum lvl, const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;log(source_loc{}, lvl, fmt, args...);
}

template&lt;typename... Args&gt;
inline void trace(const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;trace(fmt, args...);
}

template&lt;typename... Args&gt;
inline void debug(const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;debug(fmt, args...);
}

template&lt;typename... Args&gt;
inline void info(const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;info(fmt, args...);
}

template&lt;typename... Args&gt;
inline void warn(const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;warn(fmt, args...);
}

template&lt;typename... Args&gt;
inline void error(const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;error(fmt, args...);
}

template&lt;typename... Args&gt;
inline void critical(const char *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;critical(fmt, args...);
}

template&lt;typename T&gt;
inline void log(level::level_enum lvl, const T &amp;msg)
{
    default_logger_raw()-&gt;log(lvl, msg);
}

template&lt;typename T&gt;
inline void trace(const T &amp;msg)
{
    default_logger_raw()-&gt;trace(msg);
}

template&lt;typename T&gt;
inline void debug(const T &amp;msg)
{
    default_logger_raw()-&gt;debug(msg);
}

template&lt;typename T&gt;
inline void info(const T &amp;msg)
{
    default_logger_raw()-&gt;info(msg);
}

template&lt;typename T&gt;
inline void warn(const T &amp;msg)
{
    default_logger_raw()-&gt;warn(msg);
}

template&lt;typename T&gt;
inline void error(const T &amp;msg)
{
    default_logger_raw()-&gt;error(msg);
}

template&lt;typename T&gt;
inline void critical(const T &amp;msg)
{
    default_logger_raw()-&gt;critical(msg);
}

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT
template&lt;typename... Args&gt;
inline void log(level::level_enum lvl, const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;log(lvl, fmt, args...);
}

template&lt;typename... Args&gt;
inline void trace(const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;trace(fmt, args...);
}

template&lt;typename... Args&gt;
inline void debug(const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;debug(fmt, args...);
}

template&lt;typename... Args&gt;
inline void info(const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;info(fmt, args...);
}

template&lt;typename... Args&gt;
inline void warn(const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;warn(fmt, args...);
}

template&lt;typename... Args&gt;
inline void error(const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;error(fmt, args...);
}

template&lt;typename... Args&gt;
inline void critical(const wchar_t *fmt, const Args &amp;... args)
{
    default_logger_raw()-&gt;critical(fmt, args...);
}

#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT

} // namespace spdlog



//
// enable/disable log calls at compile time according to global level.
//
// define SPDLOG_ACTIVE_LEVEL to one of those (before including spdlog.h):
// SPDLOG_LEVEL_TRACE,
// SPDLOG_LEVEL_DEBUG,
// SPDLOG_LEVEL_INFO,
// SPDLOG_LEVEL_WARN,
// SPDLOG_LEVEL_ERROR,
// SPDLOG_LEVEL_CRITICAL,
// SPDLOG_LEVEL_OFF
//

#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_TRACE
#define SPDLOG_LOGGER_TRACE(logger, ...)\
    if(logger-&gt;should_log(spdlog::level::trace))\
        logger-&gt;log(spdlog::source_loc{SPDLOG_FILE_BASENAME(__FILE__), __LINE__}, spdlog::level::trace, __VA_ARGS__)
#define SPDLOG_TRACE(...) SPDLOG_LOGGER_TRACE(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#define SPDLOG_LOGGER_TRACE(logger, ...) (void)0
#define SPDLOG_TRACE(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_DEBUG
#define SPDLOG_LOGGER_DEBUG(logger, ...) logger-&gt;log(spdlog::level::debug, __VA_ARGS__)
#define SPDLOG_DEBUG(...) SPDLOG_LOGGER_DEBUG(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#define SPDLOG_LOGGER_DEBUG(logger, ...) (void)0
#define SPDLOG_DEBUG(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_INFO
#define SPDLOG_LOGGER_INFO(logger, ...) logger-&gt;log(spdlog::level::info, __VA_ARGS__)
#define SPDLOG_INFO(...) SPDLOG_LOGGER_INFO(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#define SPDLOG_LOGGER_INFO(logger, ...) (void)0
#define SPDLOG_INFO(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_WARN
#define SPDLOG_LOGGER_WARN(logger, ...) logger-&gt;log(spdlog::level::warn, __VA_ARGS__)
#define SPDLOG_WARN(...) SPDLOG_LOGGER_WARN(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#define SPDLOG_LOGGER_WARN(logger, ...) (void)0
#define SPDLOG_WARN(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_ERROR
#define SPDLOG_LOGGER_ERROR(logger, ...) logger-&gt;log(spdlog::level::err, __VA_ARGS__)
#define SPDLOG_ERROR(...) SPDLOG_LOGGER_ERROR(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#define SPDLOG_LOGGER_ERROR(logger, ...) (void)0
#define SPDLOG_ERROR(...) (void)0
#endif

#if SPDLOG_ACTIVE_LEVEL &lt;= SPDLOG_LEVEL_CRITICAL
#define SPDLOG_LOGGER_CRITICAL(logger, ...) logger-&gt;log(spdlog::level::critical, __VA_ARGS__)
#define SPDLOG_CRITICAL(...) SPDLOG_LOGGER_CRITICAL(spdlog::default_logger_raw(), __VA_ARGS__)
#else
#define SPDLOG_LOGGER_CRITICAL(logger, ...) (void)0
#define SPDLOG_CRITICAL(...) (void)0
#endif

#endif // SPDLOG_H
</t>
<t tx="leo.20220407205632.122">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

///////////////////////////////////////////////////////////////////////////////
//
// Edit this file to squeeze more performance, and to customize supported
// features
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Under Linux, the much faster CLOCK_REALTIME_COARSE clock can be used.
// This clock is less accurate - can be off by dozens of millis - depending on
// the kernel HZ.
// Uncomment to use it instead of the regular clock.
//
// #define SPDLOG_CLOCK_COARSE
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment if date/time logging is not needed and never appear in the log
// pattern.
// This will prevent spdlog from querying the clock on each log call.
//
// WARNING: If the log pattern contains any date/time while this flag is on, the
// result is undefined.
//          You must set new pattern(spdlog::set_pattern(..") without any
//          date/time in it
//
// #define SPDLOG_NO_DATETIME
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment if thread id logging is not needed (i.e. no %t in the log pattern).
// This will prevent spdlog from querying the thread id on each log call.
//
// WARNING: If the log pattern contains thread id (i.e, %t) while this flag is
// on, the result is undefined.
//
// #define SPDLOG_NO_THREAD_ID
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to prevent spdlog from using thread local storage.
//
// WARNING: if your program forks, UNCOMMENT this flag to prevent undefined
// thread ids in the children logs.
//
// #define SPDLOG_NO_TLS
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment if logger name logging is not needed.
// This will prevent spdlog from copying the logger name on each log call.
//
// #define SPDLOG_NO_NAME
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable the SPDLOG_DEBUG/SPDLOG_TRACE macros.
//
// #define SPDLOG_DEBUG_ON
// #define SPDLOG_TRACE_ON
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to avoid spdlog's usage of atomic log levels
// Use only if your code never modifies a logger's log levels concurrently by
// different threads.
//
// #define SPDLOG_NO_ATOMIC_LEVELS
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable usage of wchar_t for file names on Windows.
//
// #define SPDLOG_WCHAR_FILENAMES
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to override default eol ("\n" or "\r\n" under Linux/Windows)
//
// #define SPDLOG_EOL ";-)\n"
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to use your own copy of the fmt library instead of spdlog's copy.
// In this case spdlog will try to include &lt;fmt/format.h&gt; so set your -I flag
// accordingly.
//
// #define SPDLOG_FMT_EXTERNAL
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable wchar_t support (convert to utf8)
//
// #define SPDLOG_WCHAR_TO_UTF8_SUPPORT
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to prevent child processes from inheriting log file descriptors
//
// #define SPDLOG_PREVENT_CHILD_FD
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to enable message counting feature.
// Use the %i in the logger pattern to display log message sequence id.
//
// #define SPDLOG_ENABLE_MESSAGE_COUNTER
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to customize level names (e.g. "MT TRACE")
//
// #define SPDLOG_LEVEL_NAMES { "MY TRACE", "MY DEBUG", "MY INFO", "MY WARNING",
// "MY ERROR", "MY CRITICAL", "OFF" }
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment to disable default logger creation.
// This might save some (very) small initialization time if no default logger is needed.
//
// #define SPDLOG_DISABLE_DEFAULT_LOGGER
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Uncomment and set to compile time level with zero cost (default is INFO).
// Macros like SPDLOG_DEBUG(..), SPDLOG_INFO(..)  will expand to empty statements if not enabled
//
// #define SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_INFO
///////////////////////////////////////////////////////////////////////////////
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.123">@path ./v-rep_plugin/spdlog/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#define SPDLOG_VER_MAJOR 1
#define SPDLOG_VER_MINOR 3
#define SPDLOG_VER_PATCH 0

#define SPDLOG_VERSION (SPDLOG_VER_MAJOR * 10000 + SPDLOG_VER_MINOR * 100 + SPDLOG_VER_PATCH)
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.13"></t>
<t tx="leo.20220407205632.14">@path ./v-rep_plugin/coppelia/include/
/*
 * Dirent interface for Microsoft Visual Studio
 * Version 1.21
 *
 * Copyright (C) 2006-2012 Toni Ronkko
 * This file is part of dirent.  Dirent may be freely distributed
 * under the MIT license.  For all details and documentation, see
 * https://github.com/tronkko/dirent
 */
#ifndef DIRENT_H
#define DIRENT_H

/*
 * Define architecture flags so we don't need to include windows.h.
 * Avoiding windows.h makes it simpler to use windows sockets in conjunction
 * with dirent.h.
 */
#if !defined(_68K_) &amp;&amp; !defined(_MPPC_) &amp;&amp; !defined(_X86_) &amp;&amp; !defined(_IA64_) &amp;&amp; !defined(_AMD64_) &amp;&amp; defined(_M_IX86)
#   define _X86_
#endif
#if !defined(_68K_) &amp;&amp; !defined(_MPPC_) &amp;&amp; !defined(_X86_) &amp;&amp; !defined(_IA64_) &amp;&amp; !defined(_AMD64_) &amp;&amp; defined(_M_AMD64)
#define _AMD64_
#endif

#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;windef.h&gt;
#include &lt;winbase.h&gt;
#include &lt;wchar.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;

/* Indicates that d_type field is available in dirent structure */
#define _DIRENT_HAVE_D_TYPE

/* Indicates that d_namlen field is available in dirent structure */
#define _DIRENT_HAVE_D_NAMLEN

/* Entries missing from MSVC 6.0 */
#if !defined(FILE_ATTRIBUTE_DEVICE)
#   define FILE_ATTRIBUTE_DEVICE 0x40
#endif

/* File type and permission flags for stat(), general mask */
#if !defined(S_IFMT)
#   define S_IFMT _S_IFMT
#endif

/* Directory bit */
#if !defined(S_IFDIR)
#   define S_IFDIR _S_IFDIR
#endif

/* Character device bit */
#if !defined(S_IFCHR)
#   define S_IFCHR _S_IFCHR
#endif

/* Pipe bit */
#if !defined(S_IFFIFO)
#   define S_IFFIFO _S_IFFIFO
#endif

/* Regular file bit */
#if !defined(S_IFREG)
#   define S_IFREG _S_IFREG
#endif

/* Read permission */
#if !defined(S_IREAD)
#   define S_IREAD _S_IREAD
#endif

/* Write permission */
#if !defined(S_IWRITE)
#   define S_IWRITE _S_IWRITE
#endif

/* Execute permission */
#if !defined(S_IEXEC)
#   define S_IEXEC _S_IEXEC
#endif

/* Pipe */
#if !defined(S_IFIFO)
#   define S_IFIFO _S_IFIFO
#endif

/* Block device */
#if !defined(S_IFBLK)
#   define S_IFBLK 0
#endif

/* Link */
#if !defined(S_IFLNK)
#   define S_IFLNK 0
#endif

/* Socket */
#if !defined(S_IFSOCK)
#   define S_IFSOCK 0
#endif

/* Read user permission */
#if !defined(S_IRUSR)
#   define S_IRUSR S_IREAD
#endif

/* Write user permission */
#if !defined(S_IWUSR)
#   define S_IWUSR S_IWRITE
#endif

/* Execute user permission */
#if !defined(S_IXUSR)
#   define S_IXUSR 0
#endif

/* Read group permission */
#if !defined(S_IRGRP)
#   define S_IRGRP 0
#endif

/* Write group permission */
#if !defined(S_IWGRP)
#   define S_IWGRP 0
#endif

/* Execute group permission */
#if !defined(S_IXGRP)
#   define S_IXGRP 0
#endif

/* Read others permission */
#if !defined(S_IROTH)
#   define S_IROTH 0
#endif

/* Write others permission */
#if !defined(S_IWOTH)
#   define S_IWOTH 0
#endif

/* Execute others permission */
#if !defined(S_IXOTH)
#   define S_IXOTH 0
#endif

/* Maximum length of file name */
#if !defined(PATH_MAX)
#   define PATH_MAX MAX_PATH
#endif
#if !defined(FILENAME_MAX)
#   define FILENAME_MAX MAX_PATH
#endif
#if !defined(NAME_MAX)
#   define NAME_MAX FILENAME_MAX
#endif

/* File type flags for d_type */
#define DT_UNKNOWN 0
#define DT_REG S_IFREG
#define DT_DIR S_IFDIR
#define DT_FIFO S_IFIFO
#define DT_SOCK S_IFSOCK
#define DT_CHR S_IFCHR
#define DT_BLK S_IFBLK
#define DT_LNK S_IFLNK

/* Macros for converting between st_mode and d_type */
#define IFTODT(mode) ((mode) &amp; S_IFMT)
#define DTTOIF(type) (type)

/*
 * File type macros.  Note that block devices, sockets and links cannot be
 * distinguished on Windows and the macros S_ISBLK, S_ISSOCK and S_ISLNK are
 * only defined for compatibility.  These macros should always return false
 * on Windows.
 */
#if !defined(S_ISFIFO)
#   define S_ISFIFO(mode) (((mode) &amp; S_IFMT) == S_IFIFO)
#endif
#if !defined(S_ISDIR)
#   define S_ISDIR(mode) (((mode) &amp; S_IFMT) == S_IFDIR)
#endif
#if !defined(S_ISREG)
#   define S_ISREG(mode) (((mode) &amp; S_IFMT) == S_IFREG)
#endif
#if !defined(S_ISLNK)
#   define S_ISLNK(mode) (((mode) &amp; S_IFMT) == S_IFLNK)
#endif
#if !defined(S_ISSOCK)
#   define S_ISSOCK(mode) (((mode) &amp; S_IFMT) == S_IFSOCK)
#endif
#if !defined(S_ISCHR)
#   define S_ISCHR(mode) (((mode) &amp; S_IFMT) == S_IFCHR)
#endif
#if !defined(S_ISBLK)
#   define S_ISBLK(mode) (((mode) &amp; S_IFMT) == S_IFBLK)
#endif

/* Return the exact length of d_namlen without zero terminator */
#define _D_EXACT_NAMLEN(p) ((p)-&gt;d_namlen)

/* Return number of bytes needed to store d_namlen */
#define _D_ALLOC_NAMLEN(p) (PATH_MAX)


#ifdef __cplusplus
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205632.15">extern "C" {
#endif


/* Wide-character version */
struct _wdirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    wchar_t d_name[PATH_MAX];
};
typedef struct _wdirent _wdirent;

struct _WDIR {
    /* Current directory entry */
    struct _wdirent ent;

    /* Private file data */
    WIN32_FIND_DATAW data;

    /* True if data is valid */
    int cached;

    /* Win32 search handle */
    HANDLE handle;

    /* Initial directory name */
    wchar_t *patt;
};
typedef struct _WDIR _WDIR;

static _WDIR *_wopendir (const wchar_t *dirname);
static struct _wdirent *_wreaddir (_WDIR *dirp);
static int _wclosedir (_WDIR *dirp);
static void _wrewinddir (_WDIR* dirp);


/* For compatibility with Symbian */
#define wdirent _wdirent
#define WDIR _WDIR
#define wopendir _wopendir
#define wreaddir _wreaddir
#define wclosedir _wclosedir
#define wrewinddir _wrewinddir


/* Multi-byte character versions */
struct dirent {
    /* Always zero */
    long d_ino;

    /* Structure size */
    unsigned short d_reclen;

    /* Length of name without \0 */
    size_t d_namlen;

    /* File type */
    int d_type;

    /* File name */
    char d_name[PATH_MAX];
};
typedef struct dirent dirent;

struct DIR {
    struct dirent ent;
    struct _WDIR *wdirp;
};
typedef struct DIR DIR;

static DIR *opendir (const char *dirname);
static struct dirent *readdir (DIR *dirp);
static int closedir (DIR *dirp);
static void rewinddir (DIR* dirp);


/* Internal utility functions */
static WIN32_FIND_DATAW *dirent_first (_WDIR *dirp);
static WIN32_FIND_DATAW *dirent_next (_WDIR *dirp);

static int dirent_mbstowcs_s(
    const wchar_t *wcstr,
_wopendir(
    @others
}
#endif
#endif /*DIRENT_H*/

</t>
<t tx="leo.20220407205632.16">    const wchar_t *dirname)
{
    _WDIR *dirp = NULL;
    int error;

    /* Must have directory name */
    if (dirname == NULL  ||  dirname[0] == '\0') {
        dirent_set_errno (ENOENT);
        return NULL;
    }

    /* Allocate new _WDIR structure */
    dirp = (_WDIR*) malloc (sizeof (struct _WDIR));
    if (dirp != NULL) {
        DWORD n;

        /* Reset _WDIR structure */
        dirp-&gt;handle = INVALID_HANDLE_VALUE;
        dirp-&gt;patt = NULL;
        dirp-&gt;cached = 0;

        /* Compute the length of full path plus zero terminator */
        n = GetFullPathNameW (dirname, 0, NULL, NULL);

        /* Allocate room for absolute directory name and search pattern */
        dirp-&gt;patt = (wchar_t*) malloc (sizeof (wchar_t) * n + 16);
        if (dirp-&gt;patt) {

            /*
             * Convert relative directory name to an absolute one.  This
             * allows rewinddir() to function correctly even when current
             * working directory is changed between opendir() and rewinddir().
             */
            n = GetFullPathNameW (dirname, n, dirp-&gt;patt, NULL);
            if (n &gt; 0) {
                wchar_t *p;

                /* Append search pattern \* to the directory name */
                p = dirp-&gt;patt + n;
                if (dirp-&gt;patt &lt; p) {
                    switch (p[-1]) {
                    case '\\':
                    case '/':
                    case ':':
                        /* Directory ends in path separator, e.g. c:\temp\ */
                        /*NOP*/;
                        break;

                    default:
                        /* Directory name doesn't end in path separator */
                        *p++ = '\\';
                    }
                }
                *p++ = '*';
                *p = '\0';

                /* Open directory stream and retrieve the first entry */
                if (dirent_first (dirp)) {
                    /* Directory stream opened successfully */
                    error = 0;
                } else {
                    /* Cannot retrieve first entry */
                    error = 1;
                    dirent_set_errno (ENOENT);
                }

            } else {
                /* Cannot retrieve full path name */
                dirent_set_errno (ENOENT);
                error = 1;
            }

        } else {
            /* Cannot allocate memory for search pattern */
            error = 1;
        }

    } else {
        /* Cannot allocate _WDIR structure */
        error = 1;
    }

    /* Clean up in case of error */
    if (error  &amp;&amp;  dirp) {
        _wclosedir (dirp);
        dirp = NULL;
    }

    return dirp;
}

/*
 * Read next directory entry.  The directory entry is returned in dirent
 * structure in the d_name field.  Individual directory entries returned by
 * this function include regular files, sub-directories, pseudo-directories
 * "." and ".." as well as volume labels, hidden files and system files.
 */
</t>
<t tx="leo.20220407205632.17">static struct _wdirent*
_wreaddir(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *datap;
    struct _wdirent *entp;

    /* Read next directory entry */
    datap = dirent_next (dirp);
    if (datap) {
        size_t n;
        DWORD attr;
        
        /* Pointer to directory entry to return */
        entp = &amp;dirp-&gt;ent;

        /* 
         * Copy file name as wide-character string.  If the file name is too
         * long to fit in to the destination buffer, then truncate file name
         * to PATH_MAX characters and zero-terminate the buffer.
         */
        n = 0;
        while (n + 1 &lt; PATH_MAX  &amp;&amp;  datap-&gt;cFileName[n] != 0) {
            entp-&gt;d_name[n] = datap-&gt;cFileName[n];
            n++;
        }
        dirp-&gt;ent.d_name[n] = 0;

        /* Length of file name excluding zero terminator */
        entp-&gt;d_namlen = n;

        /* File type */
        attr = datap-&gt;dwFileAttributes;
        if ((attr &amp; FILE_ATTRIBUTE_DEVICE) != 0) {
            entp-&gt;d_type = DT_CHR;
        } else if ((attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
            entp-&gt;d_type = DT_DIR;
        } else {
            entp-&gt;d_type = DT_REG;
        }

        /* Reset dummy fields */
        entp-&gt;d_ino = 0;
        entp-&gt;d_reclen = sizeof (struct _wdirent);

    } else {

        /* Last directory entry read */
        entp = NULL;

    }

    return entp;
}

/*
 * Close directory stream opened by opendir() function.  This invalidates the
 * DIR structure as well as any directory entry read previously by
 * _wreaddir().
 */
</t>
<t tx="leo.20220407205632.18">static int
_wclosedir(
    _WDIR *dirp)
{
    int ok;
    if (dirp) {

        /* Release search handle */
        if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
            FindClose (dirp-&gt;handle);
            dirp-&gt;handle = INVALID_HANDLE_VALUE;
        }

        /* Release search pattern */
        if (dirp-&gt;patt) {
            free (dirp-&gt;patt);
            dirp-&gt;patt = NULL;
        }

        /* Release directory structure */
        free (dirp);
        ok = /*success*/0;

    } else {
        /* Invalid directory stream */
        dirent_set_errno (EBADF);
        ok = /*failure*/-1;
    }
    return ok;
}

/*
 * Rewind directory stream such that _wreaddir() returns the very first
 * file name again.
 */
</t>
<t tx="leo.20220407205632.19">static void
_wrewinddir(
    _WDIR* dirp)
{
    if (dirp) {
        /* Release existing search handle */
        if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {
            FindClose (dirp-&gt;handle);
        }

        /* Open new search handle */
        dirent_first (dirp);
    }
}

/* Get first directory entry (internal) */
</t>
<t tx="leo.20220407205632.2">float CStackNumber::getFloatValue()
{
    return((float)_value);
}

</t>
<t tx="leo.20220407205632.20">static WIN32_FIND_DATAW*
dirent_first(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *datap;

    /* Open directory and retrieve the first entry */
    dirp-&gt;handle = FindFirstFileW (dirp-&gt;patt, &amp;dirp-&gt;data);
    if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {

        /* a directory entry is now waiting in memory */
        datap = &amp;dirp-&gt;data;
        dirp-&gt;cached = 1;

    } else {

        /* Failed to re-open directory: no directory entry in memory */
        dirp-&gt;cached = 0;
        datap = NULL;

    }
    return datap;
}

/* Get next directory entry (internal) */
</t>
<t tx="leo.20220407205632.21">static WIN32_FIND_DATAW*
dirent_next(
    _WDIR *dirp)
{
    WIN32_FIND_DATAW *p;

    /* Get next directory entry */
    if (dirp-&gt;cached != 0) {

        /* A valid directory entry already in memory */
        p = &amp;dirp-&gt;data;
        dirp-&gt;cached = 0;

    } else if (dirp-&gt;handle != INVALID_HANDLE_VALUE) {

        /* Get the next directory entry from stream */
        if (FindNextFileW (dirp-&gt;handle, &amp;dirp-&gt;data) != FALSE) {
            /* Got a file */
            p = &amp;dirp-&gt;data;
        } else {
            /* The very last entry has been processed or an error occured */
            FindClose (dirp-&gt;handle);
            dirp-&gt;handle = INVALID_HANDLE_VALUE;
            p = NULL;
        }

    } else {

        /* End of directory stream reached */
        p = NULL;

    }

    return p;
}

/* 
 * Open directory stream using plain old C-string.
 */
</t>
<t tx="leo.20220407205632.22">static DIR*
opendir(
    const char *dirname) 
{
    struct DIR *dirp;
    int error;

    /* Must have directory name */
    if (dirname == NULL  ||  dirname[0] == '\0') {
        dirent_set_errno (ENOENT);
        return NULL;
    }

    /* Allocate memory for DIR structure */
    dirp = (DIR*) malloc (sizeof (struct DIR));
    if (dirp) {
        wchar_t wname[PATH_MAX];
        size_t n;

        /* Convert directory name to wide-character string */
        error = dirent_mbstowcs_s (&amp;n, wname, PATH_MAX, dirname, PATH_MAX);
        if (!error) {

            /* Open directory stream using wide-character name */
            dirp-&gt;wdirp = _wopendir (wname);
            if (dirp-&gt;wdirp) {
                /* Directory stream opened */
                error = 0;
            } else {
                /* Failed to open directory stream */
                error = 1;
            }

        } else {
            /* 
             * Cannot convert file name to wide-character string.  This
             * occurs if the string contains invalid multi-byte sequences or
             * the output buffer is too small to contain the resulting
             * string.
             */
            error = 1;
        }

    } else {
        /* Cannot allocate DIR structure */
        error = 1;
    }

    /* Clean up in case of error */
    if (error  &amp;&amp;  dirp) {
        free (dirp);
        dirp = NULL;
    }

    return dirp;
}

/*
 * Read next directory entry.
 *
 * When working with text consoles, please note that file names returned by
 * readdir() are represented in the default ANSI code page while any output to
 * console is typically formatted on another code page.  Thus, non-ASCII
 * characters in file names will not usually display correctly on console.  The
 * problem can be fixed in two ways: (1) change the character set of console
 * to 1252 using chcp utility and use Lucida Console font, or (2) use
 * _cprintf function when writing to console.  The _cprinf() will re-encode
 * ANSI strings to the console code page so many non-ASCII characters will
 * display correcly.
 */
</t>
<t tx="leo.20220407205632.23">static struct dirent*
readdir(
    DIR *dirp) 
{
    WIN32_FIND_DATAW *datap;
    struct dirent *entp;

    /* Read next directory entry */
    datap = dirent_next (dirp-&gt;wdirp);
    if (datap) {
        size_t n;
        int error;

        /* Attempt to convert file name to multi-byte string */
        error = dirent_wcstombs_s(
            &amp;n, dirp-&gt;ent.d_name, PATH_MAX, datap-&gt;cFileName, PATH_MAX);

        /* 
         * If the file name cannot be represented by a multi-byte string,
         * then attempt to use old 8+3 file name.  This allows traditional
         * Unix-code to access some file names despite of unicode
         * characters, although file names may seem unfamiliar to the user.
         *
         * Be ware that the code below cannot come up with a short file
         * name unless the file system provides one.  At least
         * VirtualBox shared folders fail to do this.
         */
        if (error  &amp;&amp;  datap-&gt;cAlternateFileName[0] != '\0') {
            error = dirent_wcstombs_s(
                &amp;n, dirp-&gt;ent.d_name, PATH_MAX, 
                datap-&gt;cAlternateFileName, PATH_MAX);
        }

        if (!error) {
            DWORD attr;

            /* Initialize directory entry for return */
            entp = &amp;dirp-&gt;ent;

            /* Length of file name excluding zero terminator */
            entp-&gt;d_namlen = n - 1;

            /* File attributes */
            attr = datap-&gt;dwFileAttributes;
            if ((attr &amp; FILE_ATTRIBUTE_DEVICE) != 0) {
                entp-&gt;d_type = DT_CHR;
            } else if ((attr &amp; FILE_ATTRIBUTE_DIRECTORY) != 0) {
                entp-&gt;d_type = DT_DIR;
            } else {
                entp-&gt;d_type = DT_REG;
            }

            /* Reset dummy fields */
            entp-&gt;d_ino = 0;
            entp-&gt;d_reclen = sizeof (struct dirent);

        } else {
            /* 
             * Cannot convert file name to multi-byte string so construct
             * an errornous directory entry and return that.  Note that
             * we cannot return NULL as that would stop the processing
             * of directory entries completely.
             */
            entp = &amp;dirp-&gt;ent;
            entp-&gt;d_name[0] = '?';
            entp-&gt;d_name[1] = '\0';
            entp-&gt;d_namlen = 1;
            entp-&gt;d_type = DT_UNKNOWN;
            entp-&gt;d_ino = 0;
            entp-&gt;d_reclen = 0;
        }

    } else {
        /* No more directory entries */
        entp = NULL;
    }

    return entp;
}

/*
 * Close directory stream.
 */
</t>
<t tx="leo.20220407205632.24">static int
closedir(
    DIR *dirp) 
{
    int ok;
    if (dirp) {

        /* Close wide-character directory stream */
        ok = _wclosedir (dirp-&gt;wdirp);
        dirp-&gt;wdirp = NULL;

        /* Release multi-byte character version */
        free (dirp);

    } else {

        /* Invalid directory stream */
        dirent_set_errno (EBADF);
        ok = /*failure*/-1;

    }
    return ok;
}

/*
 * Rewind directory stream to beginning.
 */
</t>
<t tx="leo.20220407205632.25">static void
rewinddir(
    DIR* dirp) 
{
    /* Rewind wide-character string directory stream */
    _wrewinddir (dirp-&gt;wdirp);
}

/* Convert multi-byte string to wide character string */
</t>
<t tx="leo.20220407205632.26">static int
dirent_mbstowcs_s(
    size_t *pReturnValue,
    wchar_t *wcstr,
    size_t sizeInWords,
    const char *mbstr,
    size_t count)
{
    int error;

#if defined(_MSC_VER)  &amp;&amp;  _MSC_VER &gt;= 1400

    /* Microsoft Visual Studio 2005 or later */
    error = mbstowcs_s (pReturnValue, wcstr, sizeInWords, mbstr, count);

#else

    /* Older Visual Studio or non-Microsoft compiler */
    size_t n;

    /* Convert to wide-character string (or count characters) */
    n = mbstowcs (wcstr, mbstr, sizeInWords);
    if (!wcstr  ||  n &lt; count) {

        /* Zero-terminate output buffer */
        if (wcstr  &amp;&amp;  sizeInWords) {
            if (n &gt;= sizeInWords) {
                n = sizeInWords - 1;
            }
            wcstr[n] = 0;
        }

        /* Length of resuting multi-byte string WITH zero terminator */
        if (pReturnValue) {
            *pReturnValue = n + 1;
        }

        /* Success */
        error = 0;

    } else {

        /* Could not convert string */
        error = 1;

    }

#endif

    return error;
}

/* Convert wide-character string to multi-byte string */
</t>
<t tx="leo.20220407205632.27">static int
dirent_wcstombs_s(
    size_t *pReturnValue,
    char *mbstr,
    size_t sizeInBytes, /* max size of mbstr */
    const wchar_t *wcstr,
    size_t count)
{
    int error;

#if defined(_MSC_VER)  &amp;&amp;  _MSC_VER &gt;= 1400

    /* Microsoft Visual Studio 2005 or later */
    error = wcstombs_s (pReturnValue, mbstr, sizeInBytes, wcstr, count);

#else

    /* Older Visual Studio or non-Microsoft compiler */
    size_t n;

    /* Convert to multi-byte string (or count the number of bytes needed) */
    n = wcstombs (mbstr, wcstr, sizeInBytes);
    if (!mbstr  ||  n &lt; count) {

        /* Zero-terminate output buffer */
        if (mbstr  &amp;&amp;  sizeInBytes) {
            if (n &gt;= sizeInBytes) {
                n = sizeInBytes - 1;
            }
            mbstr[n] = '\0';
        }

        /* Lenght of resulting multi-bytes string WITH zero-terminator */
        if (pReturnValue) {
            *pReturnValue = n + 1;
        }

        /* Success */
        error = 0;

    } else {

        /* Cannot convert string */
        error = 1;

    }

#endif

    return error;
}

/* Set errno variable */
</t>
<t tx="leo.20220407205632.28">static void
dirent_set_errno(
    int error)
{
#if defined(_MSC_VER)  &amp;&amp;  _MSC_VER &gt;= 1400

    /* Microsoft Visual Studio 2005 and later */
    _set_errno (error);

#else

    /* Non-Microsoft compiler or older Microsoft compiler */
    errno = error;

#endif
}


#ifdef __cplusplus
</t>
<t tx="leo.20220407205632.29">@path ./v-rep_plugin/coppelia/include/
#pragma once

#include "luaFunctionDataItem.h"
#include "simLib.h"

#define SIM_LUA_ARG_NIL_ALLOWED (65536)

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.3">int CStackNumber::getIntValue()
{
    return((int)_value);
}

long CStackNumber::getLongValue()
{
    return((long)_value);
}

double CStackNumber::getValue()
{
    return(_value);
}

</t>
<t tx="leo.20220407205632.30">class CLuaFunctionData  
{
public:
    CLuaFunctionData();
    virtual ~CLuaFunctionData();

    //------------------------
    static void getInputDataForFunctionRegistration(const int* dat,std::vector&lt;int&gt;&amp; outDat);
    bool readDataFromLua(const SLuaCallBack* p,const int* expectedArguments,int requiredArgumentCount,const char* functionName);
    std::vector&lt;CLuaFunctionDataItem&gt;* getInDataPtr();
    void pushOutData(const CLuaFunctionDataItem&amp; dataItem);
    void writeDataToLua(SLuaCallBack* p);
    //------------------------


    //------------------------
    void pushOutData_luaFunctionCall(const CLuaFunctionDataItem&amp; dataItem);
    void writeDataToLua_luaFunctionCall(SLuaCallBack* p,const int* expectedArguments);
    bool readDataFromLua_luaFunctionCall(const SLuaCallBack* p,const int* expectedArguments,int requiredArgumentCount,const char* functionName);
    std::vector&lt;CLuaFunctionDataItem&gt;* getOutDataPtr_luaFunctionCall();
    void releaseBuffers_luaFunctionCall(SLuaCallBack* p);
    //------------------------



protected:
    std::vector&lt;CLuaFunctionDataItem&gt; _inData;
    std::vector&lt;CLuaFunctionDataItem&gt; _outData;
};
</t>
<t tx="leo.20220407205632.31">@path ./v-rep_plugin/coppelia/include/
#pragma once

#include &lt;vector&gt;
#include &lt;string&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.32">class CLuaFunctionDataItem
{
public:
    CLuaFunctionDataItem();
    CLuaFunctionDataItem(bool v);
    CLuaFunctionDataItem(int v);
    CLuaFunctionDataItem(float v);
    CLuaFunctionDataItem(double v);
    CLuaFunctionDataItem(const std::string&amp; v);
    CLuaFunctionDataItem(const char* bufferPtr,unsigned int bufferLength);

    CLuaFunctionDataItem(const std::vector&lt;bool&gt;&amp; v);
    CLuaFunctionDataItem(const std::vector&lt;int&gt;&amp; v);
    CLuaFunctionDataItem(const std::vector&lt;float&gt;&amp; v);
    CLuaFunctionDataItem(const std::vector&lt;double&gt;&amp; v);
    CLuaFunctionDataItem(const std::vector&lt;std::string&gt;&amp; v);

    virtual ~CLuaFunctionDataItem();

    bool isTable();
    int getType();
    void setNilTable(int size);
    int getNilTableSize();

    std::vector&lt;bool&gt; boolData;
    std::vector&lt;int&gt; intData;
    std::vector&lt;float&gt; floatData;
    std::vector&lt;double&gt; doubleData;
    std::vector&lt;std::string&gt; stringData;

protected:
    int _nilTableSize;
    bool _isTable;
    int _type; // -1=nil,0=bool,1=int,2=float,3=string,4=buffer,5=double
};
</t>
<t tx="leo.20220407205632.33">@path ./v-rep_plugin/coppelia/include/
#pragma once

#include "scriptFunctionDataItem.h"
#include "simLib.h"

#define SIM_SCRIPT_ARG_NULL_ALLOWED (65536)

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.34">class CScriptFunctionData  
{
public:
    CScriptFunctionData();
    virtual ~CScriptFunctionData();

    //------------------------
    // Use following to read args coming from a script call to this plugin, and to return args back to a script
    bool readDataFromStack(int stackHandle,const int* expectedArguments,int requiredArgumentCount,const char* functionName);
    std::vector&lt;CScriptFunctionDataItem&gt;* getInDataPtr();
    void pushOutData(const CScriptFunctionDataItem&amp; dataItem);
    void writeDataToStack(int stackHandle);
    //------------------------


    //------------------------
    // Use following to write args for a script function call, and to read the return values from that script function call
    void pushOutData_scriptFunctionCall(const CScriptFunctionDataItem&amp; dataItem);
    void writeDataToStack_scriptFunctionCall(int stackHandle);
    bool readDataFromStack_scriptFunctionCall(int stackHandle,const int* expectedArguments,int requiredArgumentCount,const char* functionName);
    std::vector&lt;CScriptFunctionDataItem&gt;* getOutDataPtr_scriptFunctionCall();
    //------------------------

protected:
    bool _readData(int stack,const int* expectedArguments,int requiredArgumentCount,const char* functionName,const char* argumentText1,const char* argumentText2,std::vector&lt;CScriptFunctionDataItem&gt;&amp; inOutData);
    void _writeData(int stack,std::vector&lt;CScriptFunctionDataItem&gt;&amp; inOutData);

    std::vector&lt;CScriptFunctionDataItem&gt; _inData;
    std::vector&lt;CScriptFunctionDataItem&gt; _outData;
};
</t>
<t tx="leo.20220407205632.35">@path ./v-rep_plugin/coppelia/include/
#pragma once

#include &lt;vector&gt;
#include &lt;string&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.36">class CScriptFunctionDataItem
{
public:
    CScriptFunctionDataItem();
    CScriptFunctionDataItem(bool v);
    CScriptFunctionDataItem(int v);
    CScriptFunctionDataItem(float v);
    CScriptFunctionDataItem(double v);
    CScriptFunctionDataItem(const std::string&amp; str);
    CScriptFunctionDataItem(const char* str);
    CScriptFunctionDataItem(const char* bufferPtr,unsigned int bufferLength);

    CScriptFunctionDataItem(const std::vector&lt;bool&gt;&amp; v);
    CScriptFunctionDataItem(const std::vector&lt;int&gt;&amp; v);
    CScriptFunctionDataItem(const std::vector&lt;float&gt;&amp; v);
    CScriptFunctionDataItem(const std::vector&lt;double&gt;&amp; v);
    CScriptFunctionDataItem(const std::vector&lt;std::string&gt;&amp; v);

    virtual ~CScriptFunctionDataItem();

    bool isTable();
    int getType();
    void setNilTable(int size);
    int getNilTableSize();

    std::vector&lt;bool&gt; boolData;
    std::vector&lt;int&gt; int32Data;
    std::vector&lt;float&gt; floatData;
    std::vector&lt;double&gt; doubleData;
    std::vector&lt;std::string&gt; stringData;

protected:
    int _nilTableSize;
    bool _isTable;
    int _type; // -1=nil,0=bool,1=int32,2=float,3=string,4=buffer,5=double
};
</t>
<t tx="leo.20220407205632.37">@path ./v-rep_plugin/coppelia/include/
// This file, and generally the shared memory part of the remote API
// are courtesy of Benjamin Navarro

#pragma once

#include &lt;stddef.h&gt;
#include &lt;stdbool.h&gt;

#ifdef _WIN32
typedef void* shm_handle_t;
#elif defined (__linux) || defined (__APPLE__)
typedef int shm_handle_t;
#endif /* _WIN32 */

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.38">typedef struct
{
    char name[28];
    shm_handle_t handle;
    size_t header_size;
    size_t size;
    unsigned char* buffer;
} shared_memory_info_t;

#ifdef __cplusplus
</t>
<t tx="leo.20220407205632.39">extern "C" {
#endif

bool create_shared_memory(shared_memory_info_t* info);
bool destroy_shared_memory(shared_memory_info_t* info);
bool open_shared_memory(shared_memory_info_t* info);
bool close_shared_memory(shared_memory_info_t* info);
bool map_shared_memory(shared_memory_info_t* info);
bool unmap_shared_memory(shared_memory_info_t* info);
void set_shared_memory_name(shared_memory_info_t* info, int identifier);
void set_shared_memory_size(shared_memory_info_t* info, size_t size);
bool is_valid_shared_memory_handle(shared_memory_info_t* info);

#ifdef __cplusplus
}
#endif
</t>
<t tx="leo.20220407205632.4">void CStackNumber::setFloatValue(float n)
{
    _value=(double)n;
}

</t>
<t tx="leo.20220407205632.40">@path ./v-rep_plugin/coppelia/include/
#if !defined(SIMCONST_INCLUDED_)
#define SIMCONST_INCLUDED_

#define SIM_PROGRAM_VERSION_NB 40000
#define SIM_PROGRAM_VERSION "4.0.0."

#define SIM_PROGRAM_REVISION_NB 4
#define SIM_PROGRAM_REVISION "(rev. 4)"

#define SIM_PROGRAM_FULL_VERSION_NB ((SIM_PROGRAM_VERSION_NB) * 100 + (SIM_PROGRAM_REVISION_NB))

/* Scene object types. Values are serialized */
enum {
        sim_object_shape_type=0,
        sim_object_joint_type,
        sim_object_graph_type,
        sim_object_camera_type,
        sim_object_dummy_type,
        sim_object_proximitysensor_type,
        sim_object_reserved1,
        sim_object_reserved2,
        sim_object_path_type,
        sim_object_visionsensor_type,
        sim_object_reserved3,
        sim_object_mill_type,
        sim_object_forcesensor_type,
        sim_object_light_type,
        sim_object_mirror_type,
        sim_object_octree_type,
        sim_object_pointcloud_type,
        sim_object_type_end=sim_object_path_type+100
};

/* General object types. Values are serialized */
enum {
    sim_appobj_object_type=sim_object_type_end+1,
    sim_appobj_collision_type,
    sim_appobj_distance_type,
    sim_appobj_simulation_type,
    sim_appobj_ik_type,
    sim_appobj_constraintsolver_type,
    sim_appobj_collection_type,
    sim_appobj_ui_type,
    sim_appobj_script_type,
    sim_appobj_pathplanning_type,
    sim_appobj_RESERVED_type,
    sim_appobj_texture_type,
    sim_appobj_motionplanning_type
};

/* Ik calculation methods. Values are serialized */
enum {
        sim_ik_pseudo_inverse_method=0,
        sim_ik_damped_least_squares_method,
        sim_ik_jacobian_transpose_method
};

/* Ik constraints. Values are serialized */
enum {
        sim_ik_x_constraint=1,
        sim_ik_y_constraint=2,
        sim_ik_z_constraint=4,
        sim_ik_alpha_beta_constraint=8,
        sim_ik_gamma_constraint=16,
        sim_ik_avoidance_constraint=64
};

/* Ik calculation results */
enum {
    sim_ikresult_not_performed=0,
    sim_ikresult_success,
    sim_ikresult_fail
};

/* Scene object sub-types. Values are serialized */
enum {
        /* Light sub-types: */
        sim_light_omnidirectional_subtype=1,
        sim_light_spot_subtype,
        sim_light_directional_subtype,
        /* Joint sub-types: */
        sim_joint_revolute_subtype=10,
        sim_joint_prismatic_subtype,
        sim_joint_spherical_subtype,
        /* Shape sub-types: */
        sim_shape_simpleshape_subtype=20,
        sim_shape_multishape_subtype,
        /* Proximity sensor sub-types: */
        sim_proximitysensor_pyramid_subtype=30,
        sim_proximitysensor_cylinder_subtype,
        sim_proximitysensor_disc_subtype,
        sim_proximitysensor_cone_subtype,
        sim_proximitysensor_ray_subtype,
        /* Mill sub-types: */
        sim_mill_pyramid_subtype=40,
        sim_mill_cylinder_subtype,
        sim_mill_disc_subtype,
        sim_mill_cone_subtype,
        /* No sub-type: */
        sim_object_no_subtype=200
};

enum { /* Scene object main properties (serialized): */
        sim_objectspecialproperty_collidable                    =0x0001,
        sim_objectspecialproperty_measurable                    =0x0002,
        /*reserved                      =0x0004, */
        /*reserved                      =0x0008, */
        sim_objectspecialproperty_detectable_ultrasonic         =0x0010,
        sim_objectspecialproperty_detectable_infrared           =0x0020,
        sim_objectspecialproperty_detectable_laser              =0x0040,
        sim_objectspecialproperty_detectable_inductive          =0x0080,
        sim_objectspecialproperty_detectable_capacitive         =0x0100,
        sim_objectspecialproperty_renderable                    =0x0200,
        sim_objectspecialproperty_detectable_all                =sim_objectspecialproperty_detectable_ultrasonic|sim_objectspecialproperty_detectable_infrared|sim_objectspecialproperty_detectable_laser|sim_objectspecialproperty_detectable_inductive|sim_objectspecialproperty_detectable_capacitive,
        sim_objectspecialproperty_cuttable                      =0x0400,
        sim_objectspecialproperty_pathplanning_ignored          =0x0800
};

enum { /* Model properties (serialized): */
        sim_modelproperty_not_collidable                =0x0001,
        sim_modelproperty_not_measurable                =0x0002,
        sim_modelproperty_not_renderable                =0x0004,
        sim_modelproperty_not_detectable                =0x0008,
        sim_modelproperty_not_cuttable                  =0x0010,
        sim_modelproperty_not_dynamic                   =0x0020,
        sim_modelproperty_not_respondable               =0x0040, /* cannot be selected if sim_modelproperty_not_dynamic is not selected */
        sim_modelproperty_not_reset                     =0x0080, /* Model is not reset at simulation end. This flag is cleared at simulation end */
        sim_modelproperty_not_visible                   =0x0100, /* Whole model is invisible, independent of local visibility settings */
        sim_modelproperty_scripts_inactive              =0x0200, /* All scripts in the model will not be executed */
        sim_modelproperty_not_showasinsidemodel         =0x0400, /* Whole model is invisible to any model bounding box */
        sim_modelproperty_not_model                     =0xf000  /* object is not a model */
};

enum { /* Check the documentation instead of comments below!! */
        /* Following messages are dispatched to the Lua-message container: */
        sim_message_ui_button_state_change=0,   /* a UI button, slider, etc. changed (due to a user's action). aux[0]=UI handle, aux[1]=button handle, aux[2]=button attributes, aux[3]=slider position (if slider) */
        sim_message_reserved9,                  /* Do not use */
        sim_message_object_selection_changed,
        sim_message_reserved10,                 /* do not use */
        sim_message_model_loaded,
        sim_message_reserved11,                 /* do not use */
        sim_message_keypress,                   /* a key was pressed while the focus was on a page (aux[0]=key, aux[1]=ctrl and shift key state) */
        sim_message_bannerclicked,              /* a banner was clicked (aux[0]=banner ID) */
        sim_message_scene_loaded,               /* a scene was loaded */

        sim_message_prox_sensor_select_down,    /* a "geometric" click select (mouse down) was registered. Enable with sim_intparam_prox_sensor_select_down. aux[0]=objectID, aux2[0-2]=pt coord, aux2[3-5]=pt normal vector */
        sim_message_prox_sensor_select_up,      /* a "geometric" click select (mouse up) was registered. Enable with sim_intparam_prox_sensor_select_up. aux[0]=objectID, aux2[0-2]=pt coord, aux2[3-5]=pt normal vector */
        sim_message_pick_select_down,           /* a "pick" click select (mouse down) was registered. aux[0]=objectID */


        /* Following messages are dispatched only to the C-API (not available from Lua): */
        sim_message_for_c_api_only_start=0x0100,            /* Do not use */
        sim_message_reserved1,                              /* Do not use */
        sim_message_reserved2,                              /* Do not use */
        sim_message_reserved3,                              /* Do not use */


        sim_message_eventcallback_scenesave,                /* about to save a scene */
        sim_message_eventcallback_modelsave,                /* about to save a model (current selection will be saved) */
        sim_message_eventcallback_moduleopen,               /* deprecated */
        sim_message_eventcallback_modulehandle,             /* deprecated */
        sim_message_eventcallback_moduleclose,              /* deprecated */
        sim_message_reserved4,                              /* Do not use */
        sim_message_reserved5,                              /* Do not use */
        sim_message_reserved6,                              /* Do not use */
        sim_message_reserved7,                              /* Do not use */
        sim_message_eventcallback_instancepass,             /* Called once every main application loop pass. auxiliaryData[0] contains event flags of events that happened since last time: */
                                                            /* bit0 set: object(s) erased */
                                                            /* bit1 set: object(s) created */
                                                            /* bit2 set: model loaded */
                                                            /* bit3 set: scene loaded */
                                                            /* bit4 set: undo called */
                                                            /* bit5 set: redo called */
                                                            /* bit6 set: scene switched (similar to scene loaded, basically: scene content completely changed) */
                                                            /* bit7 set: edit mode active. This is not an event flag, but a state flag */
                                                            /* bit8 set: object(s) scaled */
                                                            /* bit9 set: selection state changed. (different objects are selected now) */
                                                            /* bit10 set: key pressed */
                                                            /* bit11 set: simulation started */
                                                            /* bit12 set: simulation ended */

        sim_message_eventcallback_broadcast, /* deprecated */
        sim_message_eventcallback_imagefilter_enumreset, /* deprecated */
        sim_message_eventcallback_imagefilter_enumerate, /* deprecated */
        sim_message_eventcallback_imagefilter_adjustparams, /* deprecated */
        sim_message_eventcallback_imagefilter_reserved, /* deprecated */
        sim_message_eventcallback_imagefilter_process, /* deprecated */

        sim_message_eventcallback_reserved1, /* do not use */
        sim_message_eventcallback_reserved2, /* do not use */
        sim_message_eventcallback_reserved3, /* do not use */
        sim_message_eventcallback_reserved4, /* do not use */

        sim_message_eventcallback_abouttoundo,      /* the undo button was hit and a previous state is about to be restored */
        sim_message_eventcallback_undoperformed,    /* the undo button was hit and a previous state restored */
        sim_message_eventcallback_abouttoredo,      /* the redo button was hit and a future state is about to be restored  */
        sim_message_eventcallback_redoperformed,    /* the redo button was hit and a future state restored  */
        sim_message_eventcallback_scripticondblclick, /* scipt icon was double clicked.  (aux[0]=object handle associated with script, set replyData[0] to 1 if script should not be opened)  */
        sim_message_eventcallback_simulationabouttostart,
        sim_message_eventcallback_simulationended,

        sim_message_eventcallback_reserved5,            /* do not use */
        sim_message_eventcallback_keypress,         /* a key was pressed while the focus was on a page (aux[0]=key, aux[1]=ctrl and shift key state) */
        sim_message_eventcallback_modulehandleinsensingpart, /* deprecated */

        sim_message_eventcallback_renderingpass, /* deprecated */
        sim_message_eventcallback_bannerclicked, /* called when a banner was clicked (aux[0]=banner ID) */
        sim_message_eventcallback_menuitemselected, /* auxiliaryData[0] indicates the handle of the item, auxiliaryData[1] indicates the state of the item */
        sim_message_eventcallback_refreshdialogs, /* aux[0]=refresh degree (0=light, 1=medium, 2=full) */
        sim_message_eventcallback_sceneloaded,
        sim_message_eventcallback_modelloaded,
        sim_message_eventcallback_instanceswitch,


        sim_message_eventcallback_guipass,
        sim_message_eventcallback_mainscriptabouttobecalled,

        sim_message_eventcallback_rmlposition, /* the command simRMLPosition was called. The appropriate plugin should handle the call */
        sim_message_eventcallback_rmlvelocity, /* the command simRMLVelocity was called. The appropriate plugin should handle the call */

        sim_message_eventcallback_reserved18,
        sim_message_eventcallback_reserved19,
        sim_message_eventcallback_pathplanningplugin, /* deprecated */
        sim_message_eventcallback_colladaplugin, /* to interact with the collada plugin */

        sim_message_eventcallback_opengl, /* deprecated */
        sim_message_eventcallback_openglframe, /* deprecated */
        sim_message_eventcallback_openglcameraview, /* deprecated */

        sim_message_eventcallback_proxsensorselectdown, /* a "geometric" click select (mouse down) was registered. Enable with sim_intparam_prox_sensor_select_down. aux[0]=objectID, customData[0-2]=pt coord (floats), customData[3-5]=pt normal vector (floats)*/
        sim_message_eventcallback_proxsensorselectup, /* a "geometric" click select (mouse up) was registered. Enable with sim_intparam_prox_sensor_select_down. aux[0]=objectID, customData[0-2]=pt coord (floats), customData[3-5]=pt normal vector (floats)*/
        sim_message_eventcallback_pickselectdown, /* a "pick" click select (mouse down) was registered. aux[0]=objectID */

        sim_message_eventcallback_rmlpos, /* the command simRMLPos was called. The appropriate plugin should handle the call */
        sim_message_eventcallback_rmlvel, /* the command simRMLVel was called. The appropriate plugin should handle the call */
        sim_message_eventcallback_rmlstep, /* the command simRMLStep was called. The appropriate plugin should handle the call */
        sim_message_eventcallback_rmlremove, /* the command simRMLRemove was called. The appropriate plugin should handle the call */
        sim_message_eventcallback_rmlinfo, /* used internally */

        sim_message_eventcallback_beforerendering, /* called just before the scene is rendered. From the main SIM thread! */

        sim_message_eventcallback_extrenderer_start,
        sim_message_eventcallback_extrenderer_light,
        sim_message_eventcallback_extrenderer_mesh,
        sim_message_eventcallback_extrenderer_stop,

        sim_message_eventcallback_reserved6,
        sim_message_eventcallback_reserved7,
        sim_message_eventcallback_reserved8,
        sim_message_eventcallback_reserved9,
        sim_message_eventcallback_reserved10,
        sim_message_eventcallback_reserved11,
        sim_message_eventcallback_reserved12,
        sim_message_eventcallback_reserved13,
        sim_message_eventcallback_reserved14,
        sim_message_eventcallback_reserved15,
        sim_message_eventcallback_reserved16,
        sim_message_eventcallback_reserved17,

        sim_message_eventcallback_extrenderer_triangles,
        sim_message_eventcallback_simulationabouttoend,
        sim_message_eventcallback_instanceabouttoswitch,

        sim_message_eventcallback_lastinstancepass,
        sim_message_eventcallback_uipass,             /* Called from the UI thread, just after sim_message_eventcallback_instancepass was called from the SIM thread */

        sim_message_simulation_start_resume_request=0x1000,
        sim_message_simulation_pause_request,
        sim_message_simulation_stop_request

};

// Rendering attributes:
enum {
        sim_displayattribute_renderpass     =0x0001,
        sim_displayattribute_depthpass      =0x0002,
        sim_displayattribute_pickpass       =0x0004,
        sim_displayattribute_selected       =0x0008,
        sim_displayattribute_groupselection =0x0010,
        sim_displayattribute_mainselection  =0x0020,
        sim_displayattribute_forcewireframe =0x0040,
        sim_displayattribute_forbidwireframe=0x0080,
        sim_displayattribute_forbidedges    =0x0100,
        sim_displayattribute_originalcolors =0x0200,
        sim_displayattribute_ignorelayer    =0x0400,
        sim_displayattribute_forvisionsensor    =0x0800,
        sim_displayattribute_colorcodedpickpass =0x1000,
        sim_displayattribute_colorcoded         =0x2000,
        sim_displayattribute_trianglewireframe  =0x4000,
        sim_displayattribute_inertiaonly        =0x8000,
        sim_displayattribute_thickEdges             =0x10000,
        sim_displayattribute_dynamiccontentonly     =0x20000,
        sim_displayattribute_mirror                 =0x40000,
        sim_displayattribute_useauxcomponent        =0x80000,
        sim_displayattribute_ignorerenderableflag   =0x100000,
        sim_displayattribute_noopenglcallbacks      =0x200000,
        sim_displayattribute_FREE                   =0x400000,
        sim_displayattribute_noghosts               =0x800000,
        sim_displayattribute_nopointclouds          =0x1000000,
        sim_displayattribute_nodrawingobjects       =0x2000000,
        sim_displayattribute_noparticles            =0x4000000,
        sim_displayattribute_colorcodedtriangles    =0x8000000
/*        sim_displayattribute_mode1                  =0x10000000,
        sim_displayattribute_mode2                  =0x20000000 */
};

enum { /* Scene object properties. Combine with the | operator */
    sim_objectproperty_reserved1    =0x0000,
    sim_objectproperty_reserved2    =0x0001,
    sim_objectproperty_reserved3    =0x0002,
    sim_objectproperty_reserved4    =0x0003,
    sim_objectproperty_reserved5    =0x0004, /* formely sim_objectproperty_visible */
    sim_objectproperty_reserved6    =0x0008, /* formely sim_objectproperty_wireframe */
    sim_objectproperty_collapsed                =0x0010,
    sim_objectproperty_selectable               =0x0020,
    sim_objectproperty_reserved7                =0x0040,
    sim_objectproperty_selectmodelbaseinstead   =0x0080,
    sim_objectproperty_dontshowasinsidemodel    =0x0100,
    /* reserved                                 =0x0200, */
    sim_objectproperty_canupdatedna             =0x0400,
    sim_objectproperty_selectinvisible          =0x0800,
    sim_objectproperty_depthinvisible           =0x1000,
    sim_objectproperty_cannotdelete             =0x2000,
    sim_objectproperty_cannotdeleteduringsim    =0x4000,
};

enum { /* DEPRECATED, check below */
    sim_lua_arg_nil=0,
    sim_lua_arg_bool,
    sim_lua_arg_int,
    sim_lua_arg_float,
    sim_lua_arg_string,
    sim_lua_arg_invalid,
    sim_lua_arg_charbuff,
    sim_lua_arg_double,
    sim_lua_arg_table=8
    /* SIM_LUA_ARG_NIL_ALLOWED=65536 is defined and used in CLuaFunctionData.h. This flag is reserved here. */
};

enum { /* type of arguments (input and output) for custom script commands */
    sim_script_arg_null=0,
    sim_script_arg_bool,
    sim_script_arg_int32,
    sim_script_arg_float,
    sim_script_arg_string,
    sim_script_arg_invalid,
    sim_script_arg_charbuff,
    sim_script_arg_double,
    sim_script_arg_table=8
    /* SIM_SCRIPT_ARG_NULL_ALLOWED=65536 is defined and used in CScriptFunctionData.h. This flag is reserved here. */
};

enum { /* OpenGl-based custom UI menu attributes: */
    sim_ui_menu_title       =1,
    sim_ui_menu_minimize    =2,
    sim_ui_menu_close       =4,
    sim_ui_menu_systemblock =8
};

enum { /* OpenGl-based custom UI properties. Values are serialized. */
    sim_ui_property_visible                     =0x0001,
    sim_ui_property_visibleduringsimulationonly =0x0002,
    sim_ui_property_moveable                    =0x0004,
    sim_ui_property_relativetoleftborder        =0x0008,
    sim_ui_property_relativetotopborder         =0x0010,
    sim_ui_property_fixedwidthfont              =0x0020,
    sim_ui_property_systemblock                 =0x0040,
    sim_ui_property_settocenter                 =0x0080,
    sim_ui_property_rolledup                    =0x0100,
    sim_ui_property_selectassociatedobject      =0x0200,
    sim_ui_property_visiblewhenobjectselected   =0x0400,
    sim_ui_property_systemblockcanmovetofront   =0x0800,
    sim_ui_property_pauseactive                 =0x1000
};

enum { /* button properties. Values are serialized. */
    sim_buttonproperty_button               =0x0000,
    sim_buttonproperty_label                =0x0001,
    sim_buttonproperty_slider               =0x0002,
    sim_buttonproperty_editbox              =0x0003,
    sim_buttonproperty_staydown             =0x0008,
    sim_buttonproperty_enabled              =0x0010,
    sim_buttonproperty_borderless           =0x0020,
    sim_buttonproperty_horizontallycentered =0x0040,
    sim_buttonproperty_ignoremouse          =0x0080,
    sim_buttonproperty_isdown               =0x0100,
    sim_buttonproperty_transparent          =0x0200,
    sim_buttonproperty_nobackgroundcolor    =0x0400,
    sim_buttonproperty_rollupaction         =0x0800,
    sim_buttonproperty_closeaction          =0x1000,
    sim_buttonproperty_verticallycentered   =0x2000,
    sim_buttonproperty_downupevent          =0x4000
};

enum { /* Simulation status */
    sim_simulation_stopped                      =0x00,                              /* Simulation is stopped */
    sim_simulation_paused                       =0x08,                              /* Simulation is paused */
    sim_simulation_advancing                    =0x10,                              /* Simulation is advancing */
    sim_simulation_advancing_firstafterstop     =sim_simulation_advancing|0x00,     /* First simulation pass (1x) */
    sim_simulation_advancing_running            =sim_simulation_advancing|0x01,     /* Normal simulation pass (&gt;=1x) */
    /* reserved                                 =sim_simulation_advancing|0x02, */
    sim_simulation_advancing_lastbeforepause    =sim_simulation_advancing|0x03,     /* Last simulation pass before pause (1x) */
    sim_simulation_advancing_firstafterpause    =sim_simulation_advancing|0x04,     /* First simulation pass after pause (1x) */
    sim_simulation_advancing_abouttostop        =sim_simulation_advancing|0x05,     /* "Trying to stop" simulation pass (&gt;=1x) */
    sim_simulation_advancing_lastbeforestop     =sim_simulation_advancing|0x06      /* Last simulation pass (1x) */
};

enum { /* Script execution result (first return value) */
    sim_script_no_error                 =0,
    sim_script_main_script_nonexistent  =1,
    sim_script_main_script_not_called   =2,
    sim_script_reentrance_error         =4,
    sim_script_lua_error                =8,
    sim_script_call_error               =16
};

enum { /* Script types (serialized!) */
    sim_scripttype_mainscript=0,
    sim_scripttype_childscript,
    sim_scripttype_addonscript,
    sim_scripttype_addonfunction,
    sim_scripttype_jointctrlcallback_old, /* deprecated */
    sim_scripttype_contactcallback_old, /* deprecated */
    sim_scripttype_customizationscript,
    sim_scripttype_generalcallback_old, /* deprecated */
    sim_scripttype_sandboxscript, /* special */
    sim_scripttype_threaded=0x00f0          /* Combine with sim_scripttype_childscript if you want */
};

enum { /* System callbacks */
    sim_syscb_init=0,
    sim_syscb_cleanup, /* last time called. Do some clean-up */
    sim_syscb_nonsimulation, /* called while simulation not running */
    sim_syscb_beforesimulation, /* called just before simulation starts */
    sim_syscb_aftersimulation, /* called just after simulation ended */
    sim_syscb_actuation, /* called in the "actuation" phase of the main script. Called only if the script is flagged as sim_customizationscriptattribute_activeduringsimulation */
    sim_syscb_sensing, /* called in the "sensing" phase of the main script. Called only if the script is flagged as sim_customizationscriptattribute_activeduringsimulation */
    sim_syscb_suspended, /* called while simulation is paused */
    sim_syscb_suspend, /* called just after a simulation was paused */
    sim_syscb_resume, /* called just before a simulation is unpaused */
    sim_syscb_beforeinstanceswitch, /* called just before an instance switch (switch to another scene) */
    sim_syscb_afterinstanceswitch, /* called just after an instance switch (switch to another scene) */
    sim_syscb_beforecopy, /* called just before objects are copied (in an object copy/cut operation, or a model save operation). Arg1 is a map with 'objectHandles' keys */
    sim_syscb_aftercopy, /* called just after objects were copied. Arg1 is a map with 'objectHandles' keys */
    sim_syscb_aos_run, /* special for add-on scripts */
    sim_syscb_aos_suspend, /* special for add-on scripts */
    sim_syscb_aos_resume, /* special for add-on scripts */
    sim_syscb_jointcallback, /* called by the physics engine for a dynamically enabled joint */
    sim_syscb_contactcallback, /* called by the physics engine when two respondable shapes are contacting */
    sim_syscb_customcallback1, /* custom call */
    sim_syscb_customcallback2, /* custom call */
    sim_syscb_customcallback3, /* custom call */
    sim_syscb_customcallback4, /* custom call */
    sim_syscb_beforedelete, /* called just before objects are deleted (in an object delete or cut operation). Arg1 is a map with 'objectHandles' and 'allObjects' keys */
    sim_syscb_afterdelete, /* called just after objects were deleted. Arg1 is a map with 'objectHandles' keys */
    sim_syscb_aftercreate, /* called just after objects were created/pasted/loaded. Not called for the created objects. Arg1 is a map with 'objectHandles' array */
    sim_syscb_threadmain, /* the main section of a threaded child script */
    sim_syscb_dyncallback, /* called by the physics engine twice per dyn. simulation pass */
    sim_syscb_beforemainscript, /* called in customization scripts just before calling the main script */
    sim_syscb_vision, /* called just after a vision sensor image was acquired, for processing */
    sim_syscb_trigger, /* called by vision, proximity or force/torque sensors when they trigger */
    sim_syscb_userconfig, /* called for the customization script, when the user double-clicks the script simulation parameters icon */
    sim_syscb_xr=sim_syscb_init+200, /* reserved for XR */
    sim_syscb_br=sim_syscb_xr, /* reserved for XR */
    /* sim_syscb_xrend=sim_syscb_xr+1000  reserved for XR */
};

enum { /* Script attributes */
    sim_customizationscriptattribute_activeduringsimulation=0, /* deprecated */
    sim_scriptattribute_executionorder, /* integer attribute, see sim_scriptexecorder_normal, etc. */
    sim_scriptattribute_executioncount, /* integer attribute */
    sim_childscriptattribute_automaticcascadingcalls, /* deprecated */
    sim_scriptattribute_enabled, /* boolean attribute */
    sim_childscriptattribute_enabled=sim_scriptattribute_enabled, /* boolean attribute */
    sim_customizationscriptattribute_cleanupbeforesave, /* deprecated */
    sim_scriptattribute_debuglevel, /* debug */
    sim_scriptattribute_scripttype
};

enum { /* Script execution order, is serialized */
    sim_scriptexecorder_first=0,
    sim_scriptexecorder_normal,
    sim_scriptexecorder_last
};

enum { /* Script tree traversal direction, is serialized */
    sim_scripttreetraversal_reverse=0,
    sim_scripttreetraversal_forward,
    sim_scripttreetraversal_parent
};

enum { /* Script debug level, is serialized */
    sim_scriptdebug_none=0,
    sim_scriptdebug_syscalls=1,
    sim_scriptdebug_vars_interval=2,
    sim_scriptdebug_allcalls=3,
    sim_scriptdebug_vars=4,
    sim_scriptdebug_callsandvars=5
};

enum { /* Threaded script resume location */
    sim_scriptthreadresume_launch           =-2,
    sim_scriptthreadresume_allnotyetresumed =-1,
    sim_scriptthreadresume_default          =0,
    sim_scriptthreadresume_actuation_first  =1,
    sim_scriptthreadresume_actuation_last   =2,
    sim_scriptthreadresume_sensing_first    =3,
    sim_scriptthreadresume_sensing_last     =4,
    sim_scriptthreadresume_custom           =5
};

enum { /* General callback IDs */
    sim_callbackid_rossubscriber            =1,
    sim_callbackid_dynstep                  =2,
    sim_callbackid_userdefined              =1000
};


enum { /* API call error messages */
    sim_api_error_report =1,
    sim_api_error_output =2,
    sim_api_warning_output =4,

    /* for backward compatibility */
    sim_api_errormessage_ignore =0, /* does not memorize nor output errors */
    sim_api_errormessage_report =1, /* memorizes errors (default for C-API calls) */
    sim_api_errormessage_output =2  /* memorizes and outputs errors (default for Lua-API calls) */
};

enum { /* special argument of some functions: */
    sim_handle_all                      =-2,
    sim_handle_all_except_explicit      =-3,
    sim_handle_self                     =-4,
    sim_handle_main_script              =-5,
    sim_handle_tree                     =-6,
    sim_handle_chain                    =-7,
    sim_handle_single                   =-8,
    sim_handle_default                  =-9,
    sim_handle_all_except_self          =-10,
    sim_handle_parent                   =-11,
    sim_handle_scene                    =-12,
    sim_handle_app                      =-13
};

enum { /* special handle flags: */
    sim_handleflag_assembly             =0x00400000,
    sim_handleflag_togglevisibility     =0x00400000,
    sim_handleflag_extended             =0x00400000,
    sim_handleflag_greyscale            =0x00400000,
    sim_handleflag_codedstring          =0x00400000,
    sim_handleflag_depthbuffer          =0x00800000,
    sim_handleflag_depthbuffermeters    =0x00800000,
    sim_handleflag_keeporiginal         =0x00400000,
    sim_handleflag_camera               =0x00400000,
    sim_handleflag_altname              =0x00400000,
    sim_handleflag_axis                 =0x00400000,
    sim_handleflag_resetforce           =0x00400000,
    sim_handleflag_resettorque          =0x00800000,
    sim_handleflag_resetforcetorque     =sim_handleflag_resetforce|sim_handleflag_resettorque,
    sim_handleflag_model                =0x00800000,
    sim_handleflag_rawvalue             =0x01000000,
    sim_handleflag_silenterror          =0x02000000
};

enum { /* distance calculation methods: (serialized) */
    sim_distcalcmethod_dl=0,
    sim_distcalcmethod_dac,
    sim_distcalcmethod_max_dl_dac,
    sim_distcalcmethod_dl_and_dac,
    sim_distcalcmethod_sqrt_dl2_and_dac2,
    sim_distcalcmethod_dl_if_nonzero,
    sim_distcalcmethod_dac_if_nonzero
};

enum { /* Generic dialog styles: */
    sim_dlgstyle_message        =0,
    sim_dlgstyle_input,
    sim_dlgstyle_ok,
    sim_dlgstyle_ok_cancel,
    sim_dlgstyle_yes_no,
    sim_dlgstyle_dont_center    =32 /* can be combined with one of above values. Only with this flag can the position of the related UI be set just after dialog creation  */
};

enum { /* Generic dialog return values: */
    sim_dlgret_still_open=0,
    sim_dlgret_ok,
    sim_dlgret_cancel,
    sim_dlgret_yes,
    sim_dlgret_no
};

enum { /* Path properties: */
    sim_pathproperty_show_line              =0x0001,
    sim_pathproperty_show_orientation       =0x0002,
    sim_pathproperty_closed_path            =0x0004,
    sim_pathproperty_automatic_orientation  =0x0008,
    sim_pathproperty_invert_velocity_deprecated     =0x0010,
    sim_pathproperty_infinite_acceleration_deprecated   =0x0020,
    sim_pathproperty_flat_path              =0x0040,
    sim_pathproperty_show_position          =0x0080,
    sim_pathproperty_auto_velocity_profile_translation_deprecated   =0x0100,
    sim_pathproperty_auto_velocity_profile_rotation_deprecated      =0x0200,
    sim_pathproperty_endpoints_at_zero_deprecated                   =0x0400,
    sim_pathproperty_keep_x_up                          =0x0800
};

enum { /* drawing objects: */
    /* following are mutually exclusive: */
    sim_drawing_points=0,           /* 3 values per point (point size in pixels) */
    sim_drawing_lines,              /* 6 values per line (line size in pixels) */
    sim_drawing_triangles,          /* 9 values per triangle */
    sim_drawing_trianglepoints,     /* 6 values per point (3 for triangle position, 3 for triangle normal vector) (triangle size in meters) */
    sim_drawing_quadpoints,         /* 6 values per point (3 for quad position, 3 for quad normal vector) (quad size in meters) */
    sim_drawing_discpoints,         /* 6 values per point (3 for disc position, 3 for disc normal vector) (disc size in meters) */
    sim_drawing_cubepoints,         /* 6 values per point (3 for cube position, 3 for cube normal vector) (cube size in meters) */
    sim_drawing_spherepoints,           /* 3 values per point (sphere size in meters) */

    /* following can be or-combined: */
    sim_drawing_itemcolors              =0x000020, /* +3 values per item (each item has its own ambient color (r,g,b values)). Mutually exclusive with sim_drawing_vertexcolors */
    sim_drawing_vertexcolors            =0x000040, /* +3 values per vertex (each vertex has its own ambient color (r,g,b values). Only for sim_drawing_lines (+6) and for sim_drawing_triangles(+9)). Mutually exclusive with sim_drawing_itemcolors */
    sim_drawing_itemsizes               =0x000080, /* +1 value per item (each item has its own size). Not for sim_drawing_triangles */
    sim_drawing_backfaceculling         =0x000100, /* back faces are not displayed for all items */
    sim_drawing_wireframe               =0x000200, /* all items displayed in wireframe */
    sim_drawing_painttag                =0x000400, /* all items are tagged as paint (for additinal processing at a later stage) */
    sim_drawing_followparentvisibility  =0x000800, /* if the object is associated with a scene object, then it follows that visibility, otherwise it is always visible */
    sim_drawing_cyclic                  =0x001000, /* if the max item count was reached, then the first items are overwritten. */
    sim_drawing_50percenttransparency   =0x002000, /* the drawing object will be 50% transparent */
    sim_drawing_25percenttransparency   =0x004000, /* the drawing object will be 25% transparent */
    sim_drawing_12percenttransparency   =0x008000, /* the drawing object will be 12.5% transparent */
    sim_drawing_emissioncolor           =0x010000, /* When used in combination with sim_drawing_itemcolors or sim_drawing_vertexcolors, then the specified colors will be for the emissive component */
    sim_drawing_facingcamera            =0x020000, /* Only for trianglepoints, quadpoints, discpoints and cubepoints. If specified, the normal verctor is calculated to face the camera (each item data requires 3 values less) */
    sim_drawing_overlay                 =0x040000, /* When specified, objects are always drawn on top of "regular objects" */
    sim_drawing_itemtransparency        =0x080000,  /* +1 value per item (each item has its own transparency value (0-1)). Not compatible with sim_drawing_vertexcolors */
    sim_drawing_persistent              =0x100000,  /* object is not automatically removed when created via a simulation script */
    sim_drawing_auxchannelcolor1        =0x200000,  /* when specifying the emission color component in the simAddDrawingObject function, 6 values should be specified instead of 3: 3 for the emission component, and 3 for the aux channel component */
    sim_drawing_auxchannelcolor2        =0x400000,  /* When used in combination with sim_drawing_itemcolors or sim_drawing_vertexcolors, then the specified colors will be for the aux channel component */
};

enum { /* banner values: */
    /* following can be or-combined: */
    sim_banner_left                     =0x00001, /* Banners display on the left of the specified point */
    sim_banner_right                    =0x00002, /* Banners display on the right of the specified point */
    sim_banner_nobackground             =0x00004, /* Banners have no background rectangle */
    sim_banner_overlay                  =0x00008, /* When specified, banners are always drawn on top of "regular objects" */
    sim_banner_followparentvisibility   =0x00010, /* if the object is associated with a scene object, then it follows that visibility, otherwise it is always visible */
    sim_banner_clickselectsparent       =0x00020, /* if the object is associated with a scene object, then clicking the banner will select the scene object */
    sim_banner_clicktriggersevent       =0x00040, /* if the banner is clicked, an event is triggered (sim_message_eventcallback_bannerclicked and sim_message_bannerclicked are generated) */
    sim_banner_facingcamera             =0x00080, /* If specified, the banner will always face the camera by rotating around the banner's vertical axis (y-axis) */
    sim_banner_fullyfacingcamera        =0x00100, /* If specified, the banner will always fully face the camera (the banner's orientation is same as the camera looking at it) */
    sim_banner_backfaceculling          =0x00200, /* If specified, the banner will only be visible from one side */
    sim_banner_keepsamesize             =0x00400, /* If specified, the banner will always appear in the same size. In that case size represents the character height in pixels */
    sim_banner_bitmapfont               =0x00800 /* If specified, a fixed-size bitmap font is used. The text will also always fully face the camera and be right to the specified position. Bitmap fonts are not clickable */
};

enum { /* particle objects: */
    /* following are mutually exclusive: */
    sim_particle_points1=0,         /* 6 values per point (pt1 and pt2. Pt1 is start position, pt2-pt1 is the initial velocity vector). Point is 1 pixel big. Only appearance is a point, internally handled as a perfect sphere */
    sim_particle_points2,           /* 6 values per point. Point is 2 pixel big. Only appearance is a point, internally handled as a perfect sphere */
    sim_particle_points4,           /* 6 values per point. Point is 4 pixel big. Only appearance is a point, internally handled as a perfect sphere */
    sim_particle_roughspheres,      /* 6 values per sphere. Only appearance is rough. Internally a perfect sphere */
    sim_particle_spheres,           /* 6 values per sphere. Internally a perfect sphere */

    /* following can be or-combined: */
    sim_particle_respondable1to4        =0x0020, /* the particles are respondable against shapes (against all objects that have at least one bit 1-4 activated in the global respondable mask) */
    sim_particle_respondable5to8        =0x0040, /* the particles are respondable against shapes (against all objects that have at least one bit 5-8 activated in the global respondable mask) */
    sim_particle_particlerespondable    =0x0080, /* the particles are respondable against each other */
    sim_particle_ignoresgravity         =0x0100, /* the particles ignore the effect of gravity. Not compatible with sim_particle_water */
    sim_particle_invisible              =0x0200, /* the particles are invisible */
    sim_particle_itemsizes              =0x0400, /* +1 value per particle (each particle can have a different size) */
    sim_particle_itemdensities          =0x0800, /* +1 value per particle (each particle can have a different density) */
    sim_particle_itemcolors             =0x1000, /* +3 values per particle (each particle can have a different color) */
    sim_particle_cyclic                 =0x2000, /* if the max item count was reached, then the first items are overwritten. */
    sim_particle_emissioncolor          =0x4000, /* When used in combination with sim_particle_itemcolors, then the specified colors will be for the emissive component */
    sim_particle_water                  =0x8000, /* the particles are water particles (no weight in the water (i.e. when z&lt;0)). Not compatible with sim_particle_ignoresgravity */
    sim_particle_painttag               =0x10000 /* The particles can be seen by vision sensors (sim_particle_invisible must not be set) */
};

enum { /* Boolean parameters: */
    sim_boolparam_hierarchy_visible=0,
    sim_boolparam_console_visible,
    sim_boolparam_collision_handling_enabled,
    sim_boolparam_distance_handling_enabled,
    sim_boolparam_ik_handling_enabled,
    sim_boolparam_gcs_handling_enabled,
    sim_boolparam_dynamics_handling_enabled,
    sim_boolparam_joint_motion_handling_enabled_deprecated,
    sim_boolparam_path_motion_handling_enabled_deprecated,
    sim_boolparam_proximity_sensor_handling_enabled,
    sim_boolparam_vision_sensor_handling_enabled,
    sim_boolparam_mill_handling_enabled,
    sim_boolparam_browser_visible,
    sim_boolparam_scene_and_model_load_messages,
    sim_reserved0,
    sim_boolparam_shape_textures_are_visible,
    sim_boolparam_display_enabled,
    sim_boolparam_infotext_visible,
    sim_boolparam_statustext_open,
    sim_boolparam_fog_enabled,
    sim_boolparam_rml2_available,
    sim_boolparam_rml4_available,
    sim_boolparam_mirrors_enabled,
    sim_boolparam_aux_clip_planes_enabled,
    sim_boolparam_reserved3,
    sim_boolparam_realtime_simulation,
    sim_boolparam_use_glfinish_cmd,
    sim_boolparam_force_show_wireless_emission,
    sim_boolparam_force_show_wireless_reception,
    sim_boolparam_video_recording_triggered,
    sim_boolparam_reserved1,
    sim_boolparam_reserved2,
    sim_boolparam_threaded_rendering_enabled,
    sim_boolparam_fullscreen,
    sim_boolparam_headless,
    sim_boolparam_hierarchy_toolbarbutton_enabled,
    sim_boolparam_browser_toolbarbutton_enabled,
    sim_boolparam_objectshift_toolbarbutton_enabled,
    sim_boolparam_objectrotate_toolbarbutton_enabled,
    sim_boolparam_force_calcstruct_all_visible,
    sim_boolparam_force_calcstruct_all,
    sim_boolparam_exit_request,
    sim_boolparam_play_toolbarbutton_enabled,
    sim_boolparam_pause_toolbarbutton_enabled,
    sim_boolparam_stop_toolbarbutton_enabled,
    sim_boolparam_waiting_for_trigger,
    sim_boolparam_objproperties_toolbarbutton_enabled,
    sim_boolparam_calcmodules_toolbarbutton_enabled,
    sim_boolparam_rosinterface_donotrunmainscript,
    sim_boolparam_online_mode,
    sim_boolparam_xr_partrepository,
    sim_boolparam_xr_palletrepository,
    sim_boolparam_scene_closing,
    sim_boolparam_show_w_emitters,
    sim_boolparam_show_w_receivers,
    sim_boolparam_xr_jobfunc
};

enum { /* Integer parameters: */
    sim_intparam_error_report_mode=0, /* Check sim_api_errormessage_... constants above for valid values */
    sim_intparam_program_version,       /* e.g Version 2.1.4 --&gt; 20104. Can only be read. See also sim_intparam_program_revision */
    sim_intparam_instance_count,    /* do not use anymore (always returns 1 since CoppeliaSim 2.5.11) */
    sim_intparam_custom_cmd_start_id, /* can only be read */
    sim_intparam_compilation_version, /* 0=evaluation version, 1=full version, 2=player version. Can only be read */
    sim_intparam_current_page,
    sim_intparam_flymode_camera_handle, /* can only be read */
    sim_intparam_dynamic_step_divider, /* can only be read */
    sim_intparam_dynamic_engine, /* 0=Bullet, 1=ODE. 2=Vortex. 3=Newton. Can only be read */
    sim_intparam_server_port_start, /* can only be read */
    sim_intparam_server_port_range, /* can only be read */
    sim_intparam_visible_layers,
    sim_intparam_infotext_style,
    sim_intparam_settings,
    sim_intparam_edit_mode_type, /* can only be read */
    sim_intparam_server_port_next, /* is initialized at sim_intparam_server_port_start */
    sim_intparam_qt_version, /* version of the used Qt framework */
    sim_intparam_event_flags_read, /* can only be read */
    sim_intparam_event_flags_read_clear, /* can only be read */
    sim_intparam_platform, /* can only be read */
    sim_intparam_scene_unique_id, /* can only be read */
    sim_intparam_work_thread_count, /* deprecated */
    sim_intparam_mouse_x, /* can only be read */
    sim_intparam_mouse_y, /* can only be read */
    sim_intparam_core_count, /* can only be read */
    sim_intparam_work_thread_calc_time_ms, /* deprecated */
    sim_intparam_idle_fps,
    sim_intparam_prox_sensor_select_down,
    sim_intparam_prox_sensor_select_up,
    sim_intparam_stop_request_counter,
    sim_intparam_program_revision, /* Can only be read. See also sim_intparam_program_version */
    sim_intparam_mouse_buttons, /* can only be read */
    sim_intparam_dynamic_warning_disabled_mask,
    sim_intparam_simulation_warning_disabled_mask,
    sim_intparam_scene_index, /* can be used to switch to a different instance programmatically */
    sim_intparam_motionplanning_seed,
    sim_intparam_speedmodifier, /* can only be used while simulation is not stopped */
    sim_intparam_dynamic_iteration_count,
    sim_intparam_job_count, /* can only be read */
    sim_intparam_program_full_version, /* can only be read */
};

enum { /* uint64 parameters: */
    sim_uint64param_simulation_time_step_ns=0, /* simulation time step in nanoseconds */
    sim_uint64param_simulation_time_ns      /* simulation time in nanoseconds */
};

enum { /* Float parameters: */
    sim_floatparam_rand=0, /* random value (0.0-1.0) */
    sim_floatparam_simulation_time_step,
    sim_floatparam_stereo_distance,
    sim_floatparam_dynamic_step_size,
    sim_floatparam_mouse_wheel_zoom_factor
};

enum { /* String parameters: */
    sim_stringparam_application_path=0, /* path of CoppeliaSim's executable */
    sim_stringparam_video_filename, /* name + path without extension! */
    sim_stringparam_app_arg1, /* specify those args with "coppeliaSim -gxxxx" */
    sim_stringparam_app_arg2,
    sim_stringparam_app_arg3,
    sim_stringparam_app_arg4,
    sim_stringparam_app_arg5,
    sim_stringparam_app_arg6,
    sim_stringparam_app_arg7,
    sim_stringparam_app_arg8,
    sim_stringparam_app_arg9,
    sim_stringparam_additional_addonscript1, /* do not use. Can only be written. */
    sim_stringparam_additional_addonscript_firstscene=sim_stringparam_additional_addonscript1, /* deprecated */
    sim_stringparam_additional_addonscript2, /* do not use. Can only be written. */
    sim_stringparam_additional_addonscript=sim_stringparam_additional_addonscript2, /* deprecated */
    sim_stringparam_scene_path_and_name, /* can only be read */
    sim_stringparam_scene_path, /* can only be read */
    sim_stringparam_scene_name, /* can only be read */
    sim_stringparam_remoteapi_temp_file_dir, /* can only be read */
    sim_stringparam_job, /* Current job. can only be read */
    sim_stringparam_job0, /* Job0. can only be read */
    sim_stringparam_job99=sim_stringparam_job0+99, /* can only be read */
    sim_stringparam_scene_unique_id, /* can only be read */
    sim_stringparam_machine_id,
    sim_stringparam_machine_id_legacy,
};

enum { /* Array parameters: */
    sim_arrayparam_gravity=0,
    sim_arrayparam_fog,
    sim_arrayparam_fog_color,
    sim_arrayparam_background_color1,
    sim_arrayparam_background_color2,
    sim_arrayparam_ambient_light,
    sim_arrayparam_random_euler
};

enum { /* UI properties: */
    sim_gui_menubar                     =0x00001,
    sim_gui_popups                      =0x00002,
    sim_gui_toolbar1                    =0x00004,
    sim_gui_toolbar2                    =0x00008,
    sim_gui_hierarchy                   =0x00010,
    sim_gui_infobar                     =0x00020,
    sim_gui_statusbar                   =0x00040,
    sim_gui_scripteditor                =0x00080,
    sim_gui_scriptsimulationparameters  =0x00100,
    sim_gui_dialogs                     =0x00200,
    sim_gui_browser                     =0x00400,
    sim_gui_all                         =0x0ffff,
    sim_gui_headless                    =0x10000,
    sim_autostart                       =0x20000,
    sim_autoquit                        =0x40000
};

enum { /* Joint modes: */
    sim_jointmode_passive=0,
    sim_jointmode_motion_deprecated,
    sim_jointmode_ik,
    sim_jointmode_reserved_previously_ikdependent,
    sim_jointmode_dependent,
    sim_jointmode_force
};

enum { /* Navigation and selection modes with the mouse. Lower byte values are mutually exclusive, upper byte bits can be combined */
    sim_navigation_passive                  =0x000000,
    sim_navigation_camerashift              =0x000001,
    sim_navigation_camerarotate             =0x000002,
    sim_navigation_camerazoom               =0x000003,
    sim_navigation_cameratilt               =0x000004,
    sim_navigation_cameraangle              =0x000005,
    sim_navigation_camerafly                =0x000006,
    sim_navigation_objectshift              =0x000007,
    sim_navigation_objectrotate             =0x000008,
    sim_navigation_reserved2                =0x000009,
    sim_navigation_reserved3                =0x00000A,
    sim_navigation_reserved4                =0x00000B,
    sim_navigation_reserved5                =0x00000C,
    sim_navigation_reserved6                =0x00000D,
    /* Bit-combine following values and add them to one of above's values for a valid navigation mode: */
    sim_navigation_createpathpoint          =0x000100,
    sim_navigation_clickselection           =0x000200,
    sim_navigation_ctrlselection            =0x000400,
    sim_navigation_shiftselection           =0x000800,
    sim_navigation_camerazoomwheel          =0x001000,
    sim_navigation_camerarotaterightbutton  =0x002000, /* deprecated */
    sim_navigation_camerarotatemiddlebutton =0x002000
};


enum { /* Reflexxes Motion Library flags */
    /* enable one of following: */
    simrml_phase_sync_if_possible                   =0x0000,
    simrml_only_time_sync                           =0x0001,
    simrml_only_phase_sync                          =0x0002,
    simrml_no_sync                                  =0x0003,

    /* enable one of following: */
    simrml_keep_target_vel                          =0x0000,
    simrml_recompute_trajectory                     =0x0004,

    /* enable any: */
    simrml_disable_extremum_motion_states_calc      =0x0008,
    simrml_keep_current_vel_if_fallback_strategy    =0x0010
};

enum { /* file dialog styles */
    sim_filedlg_type_load=0,
    sim_filedlg_type_save,
    sim_filedlg_type_load_multiple,
    sim_filedlg_type_folder
};

enum { /* message box styles */
    sim_msgbox_type_info=0,
    sim_msgbox_type_question,
    sim_msgbox_type_warning,
    sim_msgbox_type_critical
};

enum { /* message box buttons */
    sim_msgbox_buttons_ok=0,
    sim_msgbox_buttons_yesno,
    sim_msgbox_buttons_yesnocancel,
    sim_msgbox_buttons_okcancel
};

enum { /* message box return values */
    sim_msgbox_return_cancel=0,
    sim_msgbox_return_no,
    sim_msgbox_return_yes,
    sim_msgbox_return_ok,
    sim_msgbox_return_error
};

enum { /* physics engine */
    sim_physics_bullet=0,
    sim_physics_ode,
    sim_physics_vortex,
    sim_physics_newton
};

enum { /* pure primitives type */
    sim_pure_primitive_none=0,
    sim_pure_primitive_plane,
    sim_pure_primitive_disc,
    sim_pure_primitive_cuboid,
    sim_pure_primitive_spheroid,
    sim_pure_primitive_cylinder,
    sim_pure_primitive_cone,
    sim_pure_primitive_heightfield
};

enum { /* dummy-dummy link types */
    sim_dummy_linktype_dynamics_loop_closure=0,
    sim_dummy_linktype_dynamics_force_constraint,
    sim_dummy_linktype_gcs_loop_closure,
    sim_dummy_linktype_gcs_tip,
    sim_dummy_linktype_gcs_target,
    sim_dummy_linktype_ik_tip_target,
    sim_dummy_linktype_reserved
};

enum { /* texture map modes (serialized) */
    sim_texturemap_plane=0,
    sim_texturemap_cylinder,
    sim_texturemap_sphere,
    sim_texturemap_cube
};

enum { /* path planning types */
    sim_pathplanning_holonomic=0,
    sim_pathplanning_reserved,
    sim_pathplanning_nonholonomic
};

enum { /* Holonomic path planning types */
    sim_holonomicpathplanning_xy=0,     // 2 DoF
    sim_holonomicpathplanning_xg,
    sim_holonomicpathplanning_xyz,      // 3 DoF
    sim_holonomicpathplanning_xyg,
    sim_holonomicpathplanning_abg,
    sim_holonomicpathplanning_xyzg,     // 4 DoF
    sim_holonomicpathplanning_xabg,
    sim_holonomicpathplanning_xyabg,    // 5 DoF
    sim_holonomicpathplanning_xyzabg    // 6 Dof
};

enum { /* resource lock types */
    sim_lock_ui_wants_to_read=0,
    sim_lock_ui_wants_to_write,
    sim_lock_nonui_wants_to_write
};

enum { /* color components */
    sim_colorcomponent_ambient=0,
    sim_colorcomponent_ambient_diffuse=0,
    sim_colorcomponent_diffuse,
    sim_colorcomponent_specular,
    sim_colorcomponent_emission,
    sim_colorcomponent_transparency,
    sim_colorcomponent_auxiliary
};

enum { /* prox. sensor or mill volume types */
    sim_volume_pyramid=0,
    sim_volume_cylinder,
    sim_volume_disc,
    sim_volume_cone,
    sim_volume_ray,
    sim_volume_randomizedray
};

enum { /* Pov pattern types */
    sim_pov_pattern_null=0,
    sim_pov_white_marble,
    sim_pov_blood_marble,
    sim_pov_blue_agate,
    sim_pov_sapphire_agate,
    sim_pov_brown_agate,
    sim_pov_pink_granite,
    sim_pov_pink_alabaster,
    sim_pov_cherry_wood,
    sim_pov_pine_wood,
    sim_pov_dark_wood,
    sim_pov_tan_wood,
    sim_pov_white_wood,
    sim_pov_tom_wood,
    sim_pov_dmf_wood1,
    sim_pov_dmf_wood2,
    sim_pov_dmf_wood3,
    sim_pov_dmf_wood4,
    sim_pov_dmf_wood5,
    sim_pov_dmf_wood6,
    sim_pov_dmf_light_oak,
    sim_pov_dmf_dark_oak,
    sim_pov_emb_wood1,
    sim_pov_yellow_pine,
    sim_pov_rose_wood,
    sim_pov_sandal_wood,
    sim_pov_glass,
    sim_pov_glass2,
    sim_pov_glass3,
    sim_pov_green_glass,
    sim_pov_light_glass,
    sim_pov_bold_glass,
    sim_pov_wine_bottle,
    sim_pov_beer_bottle,
    sim_pov_ruby_glass,
    sim_pov_blue_glass,
    sim_pov_yellow_glass,
    sim_pov_orange_glass,
    sim_pov_vicks_bottle_glass,
    sim_pov_chrome_metal,
    sim_pov_brass_metal,
    sim_pov_copper_metal,
    sim_pov_bronze_metal,
    sim_pov_silver_metal,
    sim_pov_gold_metal,
    sim_pov_polished_chrome,
    sim_pov_polished_brass,
    sim_pov_new_brass,
    sim_pov_spun_brass,
    sim_pov_brushed_aluminum,
    sim_pov_silver1,
    sim_pov_silver2,
    sim_pov_silver3,
    sim_pov_brass_valley,
    sim_pov_rust,
    sim_pov_rusty_iron,
    sim_pov_soft_silver,
    sim_pov_new_penny,
    sim_pov_tinny_brass,
    sim_pov_gold_nugget,
    sim_pov_aluminum,
    sim_pov_bright_bronze,
    sim_pov_water,
    sim_pov_cork,
    sim_pov_lightning,
    sim_pov_mirror
};


enum { /* Object int/float/string parameters */
    /* scene objects */
    sim_objintparam_visibility_layer= 10,
    sim_objfloatparam_abs_x_velocity= 11,
    sim_objfloatparam_abs_y_velocity= 12,
    sim_objfloatparam_abs_z_velocity= 13,
    sim_objfloatparam_abs_rot_velocity= 14,
    sim_objfloatparam_objbbox_min_x= 15,
    sim_objfloatparam_objbbox_min_y= 16,
    sim_objfloatparam_objbbox_min_z= 17,
    sim_objfloatparam_objbbox_max_x= 18,
    sim_objfloatparam_objbbox_max_y= 19,
    sim_objfloatparam_objbbox_max_z= 20,
    sim_objfloatparam_modelbbox_min_x= 21,
    sim_objfloatparam_modelbbox_min_y= 22,
    sim_objfloatparam_modelbbox_min_z= 23,
    sim_objfloatparam_modelbbox_max_x= 24,
    sim_objfloatparam_modelbbox_max_y= 25,
    sim_objfloatparam_modelbbox_max_z= 26,
    sim_objintparam_collection_self_collision_indicator= 27,
    sim_objfloatparam_transparency_offset= 28,
    sim_objintparam_child_role= 29, /* DEPRECATED */
    sim_objintparam_parent_role= 30, /* DEPRECATED */
    sim_objintparam_manipulation_permissions= 31,
    sim_objintparam_illumination_handle= 32,
    sim_objstringparam_dna= 33,
    sim_objfloatparam_size_factor= 34,
    sim_objstringparam_unique_id= 35,

    sim_objparam_end= 999,

    /* vision_sensors */
    sim_visionfloatparam_near_clipping= 1000,
    sim_visionfloatparam_far_clipping= 1001,
    sim_visionintparam_resolution_x= 1002,
    sim_visionintparam_resolution_y= 1003,
    sim_visionfloatparam_perspective_angle= 1004,
    sim_visionfloatparam_ortho_size= 1005,
    sim_visionintparam_disabled_light_components= 1006,
    sim_visionintparam_rendering_attributes= 1007,
    sim_visionintparam_entity_to_render= 1008,
    sim_visionintparam_windowed_size_x= 1009,
    sim_visionintparam_windowed_size_y= 1010,
    sim_visionintparam_windowed_pos_x= 1011,
    sim_visionintparam_windowed_pos_y= 1012,
    sim_visionintparam_pov_focal_blur= 1013,
    sim_visionfloatparam_pov_blur_distance= 1014,
    sim_visionfloatparam_pov_aperture= 1015,
    sim_visionintparam_pov_blur_sampled= 1016,
    sim_visionintparam_render_mode= 1017,
    sim_visionintparam_perspective_operation= 1018,

    /* joints */
    sim_jointintparam_motor_enabled= 2000,
    sim_jointintparam_ctrl_enabled= 2001,
    sim_jointfloatparam_pid_p= 2002,
    sim_jointfloatparam_pid_i= 2003,
    sim_jointfloatparam_pid_d= 2004,
    sim_jointfloatparam_intrinsic_x= 2005,
    sim_jointfloatparam_intrinsic_y= 2006,
    sim_jointfloatparam_intrinsic_z= 2007,
    sim_jointfloatparam_intrinsic_qx= 2008,
    sim_jointfloatparam_intrinsic_qy= 2009,
    sim_jointfloatparam_intrinsic_qz= 2010,
    sim_jointfloatparam_intrinsic_qw= 2011,
    sim_jointfloatparam_velocity= 2012,
    sim_jointfloatparam_spherical_qx= 2013,
    sim_jointfloatparam_spherical_qy= 2014,
    sim_jointfloatparam_spherical_qz= 2015,
    sim_jointfloatparam_spherical_qw= 2016,
    sim_jointfloatparam_upper_limit= 2017,
    sim_jointfloatparam_kc_k= 2018,
    sim_jointfloatparam_kc_c= 2019,
    sim_jointfloatparam_ik_weight= 2021,
    sim_jointfloatparam_error_x= 2022,
    sim_jointfloatparam_error_y= 2023,
    sim_jointfloatparam_error_z= 2024,
    sim_jointfloatparam_error_a= 2025,
    sim_jointfloatparam_error_b= 2026,
    sim_jointfloatparam_error_g= 2027,
    sim_jointfloatparam_error_pos= 2028,
    sim_jointfloatparam_error_angle= 2029,
    sim_jointintparam_velocity_lock= 2030,
    sim_jointintparam_vortex_dep_handle= 2031,
    sim_jointfloatparam_vortex_dep_multiplication= 2032,
    sim_jointfloatparam_vortex_dep_offset= 2033,

    /* shapes */
    sim_shapefloatparam_init_velocity_x= 3000,
    sim_shapefloatparam_init_velocity_y= 3001,
    sim_shapefloatparam_init_velocity_z= 3002,
    sim_shapeintparam_static= 3003,
    sim_shapeintparam_respondable= 3004,
    sim_shapefloatparam_mass= 3005,
    sim_shapefloatparam_texture_x= 3006,
    sim_shapefloatparam_texture_y= 3007,
    sim_shapefloatparam_texture_z= 3008,
    sim_shapefloatparam_texture_a= 3009,
    sim_shapefloatparam_texture_b= 3010,
    sim_shapefloatparam_texture_g= 3011,
    sim_shapefloatparam_texture_scaling_x= 3012,
    sim_shapefloatparam_texture_scaling_y= 3013,
    sim_shapeintparam_culling= 3014,
    sim_shapeintparam_wireframe= 3015,
    sim_shapeintparam_compound= 3016,
    sim_shapeintparam_convex= 3017,
    sim_shapeintparam_convex_check= 3018,
    sim_shapeintparam_respondable_mask= 3019,
    sim_shapefloatparam_init_velocity_a= 3020, /* DEPRECATED */
    sim_shapefloatparam_init_ang_velocity_x= 3020,
    sim_shapefloatparam_init_velocity_b= 3021, /* DEPRECATED */
    sim_shapefloatparam_init_ang_velocity_y= 3021,
    sim_shapefloatparam_init_velocity_g= 3022, /* DEPRECATED */
    sim_shapefloatparam_init_ang_velocity_z= 3022,
    sim_shapestringparam_color_name= 3023,
    sim_shapeintparam_edge_visibility= 3024,
    sim_shapefloatparam_shading_angle= 3025,
    sim_shapefloatparam_edge_angle= 3026,
    sim_shapeintparam_edge_borders_hidden= 3027,

    /* proximity sensors */
    sim_proxintparam_ray_invisibility= 4000,
    sim_proxintparam_volume_type= 4001,
    sim_proxintparam_entity_to_detect= 4002,

    /* force sensors */
    sim_forcefloatparam_error_x= 5000,
    sim_forcefloatparam_error_y= 5001,
    sim_forcefloatparam_error_z= 5002,
    sim_forcefloatparam_error_a= 5003,
    sim_forcefloatparam_error_b= 5004,
    sim_forcefloatparam_error_g= 5005,
    sim_forcefloatparam_error_pos= 5006,
    sim_forcefloatparam_error_angle= 5007,

    /* lights */
    sim_lightintparam_pov_casts_shadows= 8000,
    sim_lightfloatparam_spot_exponent= 8001,
    sim_lightfloatparam_spot_cutoff= 8002,
    sim_lightfloatparam_const_attenuation= 8003,
    sim_lightfloatparam_lin_attenuation= 8004,
    sim_lightfloatparam_quad_attenuation= 8005,

    /* cameras */
    sim_cameraintparam_disabled_light_components= 9000,
    sim_camerafloatparam_perspective_angle= 9001,
    sim_camerafloatparam_ortho_size= 9002,
    sim_cameraintparam_rendering_attributes= 9003,
    sim_cameraintparam_pov_focal_blur= 9004,
    sim_camerafloatparam_pov_blur_distance= 9005,
    sim_camerafloatparam_pov_aperture= 9006,
    sim_cameraintparam_pov_blur_samples= 9007,

    /* dummies */
    sim_dummyintparam_link_type= 10000,
    sim_dummyintparam_follow_path= 10001,
    sim_dummyfloatparam_follow_path_offset= 10002,

    /* mills */
    sim_millintparam_volume_type= 11000,

    /* mirrors */
    sim_mirrorfloatparam_width= 12000,
    sim_mirrorfloatparam_height= 12001,
    sim_mirrorfloatparam_reflectance= 12002,
    sim_mirrorintparam_enable= 12003,

    /* path planning */
    sim_pplanfloatparam_x_min= 20000,
    sim_pplanfloatparam_x_range= 20001,
    sim_pplanfloatparam_y_min= 20002,
    sim_pplanfloatparam_y_range= 20003,
    sim_pplanfloatparam_z_min= 20004,
    sim_pplanfloatparam_z_range= 20005,
    sim_pplanfloatparam_delta_min= 20006,
    sim_pplanfloatparam_delta_range= 20007,

    /* motion planning */
    sim_mplanintparam_nodes_computed= 25000,
    sim_mplanintparam_prepare_nodes= 25001,
    sim_mplanintparam_clear_nodes= 25002
};

enum { /* stack table info */
    sim_stack_table_circular_ref=-4,
    sim_stack_table_not_table=-3,
    sim_stack_table_map=-2,
    sim_stack_table_empty=0
};

enum { /* Physics engines params */
    /* Bullet */
    sim_bullet_global_float_start=0,
    sim_bullet_global_stepsize,
    sim_bullet_global_internalscalingfactor,
    sim_bullet_global_collisionmarginfactor,
    sim_bullet_global_float_end,

    sim_bullet_global_int_start=1000,
    sim_bullet_global_constraintsolvingiterations,
    sim_bullet_global_bitcoded,
    sim_bullet_global_constraintsolvertype,
    sim_bullet_global_int_end,

    sim_bullet_global_bool_start=2000,
    sim_bullet_global_fullinternalscaling,
    sim_bullet_global_bool_end,

    sim_bullet_joint_float_start=3000,
    sim_bullet_joint_stoperp,
    sim_bullet_joint_stopcfm,
    sim_bullet_joint_normalcfm,
    sim_bullet_joint_float_end,

    sim_bullet_joint_int_start=4000,
    /* if you add something here, search for bji11032016 */
    sim_bullet_joint_int_end,

    sim_bullet_joint_bool_start=5000,
    /* if you add something here, search for bjb11032016 */
    sim_bullet_joint_bool_end,

    sim_bullet_body_float_start=6000,
    sim_bullet_body_restitution,
    sim_bullet_body_oldfriction,
    sim_bullet_body_friction,
    sim_bullet_body_lineardamping,
    sim_bullet_body_angulardamping,
    sim_bullet_body_nondefaultcollisionmargingfactor,
    sim_bullet_body_nondefaultcollisionmargingfactorconvex,
    sim_bullet_body_float_end,

    sim_bullet_body_int_start=7000,
    sim_bullet_body_bitcoded,
    sim_bullet_body_int_end,

    sim_bullet_body_bool_start=8000,
    sim_bullet_body_sticky,
    sim_bullet_body_usenondefaultcollisionmargin,
    sim_bullet_body_usenondefaultcollisionmarginconvex,
    sim_bullet_body_autoshrinkconvex,
    sim_bullet_body_bool_end,

    /* ODE */
    sim_ode_global_float_start=9000,
    sim_ode_global_stepsize,
    sim_ode_global_internalscalingfactor,
    sim_ode_global_cfm,
    sim_ode_global_erp,
    sim_ode_global_float_end,

    sim_ode_global_int_start=10000,
    sim_ode_global_constraintsolvingiterations,
    sim_ode_global_bitcoded,
    sim_ode_global_randomseed,
    sim_ode_global_int_end,

    sim_ode_global_bool_start=11000,
    sim_ode_global_fullinternalscaling,
    sim_ode_global_quickstep,
    sim_ode_global_bool_end,

    sim_ode_joint_float_start=12000,
    sim_ode_joint_stoperp,
    sim_ode_joint_stopcfm,
    sim_ode_joint_bounce,
    sim_ode_joint_fudgefactor,
    sim_ode_joint_normalcfm,
    sim_ode_joint_float_end,

    sim_ode_joint_int_start=13000,
    /* if you add something here, search for oji11032016 */
    sim_ode_joint_int_end,

    sim_ode_joint_bool_start=14000,
    /* if you add something here, search for ojb11032016 */
    sim_ode_joint_bool_end,

    sim_ode_body_float_start=15000,
    sim_ode_body_friction,
    sim_ode_body_softerp,
    sim_ode_body_softcfm,
    sim_ode_body_lineardamping,
    sim_ode_body_angulardamping,
    sim_ode_body_float_end,

    sim_ode_body_int_start=16000,
    sim_ode_body_maxcontacts,
    sim_ode_body_int_end,

    sim_ode_body_bool_start=17000,
    /* if you add something here, search for obb11032016 */
    sim_ode_body_bool_end,

    /* Vortex */
    sim_vortex_global_float_start=18000,
    sim_vortex_global_stepsize,
    sim_vortex_global_internalscalingfactor,
    sim_vortex_global_contacttolerance,
    sim_vortex_global_constraintlinearcompliance,
    sim_vortex_global_constraintlineardamping,
    sim_vortex_global_constraintlinearkineticloss,
    sim_vortex_global_constraintangularcompliance,
    sim_vortex_global_constraintangulardamping,
    sim_vortex_global_constraintangularkineticloss,
    sim_vortex_global_float_end,

    sim_vortex_global_int_start=19000,
    sim_vortex_global_bitcoded,
    sim_vortex_global_int_end,

    sim_vortex_global_bool_start=20000,
    sim_vortex_global_autosleep,
    sim_vortex_global_multithreading,
    sim_vortex_global_bool_end,

    sim_vortex_joint_float_start=21000,
    sim_vortex_joint_lowerlimitdamping,
    sim_vortex_joint_upperlimitdamping,
    sim_vortex_joint_lowerlimitstiffness,
    sim_vortex_joint_upperlimitstiffness,
    sim_vortex_joint_lowerlimitrestitution,
    sim_vortex_joint_upperlimitrestitution,
    sim_vortex_joint_lowerlimitmaxforce,
    sim_vortex_joint_upperlimitmaxforce,
    sim_vortex_joint_motorconstraintfrictioncoeff,
    sim_vortex_joint_motorconstraintfrictionmaxforce,
    sim_vortex_joint_motorconstraintfrictionloss,
    sim_vortex_joint_p0loss,
    sim_vortex_joint_p0stiffness,
    sim_vortex_joint_p0damping,
    sim_vortex_joint_p0frictioncoeff,
    sim_vortex_joint_p0frictionmaxforce,
    sim_vortex_joint_p0frictionloss,
    sim_vortex_joint_p1loss,
    sim_vortex_joint_p1stiffness,
    sim_vortex_joint_p1damping,
    sim_vortex_joint_p1frictioncoeff,
    sim_vortex_joint_p1frictionmaxforce,
    sim_vortex_joint_p1frictionloss,
    sim_vortex_joint_p2loss,
    sim_vortex_joint_p2stiffness,
    sim_vortex_joint_p2damping,
    sim_vortex_joint_p2frictioncoeff,
    sim_vortex_joint_p2frictionmaxforce,
    sim_vortex_joint_p2frictionloss,
    sim_vortex_joint_a0loss,
    sim_vortex_joint_a0stiffness,
    sim_vortex_joint_a0damping,
    sim_vortex_joint_a0frictioncoeff,
    sim_vortex_joint_a0frictionmaxforce,
    sim_vortex_joint_a0frictionloss,
    sim_vortex_joint_a1loss,
    sim_vortex_joint_a1stiffness,
    sim_vortex_joint_a1damping,
    sim_vortex_joint_a1frictioncoeff,
    sim_vortex_joint_a1frictionmaxforce,
    sim_vortex_joint_a1frictionloss,
    sim_vortex_joint_a2loss,
    sim_vortex_joint_a2stiffness,
    sim_vortex_joint_a2damping,
    sim_vortex_joint_a2frictioncoeff,
    sim_vortex_joint_a2frictionmaxforce,
    sim_vortex_joint_a2frictionloss,
    sim_vortex_joint_dependencyfactor,
    sim_vortex_joint_dependencyoffset,
    sim_vortex_joint_float_end,

    sim_vortex_joint_int_start=22000,
    sim_vortex_joint_bitcoded,
    sim_vortex_joint_relaxationenabledbc,
    sim_vortex_joint_frictionenabledbc,
    sim_vortex_joint_frictionproportionalbc,
    sim_vortex_joint_objectid,
    sim_vortex_joint_dependentobjectid,
    sim_vortex_joint_int_end,

    sim_vortex_joint_bool_start=23000,
    sim_vortex_joint_motorfrictionenabled,
    sim_vortex_joint_proportionalmotorfriction,
    sim_vortex_joint_bool_end,

    sim_vortex_body_float_start=24000,
    sim_vortex_body_primlinearaxisfriction,
    sim_vortex_body_seclinearaxisfriction,
    sim_vortex_body_primangularaxisfriction,
    sim_vortex_body_secangularaxisfriction,
    sim_vortex_body_normalangularaxisfriction,
    sim_vortex_body_primlinearaxisstaticfrictionscale,
    sim_vortex_body_seclinearaxisstaticfrictionscale,
    sim_vortex_body_primangularaxisstaticfrictionscale,
    sim_vortex_body_secangularaxisstaticfrictionscale,
    sim_vortex_body_normalangularaxisstaticfrictionscale,
    sim_vortex_body_compliance,
    sim_vortex_body_damping,
    sim_vortex_body_restitution,
    sim_vortex_body_restitutionthreshold,
    sim_vortex_body_adhesiveforce,
    sim_vortex_body_linearvelocitydamping,
    sim_vortex_body_angularvelocitydamping,
    sim_vortex_body_primlinearaxisslide,
    sim_vortex_body_seclinearaxisslide,
    sim_vortex_body_primangularaxisslide,
    sim_vortex_body_secangularaxisslide,
    sim_vortex_body_normalangularaxisslide,
    sim_vortex_body_primlinearaxisslip,
    sim_vortex_body_seclinearaxisslip,
    sim_vortex_body_primangularaxisslip,
    sim_vortex_body_secangularaxisslip,
    sim_vortex_body_normalangularaxisslip,
    sim_vortex_body_autosleeplinearspeedthreshold,
    sim_vortex_body_autosleeplinearaccelthreshold,
    sim_vortex_body_autosleepangularspeedthreshold,
    sim_vortex_body_autosleepangularaccelthreshold,
    sim_vortex_body_skinthickness,
    sim_vortex_body_autoangulardampingtensionratio,
    sim_vortex_body_primaxisvectorx,
    sim_vortex_body_primaxisvectory,
    sim_vortex_body_primaxisvectorz,
    sim_vortex_body_float_end,

    sim_vortex_body_int_start=25000,
    sim_vortex_body_primlinearaxisfrictionmodel,
    sim_vortex_body_seclinearaxisfrictionmodel,
    sim_vortex_body_primangulararaxisfrictionmodel,
    sim_vortex_body_secmangulararaxisfrictionmodel,
    sim_vortex_body_normalmangulararaxisfrictionmodel,
    sim_vortex_body_bitcoded,
    sim_vortex_body_autosleepsteplivethreshold,
    sim_vortex_body_materialuniqueid,
    sim_vortex_body_int_end,

    sim_vortex_body_bool_start=26000,
    sim_vortex_body_pureshapesasconvex,
    sim_vortex_body_convexshapesasrandom,
    sim_vortex_body_randomshapesasterrain,
    sim_vortex_body_fastmoving,
    sim_vortex_body_autoslip,
    sim_vortex_body_seclinaxissameasprimlinaxis,
    sim_vortex_body_secangaxissameasprimangaxis,
    sim_vortex_body_normangaxissameasprimangaxis,
    sim_vortex_body_autoangulardamping,
    sim_vortex_body_bool_end,

    /* Newton */
    sim_newton_global_float_start=27000,
    sim_newton_global_stepsize,
    sim_newton_global_contactmergetolerance,
    sim_newton_global_float_end,

    sim_newton_global_int_start=28000,
    sim_newton_global_constraintsolvingiterations,
    sim_newton_global_bitcoded,
    sim_newton_global_int_end,

    sim_newton_global_bool_start=29000,
    sim_newton_global_multithreading,
    sim_newton_global_exactsolver,
    sim_newton_global_highjointaccuracy,
    sim_newton_global_bool_end,

    sim_newton_joint_float_start=30000,
    sim_newton_joint_dependencyfactor,
    sim_newton_joint_dependencyoffset,
    sim_newton_joint_float_end,

    sim_newton_joint_int_start=31000,
    sim_newton_joint_objectid,
    sim_newton_joint_dependentobjectid,
    sim_newton_joint_int_end,

    sim_newton_joint_bool_start=32000,
    /* if you add something here, search for njb11032016 */
    sim_newton_joint_bool_end,

    sim_newton_body_float_start=33000,
    sim_newton_body_staticfriction,
    sim_newton_body_kineticfriction,
    sim_newton_body_restitution,
    sim_newton_body_lineardrag,
    sim_newton_body_angulardrag,
    sim_newton_body_float_end,

    sim_newton_body_int_start=34000,
    sim_newton_body_bitcoded,
    sim_newton_body_int_end,

    sim_newton_body_bool_start=35000,
    sim_newton_body_fastmoving,
    sim_newton_body_bool_end
};

enum { /* Vortex friction models */
    sim_vortex_bodyfrictionmodel_box=0,
    sim_vortex_bodyfrictionmodel_scaledbox,
    sim_vortex_bodyfrictionmodel_proplow,
    sim_vortex_bodyfrictionmodel_prophigh,
    sim_vortex_bodyfrictionmodel_scaledboxfast,
    sim_vortex_bodyfrictionmodel_neutral,
    sim_vortex_bodyfrictionmodel_none
};

enum { /* Bullet constraint solver type */
    sim_bullet_constraintsolvertype_sequentialimpulse=0,
    sim_bullet_constraintsolvertype_nncg,
    sim_bullet_constraintsolvertype_dantzig,
    sim_bullet_constraintsolvertype_projectedgaussseidel
};

enum {
    sim_objdynprop_dynamic=1,
    sim_objdynprop_respondable=2,
};

enum {
    sim_announce_pureconenotsupported=0,
    sim_announce_purespheroidnotsupported,
    sim_announce_containsnonpurenonconvexshapes,
    sim_announce_containsstaticshapesondynamicconstruction,
    sim_announce_purehollowshapenotsupported,
    sim_announce_vortexpluginisdemo,
    sim_announce_newtondynamicrandommeshnotsupported,
};

enum {
    sim_dynamicsimicon_none=0,
    sim_dynamicsimicon_objectisdynamicallysimulated,
    sim_dynamicsimicon_objectisnotdynamicallyenabled
};

enum { /* Filter component types. Not used anymore (use vision callback functions instead) */
    sim_filtercomponent_originalimage_deprecated=1,
    sim_filtercomponent_originaldepth_deprecated,
    sim_filtercomponent_uniformimage_deprecated,
    sim_filtercomponent_tooutput_deprecated,
    sim_filtercomponent_tobuffer1_deprecated,
    sim_filtercomponent_tobuffer2_deprecated,
    sim_filtercomponent_frombuffer1_deprecated,
    sim_filtercomponent_frombuffer2_deprecated,
    sim_filtercomponent_swapbuffers_deprecated,
    sim_filtercomponent_addbuffer1_deprecated,
    sim_filtercomponent_subtractbuffer1_deprecated,
    sim_filtercomponent_multiplywithbuffer1_deprecated,
    sim_filtercomponent_horizontalflip_deprecated,
    sim_filtercomponent_verticalflip_deprecated,
    sim_filtercomponent_rotate_deprecated,
    sim_filtercomponent_shift_deprecated,
    sim_filtercomponent_resize_deprecated,
    sim_filtercomponent_3x3filter_deprecated,
    sim_filtercomponent_5x5filter_deprecated,
    sim_filtercomponent_sharpen_deprecated,
    sim_filtercomponent_edge_deprecated,
    sim_filtercomponent_rectangularcut_deprecated,
    sim_filtercomponent_circularcut_deprecated,
    sim_filtercomponent_normalize_deprecated,
    sim_filtercomponent_intensityscale_deprecated,
    sim_filtercomponent_keeporremovecolors_deprecated,
    sim_filtercomponent_scaleandoffsetcolors_deprecated,
    sim_filtercomponent_binary_deprecated,
    sim_filtercomponent_swapwithbuffer1_deprecated,
    sim_filtercomponent_addtobuffer1_deprecated,
    sim_filtercomponent_subtractfrombuffer1_deprecated,
    sim_filtercomponent_correlationwithbuffer1_deprecated,
    sim_filtercomponent_colorsegmentation_deprecated,
    sim_filtercomponent_blobextraction_deprecated,
    sim_filtercomponent_imagetocoord_deprecated,
    sim_filtercomponent_pixelchange_deprecated,
    sim_filtercomponent_velodyne_deprecated,
    sim_filtercomponent_todepthoutput_deprecated,
    sim_filtercomponent_customized_deprecated=1000
};

enum { /* Buffer types */
    sim_buffer_uint8=0,
    sim_buffer_int8,
    sim_buffer_uint16,
    sim_buffer_int16,
    sim_buffer_uint32,
    sim_buffer_int32,
    sim_buffer_float,
    sim_buffer_double,
    sim_buffer_uint8rgb,
    sim_buffer_uint8bgr,
    sim_buffer_uint8rgba,
    sim_buffer_uint8argb,
    sim_buffer_base64,
    sim_buffer_split,
    sim_buffer_clamp=256 /* flag */
};

enum { /* Image combination */
    sim_imgcomb_vertical=0,
    sim_imgcomb_horizontal
};

enum { /* Default dynamic materials */
    sim_dynmat_default=2310013, /* i.e. SIM_IDSTART_DEFDYNMATERIAL */
    sim_dynmat_highfriction,
    sim_dynmat_lowfriction,
    sim_dynmat_nofriction,
    sim_dynmat_reststackgrasp,
    sim_dynmat_foot,
    sim_dynmat_wheel,
    sim_dynmat_gripper,
    sim_dynmat_floor
};

enum { /* Vision sensors render modes */
    sim_rendermode_opengl=0,
    sim_rendermode_auxchannels,
    sim_rendermode_colorcoded,
    sim_rendermode_povray,
    sim_rendermode_reserved,
    sim_rendermode_extrenderer,
    sim_rendermode_extrendererwindowed,
    sim_rendermode_opengl3,
    sim_rendermode_opengl3windowed
};



/******************************************
*******************************************
Remote API constants:
*******************************************
*******************************************/

#define SIMX_VERSION 11  /* max is 255!!! */
/* version to 6 for release 3.1.2 */
/* version to 7 for release 3.1.3 */
/* version to 8 for release AFTER 3.1.3 */
/* version to 10 for release AFTER 3.2.3. Added simxGetCollectionHandle and simxCallScriptFunction */
/* version to 11 for release AFTER 3.3.0. Added uses stacks for data exchange with scripts */

/*
Messages sent/received look like this:
-Message header (SIMX_HEADER_SIZE in size)
-Command header 1 (SIMX_SUBHEADER_SIZE in size)
-Command data 1
-Pure data 1
-Command header 2 (SIMX_SUBHEADER_SIZE in size)
-Command data 2
-Pure data 2
- ...
-Command header n (SIMX_SUBHEADER_SIZE in size)
-Command data n
-Pure data n
*/

/* Remote API message header structure: */
#define SIMX_HEADER_SIZE 18
#define simx_headeroffset_crc 0             /* 1 simxUShort. Generated by the client or server. The CRC for the message */
#define simx_headeroffset_version 2         /* 1 byte. Generated by the client or server. The version of the remote API software */
#define simx_headeroffset_message_id 3      /* 1 simxInt. Generated by the client (and used in a reply by the server) */
#define simx_headeroffset_client_time 7     /* 1 simxInt. Client time stamp generated by the client (and sent back by the server) */
#define simx_headeroffset_server_time 11    /* 1 simxInt. Generated by the server when a reply is generated. The server timestamp */
#define simx_headeroffset_scene_id 15       /* 1 simxUShort. Generated by the server. A unique ID identifying the scene currently displayed */
#define simx_headeroffset_server_state 17   /* 1 byte. Generated by the server. Bit coded: 0 set --&gt; simulation not stopped, 1 set --&gt; simulation paused, 2 set --&gt; real-time switch on, 3-5: edit mode type (0=no edit mode, 1=triangle, 2=vertex, 3=edge, 4=path, 5=UI) */

/* Remote API command header: */
#define SIMX_SUBHEADER_SIZE 26
#define simx_cmdheaderoffset_mem_size 0         /* 1 simxInt. Generated by the client or server. The buffer size of the command. */
#define simx_cmdheaderoffset_full_mem_size 4    /* 1 simxInt. Generated by the client or server. The full buffer size of the command (applies to split chunks). */
#define simx_cmdheaderoffset_pdata_offset0 8    /* 1 simxUShort. Generated by the client or server. The amount of data that is part of the command identification. */
#define simx_cmdheaderoffset_pdata_offset1 10   /* 1 simxInt. Generated by the client or server. The amount of shift of the pure data buffer (applies to split chunks). */
#define simx_cmdheaderoffset_cmd 14             /* 1 simxInt. Generated by the client (and used in a reply by the server). The command, combined with the operation mode of the command. */
#define simx_cmdheaderoffset_delay_or_split 18  /* 1 simxUShort. Generated by the client or server. The amount of delay in ms of a streaming command, or the max. pure data size to send at once (applies to split commands). */
#define simx_cmdheaderoffset_sim_time 20        /* 1 simxInt. Generated by the server. The simulation time (in ms) when the command was executed (or 0 if simulation is not running) */
#define simx_cmdheaderoffset_status 24          /* 1 byte. Generated by the server. (1: bit 0 is set --&gt; error in function execution on server side). The client writes bit 1 if command cannot be overwritten*/
#define simx_cmdheaderoffset_reserved 25        /* 1 byte. Not yet used */

/* All command codes (followed by operation mode codes) */
enum {  simx_cmdnull_start              =0,
        /* from here on, commands are only identified by their code */
        simx_cmd_synchronous_enable,
        simx_cmd_synchronous_disable,
        simx_cmd_synchronous_next,
        simx_cmd_get_last_errors,
        simx_cmd_close_scene,
        simx_cmd_get_object_selection,
        simx_cmd_reserved1,
        simx_cmd_reserved2,
        simx_cmd_create_dummy,
        simx_cmd_kill_connection,

        simx_cmdnull_custom_start       =0x000800,

        simx_cmd4bytes_start            =0x001000,
        /* from here on, commands are also identified by additional 4 bytes */
        simx_cmd_get_joint_position,
        simx_cmd_set_joint_position,
        simx_cmd_get_vision_sensor_image_bw,
        simx_cmd_get_vision_sensor_image_rgb,
        simx_cmd_set_vision_sensor_image_bw,
        simx_cmd_set_vision_sensor_image_rgb,
        simx_cmd_start_pause_stop_simulation,
        simx_cmd_set_joint_target_velocity,
        simx_cmd_read_proximity_sensor,
        simx_cmd_get_joint_matrix,
        simx_cmd_set_spherical_joint_matrix,
        simx_cmd_set_joint_target_position,
        simx_cmd_get_joint_force,
        simx_cmd_set_joint_force,
        simx_cmd_read_force_sensor,
        simx_cmd_break_force_sensor,
        simx_cmd_read_vision_sensor,
        simx_cmd_get_object_parent,
        simx_cmd_spotcanbeused5,
        simx_cmd_aux_console_close,
        simx_cmd_aux_console_print,
        simx_cmd_aux_console_show,
        simx_cmd_get_vision_sensor_depth_buffer,
        simx_cmd_get_object_orientation,
        simx_cmd_get_object_position,
        simx_cmd_set_object_orientation,
        simx_cmd_set_object_position,
        simx_cmd_set_object_parent,
        simx_cmd_get_array_parameter,
        simx_cmd_set_array_parameter,
        simx_cmd_get_boolean_parameter,
        simx_cmd_set_boolean_parameter,
        simx_cmd_get_integer_parameter,
        simx_cmd_set_integer_parameter,
        simx_cmd_get_floating_parameter,
        simx_cmd_set_floating_parameter,
        simx_cmd_get_string_parameter,
        simx_cmd_read_collision,
        simx_cmd_read_distance,
        simx_cmd_remove_object,
        simx_cmd_remove_ui,
        simx_cmd_get_objects,
        simx_cmd_end_dialog,
        simx_cmd_get_dialog_input,
        simx_cmd_get_dialog_result,
        simx_cmd_copy_paste_objects,
        simx_cmd_set_object_selection,
        simx_cmd_spotcanbeused1,
        simx_cmd_spotcanbeused2,
        simx_cmd_spotcanbeused3,
        simx_cmd_spotcanbeused4,
        simx_cmd_get_model_property,
        simx_cmd_set_model_property,
        simx_cmd_get_object_velocity,
        simx_cmd_remove_model,
        simx_cmd_get_joint_max_force,

        simx_cmd4bytes_custom_start =0x001800,
        simx_cmd_set_object_quaternion,

        simx_cmd8bytes_start            =0x002000,
        /* from here on, commands are also identified by additional 8 bytes */
        simx_cmd_get_ui_slider,
        simx_cmd_set_ui_slider,
        simx_cmd_get_ui_event_button,
        simx_cmd_get_ui_button_property,
        simx_cmd_set_ui_button_property,
        simx_cmd_set_ui_button_label,
        simx_cmd_get_object_float_parameter,
        simx_cmd_get_object_int_parameter,
        simx_cmd_set_object_float_parameter,
        simx_cmd_set_object_int_parameter,
        simx_cmd_get_object_child,
        simx_cmd_get_object_group_data,
        simx_cmd_get_object_orientation2,
        simx_cmd_get_object_position2,

        simx_cmd8bytes_custom_start     =0x002800,
        simx_cmd_get_object_quaternion,

        simx_cmd1string_start           =0x003000,
        /* from here on, commands are also identified by one additional string */
        simx_cmd_get_object_handle,
        simx_cmd_load_scene,
        simx_cmd_load_model,
        simx_cmd_transfer_file,
        simx_cmd_load_ui,
        simx_cmd_erase_file,
        simx_cmd_get_ui_handle,
        simx_cmd_add_statusbar_message,
        simx_cmd_aux_console_open,
        simx_cmd_get_collision_handle,
        simx_cmd_get_distance_handle,
        simx_cmd_display_dialog,
        simx_cmd_clear_float_signal,
        simx_cmd_clear_integer_signal,
        simx_cmd_clear_string_signal,
        simx_cmd_get_float_signal,
        simx_cmd_get_integer_signal,
        simx_cmd_get_string_signal,
        simx_cmd_set_float_signal,
        simx_cmd_set_integer_signal,
        simx_cmd_set_string_signal,
        simx_cmd_append_string_signal,
        simx_cmd_write_string_stream=simx_cmd_append_string_signal,
        simx_cmd_get_and_clear_string_signal,
        simx_cmd_read_string_stream,
        simx_cmd_get_collection_handle,

        simx_cmd4bytes2strings_start            =0x003400,
        /* from here on, commands are also identified by 4 additional bytes and 2 additional strings */
        simx_cmd_call_script_function,

        simx_cmd4bytes2strings_end              =0x003500,

        simx_cmd1string_custom_start    =0x003800,

        simx_cmdreserved_start          =0x004000,

        simx_cmdmask                    =0x00ffff,

        /* Regular operation modes */
        simx_opmode_oneshot             =0x000000,      /* sends command as one chunk. Reply will also come as one chunk. Doesn't wait for the reply. */
        simx_opmode_blocking            =0x010000,      /* sends command as one chunk. Reply will also come as one chunk. Waits for the reply (_REPLY_WAIT_TIMEOUT_IN_MS is the timeout). */
        simx_opmode_oneshot_wait        =0x010000,      /* same as simx_opmode_blocking */
        simx_opmode_streaming           =0x020000,      /* sends command as one chunk. Command will be stored on the server and always executed (every x ms (as far as possible), where x can be 0-65535. just add x to simx_opmode_streaming). A reply will be sent continuously, each time as one chunk. Doesn't wait for the reply. */
        simx_opmode_continuous          =0x020000,      /* same as simx_opmode_streaming */

        /* Operation modes for heavy data */
        simx_opmode_oneshot_split       =0x030000,      /* sends command as several chunks (max chunk size is x bytes, where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to simx_opmode_oneshot_split). Reply will also come as several chunks. Doesn't wait for the reply. */
        simx_opmode_streaming_split     =0x040000,      /* sends command as several chunks (max chunk size is x bytes, where x can be _MIN_SPLIT_AMOUNT_IN_BYTES-65535. Just add x to simx_opmode_streaming_split). Command will be stored on the server and always executed. A reply will be sent continuously, each time as several chunks. Doesn't wait for the reply. */
        simx_opmode_continuous_split    =0x040000,      /* same as simx_opmode_streaming_split */

        /* Special operation modes */
        simx_opmode_discontinue         =0x050000,      /* removes and cancels all commands of the given type stored on the client or server side (also streaming commands) */
        simx_opmode_buffer              =0x060000,      /* doesn't send anything, but checks if a reply for the given command is available in the input buffer (i.e. previously received from the server) */
        simx_opmode_remove              =0x070000       /* doesn't send anything and doesn't return any specific value. It just erases a similar command reply in the inbox (to free some memory) */
};

/* Command return codes (bit-coded) */
enum {  simx_return_ok                      =0x000000,
        simx_return_novalue_flag            =0x000001,      /* input buffer doesn't contain the specified command. Maybe you forgot to enable data streaming, or streaming hasn't started yet */
        simx_return_timeout_flag            =0x000002,      /* command reply not received in time for simx_opmode_blocking operation mode */
        simx_return_illegal_opmode_flag     =0x000004,      /* command doesn't support the specified operation mode */
        simx_return_remote_error_flag       =0x000008,      /* command caused an error on the server side */
        simx_return_split_progress_flag     =0x000010,      /* previous similar command not yet fully processed (applies to simx_opmode_oneshot_split operation modes) */
        simx_return_local_error_flag        =0x000020,      /* command caused an error on the client side */
        simx_return_initialize_error_flag   =0x000040       /* simxStart was not yet called */
};

/* Following only for backward compatibility, but equivalent to above return values */
enum {  simx_error_noerror                  =0x000000,
        simx_error_novalue_flag             =0x000001,
        simx_error_timeout_flag             =0x000002,
        simx_error_illegal_opmode_flag      =0x000004,
        simx_error_remote_error_flag        =0x000008,
        simx_error_split_progress_flag      =0x000010,
        simx_error_local_error_flag         =0x000020,
        simx_error_initialize_error_flag    =0x000040
};


/******************************************
*******************************************
ROS API constants:
*******************************************
*******************************************/


/* All stream command codes (followed by operation mode codes) */
enum {  simros_strmcmdnull_start                =0,

        /* from here on, commands are only identified by their code */
        simros_strmcmd_get_object_selection,
        simros_strmcmd_get_info, // do not use. Is streamed anyway with topic name "info"

        simros_strmcmdnull_subscriber_start         =0x000800,
        simros_strmcmd_add_status_bar_message,
        simros_strmcmd_set_object_selection,
        simros_strmcmd_set_joint_state,


        simros_strmcmdint_start         =0x001000,
        /* from here on, commands are also identified by 1 additional int */
        simros_strmcmd_get_array_parameter,
        simros_strmcmd_get_boolean_parameter,
        simros_strmcmd_get_dialog_result,
        simros_strmcmd_get_floating_parameter,
        simros_strmcmd_get_integer_parameter,
        simros_strmcmd_get_joint_state,
        simros_strmcmd_get_object_parent,
        simros_strmcmd_get_objects,
        simros_strmcmd_get_string_parameter,
        simros_strmcmd_get_ui_event_button,
        simros_strmcmd_get_vision_sensor_depth_buffer,
        simros_strmcmd_get_vision_sensor_image,
        simros_strmcmd_read_collision,
        simros_strmcmd_read_distance,
        simros_strmcmd_read_force_sensor,
        simros_strmcmd_read_proximity_sensor,
        simros_strmcmd_read_vision_sensor,
        simros_strmcmd_get_vision_sensor_info,
        simros_strmcmd_get_range_finder_data,
        simros_strmcmd_get_laser_scanner_data,
        simros_strmcmd_get_odom_data,
        simros_strmcmd_get_depth_sensor_data,

        simros_strmcmdint_subscriber_start          =0x001800,
        simros_strmcmd_auxiliary_console_print,
        simros_strmcmd_set_array_parameter,
        simros_strmcmd_set_boolean_parameter,
        simros_strmcmd_set_floating_parameter,
        simros_strmcmd_set_integer_parameter,
        simros_strmcmd_set_joint_force,
        simros_strmcmd_set_joint_position,
        simros_strmcmd_set_joint_target_position,
        simros_strmcmd_set_joint_target_velocity,
        simros_strmcmd_set_vision_sensor_image,
        simros_strmcmd_set_joy_sensor,
        simros_strmcmd_set_twist_command,


        simros_strmcmdintint_start          =0x002000,
        /* from here on, commands are also identified by 2 additional ints */
        simros_strmcmd_get_object_pose,
        simros_strmcmd_get_object_float_parameter,
        simros_strmcmd_get_object_int_parameter,
        simros_strmcmd_get_ui_button_property,
        simros_strmcmd_get_ui_slider,
        simros_strmcmd_get_transform,
        simros_strmcmd_get_object_group_data,

        simros_strmcmdintint_subscriber_start           =0x002800,
        simros_strmcmd_set_object_float_parameter,
        simros_strmcmd_set_object_int_parameter,
        simros_strmcmd_set_object_pose,
        simros_strmcmd_set_object_position,
        simros_strmcmd_set_object_quaternion,
        simros_strmcmd_set_ui_button_label,
        simros_strmcmd_set_ui_button_property,
        simros_strmcmd_set_ui_slider,


        simros_strmcmdstring_start          =0x003000,
        /* from here on, commands are also identified by one additional string */
        simros_strmcmd_get_float_signal,
        simros_strmcmd_get_integer_signal,
        simros_strmcmd_get_string_signal,
        simros_strmcmd_reserved1,
        simros_strmcmd_get_and_clear_string_signal,

        simros_strmcmdstring_subscriber_start           =0x003800,
        simros_strmcmd_clear_float_signal,
        simros_strmcmd_clear_integer_signal,
        simros_strmcmd_clear_string_signal,
        simros_strmcmd_set_float_signal,
        simros_strmcmd_set_integer_signal,
        simros_strmcmd_set_string_signal,
        simros_strmcmd_reserved2,
        simros_strmcmd_append_string_signal,
        simros_strmcmd_set_joint_trajectory,

        simros_strmcmdintstring_start           =0x004000,
        /* from here on, commands are also identified by one additional int and one additional string */
        simros_strmcmd_get_twist_status,
        simros_strmcmd_receive_data_from_script_function,

        simros_strmcmdintstring_subscriber_start            =0x004800,
        simros_strmcmd_send_data_to_script_function,


        simros_strmcmdreserved_start            =0x005000,
};

#endif /* !defined(SIMCONST_INCLUDED_) */
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.41">@path ./v-rep_plugin/coppelia/include/
// Use this header to dynamically load and bind coppeliaSim.dll and its functions (call loadSimLibrary and unloadSimLibrary)

#if !defined(SIMLIB_INCLUDED_)
#define SIMLIB_INCLUDED_

#include "simConst.h"
#include "simTypes.h"

#ifdef QT_FRAMEWORK
    #include &lt;QLibrary&gt;
    #define LIBRARY QLibrary*
    #define __cdecl
    #define FARPROC void*
#else
    #ifdef _WIN32
        #include &lt;Windows.h&gt;
        #define LIBRARY HINSTANCE
    #elif defined (__linux) || defined (__APPLE__)
        #define __cdecl
        #define FARPROC void*
        #define LIBRARY void*
    #endif
#endif // QT_FRAMEWORK

int getSimProcAddresses(LIBRARY lib);
LIBRARY loadSimLibrary(const char* pathAndFilename);
void unloadSimLibrary(LIBRARY lib);
FARPROC _getProcAddress(LIBRARY lib,const char* funcName);

typedef simInt (__cdecl *ptrSimRunSimulator)(const simChar* applicationName,simInt options,simVoid(*initCallBack)(),simVoid(*loopCallBack)(),simVoid(*deinitCallBack)());
typedef simInt (__cdecl *ptrSimRunSimulatorEx)(const simChar* applicationName,simInt options,simVoid(*initCallBack)(),simVoid(*loopCallBack)(),simVoid(*deinitCallBack)(),simInt stopDelay,const simChar* sceneOrModelToLoad);
typedef simChar* (__cdecl *ptrSimGetSimulatorMessage)(simInt* messageID,simInt* auxiliaryData,simInt* returnedDataSize);
typedef simVoid* (__cdecl *ptrSimGetMainWindow)(simInt type);
typedef simChar* (__cdecl *ptrSimGetLastError)();
typedef simInt (__cdecl *ptrSimLoadModule)(const simChar* filenameAndPath,const simChar* pluginName);
typedef simInt (__cdecl *ptrSimUnloadModule)(simInt pluginhandle);
typedef simVoid* (__cdecl *ptrSimSendModuleMessage)(simInt message,simInt* auxiliaryData,simVoid* customData,simInt* replyData);
typedef simInt (__cdecl *ptrSimSetBooleanParameter)(simInt parameter,simBool boolState);
typedef simInt (__cdecl *ptrSimGetBooleanParameter)(simInt parameter);
typedef simInt (__cdecl *ptrSimSetBoolParameter)(simInt parameter,simBool boolState);
typedef simInt (__cdecl *ptrSimGetBoolParameter)(simInt parameter);
typedef simInt (__cdecl *ptrSimSetIntegerParameter)(simInt parameter,simInt intState);
typedef simInt (__cdecl *ptrSimGetIntegerParameter)(simInt parameter,simInt* intState);
typedef simInt (__cdecl *ptrSimSetInt32Parameter)(simInt parameter,simInt intState);
typedef simInt (__cdecl *ptrSimGetInt32Parameter)(simInt parameter,simInt* intState);
typedef simInt (__cdecl *ptrSimGetUInt64Parameter)(simInt parameter,simUInt64* intState);
typedef simInt (__cdecl *ptrSimSetFloatingParameter)(simInt parameter,simFloat floatState);
typedef simInt (__cdecl *ptrSimGetFloatingParameter)(simInt parameter,simFloat* floatState);
typedef simInt (__cdecl *ptrSimSetFloatParameter)(simInt parameter,simFloat floatState);
typedef simInt (__cdecl *ptrSimGetFloatParameter)(simInt parameter,simFloat* floatState);
typedef simInt (__cdecl *ptrSimSetStringParameter)(simInt parameter,const simChar* stringState);
typedef simChar* (__cdecl *ptrSimGetStringParameter)(simInt parameter);
typedef simInt (__cdecl *ptrSimGetObjectHandle)(const simChar* objectName);
typedef simInt (__cdecl *ptrSimRemoveObject)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimRemoveModel)(simInt objectHandle);
typedef simChar* (__cdecl *ptrSimGetObjectName)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetObjects)(simInt index,simInt objectType);
typedef simInt (__cdecl *ptrSimSetObjectName)(simInt objectHandle,const simChar* objectName);
typedef simInt (__cdecl *ptrSimGetCollectionHandle)(const simChar* collectionName);
typedef simInt (__cdecl *ptrSimRemoveCollection)(simInt collectionHandle);
typedef simInt (__cdecl *ptrSimEmptyCollection)(simInt collectionHandle);
typedef simChar* (__cdecl *ptrSimGetCollectionName)(simInt collectionHandle);
typedef simInt (__cdecl *ptrSimSetCollectionName)(simInt collectionHandle,const simChar* collectionName);
typedef simInt (__cdecl *ptrSimGetObjectMatrix)(simInt objectHandle,simInt relativeToObjectHandle,simFloat* matrix);
typedef simInt (__cdecl *ptrSimSetObjectMatrix)(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* matrix);
typedef simInt (__cdecl *ptrSimGetObjectPosition)(simInt objectHandle,simInt relativeToObjectHandle,simFloat* position);
typedef simInt (__cdecl *ptrSimSetObjectPosition)(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* position);
typedef simInt (__cdecl *ptrSimGetObjectOrientation)(simInt objectHandle,simInt relativeToObjectHandle,simFloat* eulerAngles);
typedef simInt (__cdecl *ptrSimSetObjectOrientation)(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* eulerAngles);
typedef simInt (__cdecl *ptrSimGetJointPosition)(simInt objectHandle,simFloat* position);
typedef simInt (__cdecl *ptrSimSetJointPosition)(simInt objectHandle,simFloat position);
typedef simInt (__cdecl *ptrSimSetJointTargetPosition)(simInt objectHandle,simFloat targetPosition);
typedef simInt (__cdecl *ptrSimGetJointTargetPosition)(simInt objectHandle,simFloat* targetPosition);
typedef simInt (__cdecl *ptrSimSetJointMaxForce)(simInt objectHandle,simFloat forceOrTorque);
typedef simInt (__cdecl *ptrSimGetPathPosition)(simInt objectHandle,simFloat* position);
typedef simInt (__cdecl *ptrSimSetPathPosition)(simInt objectHandle,simFloat position);
typedef simInt (__cdecl *ptrSimGetPathLength)(simInt objectHandle,simFloat* length);
typedef simInt (__cdecl *ptrSimGetJointMatrix)(simInt objectHandle,simFloat* matrix);
typedef simInt (__cdecl *ptrSimSetSphericalJointMatrix)(simInt objectHandle,const simFloat* matrix);
typedef simInt (__cdecl *ptrSimGetJointInterval)(simInt objectHandle,simBool* cyclic,simFloat* interval);
typedef simInt (__cdecl *ptrSimSetJointInterval)(simInt objectHandle,simBool cyclic,const simFloat* interval);
typedef simInt (__cdecl *ptrSimGetObjectParent)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetObjectChild)(simInt objectHandle,simInt index);
typedef simInt (__cdecl *ptrSimSetObjectParent)(simInt objectHandle,simInt parentObjectHandle,simBool keepInPlace);
typedef simInt (__cdecl *ptrSimGetObjectType)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetJointType)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimBuildIdentityMatrix)(simFloat* matrix);
typedef simInt (__cdecl *ptrSimCopyMatrix)(const simFloat* matrixIn,simFloat* matrixOut);
typedef simInt (__cdecl *ptrSimBuildMatrix)(const simFloat* position,const simFloat* eulerAngles,simFloat* matrix);
typedef simInt (__cdecl *ptrSimGetEulerAnglesFromMatrix)(const simFloat* matrix,simFloat* eulerAngles);
typedef simInt (__cdecl *ptrSimInvertMatrix)(simFloat* matrix);
typedef simInt (__cdecl *ptrSimMultiplyMatrices)(const simFloat* matrixIn1,const simFloat* matrixIn2,simFloat* matrixOut);
typedef simInt (__cdecl *ptrSimInterpolateMatrices)(const simFloat* matrixIn1,const simFloat* matrixIn2,simFloat interpolFactor,simFloat* matrixOut);
typedef simInt (__cdecl *ptrSimTransformVector)(const simFloat* matrix,simFloat* vect);
typedef simInt (__cdecl *ptrSimReservedCommand)(simInt v,simInt w);
typedef simFloat (__cdecl *ptrSimGetSimulationTime)();
typedef simInt (__cdecl *ptrSimGetSimulationState)();
typedef simFloat (__cdecl *ptrSimGetSystemTime)();
typedef simInt (__cdecl *ptrSimGetSystemTimeInMilliseconds)();
typedef simUInt (__cdecl *ptrSimGetSystemTimeInMs)(simInt previousTime);
typedef simInt (__cdecl *ptrSimLoadScene)(const simChar* filename);
typedef simInt (__cdecl *ptrSimCloseScene)();
typedef simInt (__cdecl *ptrSimSaveScene)(const simChar* filename);
typedef simInt (__cdecl *ptrSimLoadModel)(const simChar* filename);
typedef simInt (__cdecl *ptrSimSaveModel)(int baseOfModelHandle,const simChar* filename);
typedef simInt (__cdecl *ptrSimAddStatusbarMessage)(const simChar* message);
typedef simInt (__cdecl *ptrSimAddModuleMenuEntry)(const simChar* entryLabel,simInt itemCount,simInt* itemHandles);
typedef simInt (__cdecl *ptrSimSetModuleMenuItemState)(simInt itemHandle,simInt state,const simChar* label);
typedef simInt (__cdecl *ptrSimDoesFileExist)(const simChar* filename);
typedef simInt (__cdecl *ptrSimIsObjectInSelection)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimAddObjectToSelection)(simInt what,simInt objectHandle);
typedef simInt (__cdecl *ptrSimRemoveObjectFromSelection)(simInt what,simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetObjectSelectionSize)();
typedef simInt (__cdecl *ptrSimGetObjectLastSelection)();
typedef simInt (__cdecl *ptrSimGetObjectSelection)(simInt* objectHandles);
typedef simInt (__cdecl *ptrSimHandleCollision)(simInt collisionObjectHandle);
typedef simInt (__cdecl *ptrSimReadCollision)(simInt collisionObjectHandle);
typedef simInt (__cdecl *ptrSimHandleDistance)(simInt distanceObjectHandle,simFloat* smallestDistance);
typedef simInt (__cdecl *ptrSimReadDistance)(simInt distanceObjectHandle,simFloat* smallestDistance);
typedef simInt (__cdecl *ptrSimHandleProximitySensor)(simInt sensorHandle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* normalVector);
typedef simInt (__cdecl *ptrSimReadProximitySensor)(simInt sensorHandle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* normalVector);
typedef simInt (__cdecl *ptrSimHandleMill)(simInt millHandle,simFloat* removedSurfaceAndVolume);
typedef simInt (__cdecl *ptrSimHandleIkGroup)(simInt ikGroupHandle);
typedef simInt (__cdecl *ptrSimCheckIkGroup)(simInt ikGroupHandle,simInt jointCnt,const simInt* jointHandles,simFloat* jointValues,const simInt* jointOptions);
typedef simInt (__cdecl *ptrSimHandleDynamics)(simFloat deltaTime);
typedef simInt (__cdecl *ptrSimGetScriptHandle)(const simChar* scriptName);
typedef simInt (__cdecl *ptrSimSetScriptText)(simInt scriptHandle,const simChar* scriptText);
typedef const simChar* (__cdecl *ptrSimGetScriptText)(simInt scriptHandle);
typedef simInt (__cdecl *ptrSimGetScriptProperty)(simInt scriptHandle,simInt* scriptProperty,simInt* associatedObjectHandle);
typedef simInt (__cdecl *ptrSimAssociateScriptWithObject)(simInt scriptHandle,simInt associatedObjectHandle);
typedef simInt (__cdecl *ptrSimGetScript)(simInt index);
typedef simInt (__cdecl *ptrSimGetScriptAssociatedWithObject)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetCustomizationScriptAssociatedWithObject)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetObjectAssociatedWithScript)(simInt scriptHandle);
typedef simChar* (__cdecl *ptrSimGetScriptName)(simInt scriptHandle);
typedef simInt (__cdecl *ptrSimHandleMainScript)();
typedef simInt (__cdecl *ptrSimResetScript)(simInt scriptHandle);
typedef simInt (__cdecl *ptrSimAddScript)(simInt scriptProperty);
typedef simInt (__cdecl *ptrSimRemoveScript)(simInt scriptHandle);
typedef simInt (__cdecl *ptrSimRefreshDialogs)(simInt refreshDegree);
typedef simInt (__cdecl *ptrSimGetCollisionHandle)(const simChar* collisionObjectName);
typedef simInt (__cdecl *ptrSimGetDistanceHandle)(const simChar* distanceObjectName);
typedef simInt (__cdecl *ptrSimGetIkGroupHandle)(const simChar* ikGroupName);
typedef simInt (__cdecl *ptrSimResetCollision)(simInt collisionObjectHandle);
typedef simInt (__cdecl *ptrSimResetDistance)(simInt distanceObjectHandle);
typedef simInt (__cdecl *ptrSimResetProximitySensor)(simInt sensorHandle);
typedef simInt (__cdecl *ptrSimResetMill)(simInt millHandle);
typedef simInt (__cdecl *ptrSimCheckProximitySensor)(simInt sensorHandle,simInt entityHandle,simFloat* detectedPoint);
typedef simInt (__cdecl *ptrSimCheckProximitySensorEx)(simInt sensorHandle,simInt entityHandle,simInt detectionMode,simFloat detectionThreshold,simFloat maxAngle,simFloat* detectedPoint,simInt* detectedObjectHandle,simFloat* normalVector);
typedef simInt (__cdecl *ptrSimCheckProximitySensorEx2)(simInt sensorHandle,simFloat* vertexPointer,simInt itemType,simInt itemCount,simInt detectionMode,simFloat detectionThreshold,simFloat maxAngle,simFloat* detectedPoint,simFloat* normalVector);
typedef simChar* (__cdecl *ptrSimCreateBuffer)(simInt size);
typedef simInt (__cdecl *ptrSimReleaseBuffer)(const simChar* buffer);
typedef simInt (__cdecl *ptrSimCheckCollision)(simInt entity1Handle,simInt entity2Handle);
typedef simInt (__cdecl *ptrSimCheckCollisionEx)(simInt entity1Handle,simInt entity2Handle,simFloat** intersectionSegments);
typedef simInt (__cdecl *ptrSimCheckDistance)(simInt entity1Handle,simInt entity2Handle,simFloat threshold,simFloat* distanceData);
typedef simChar* (__cdecl *ptrSimGetObjectConfiguration)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimSetObjectConfiguration)(const simChar* data);
typedef simChar* (__cdecl *ptrSimGetConfigurationTree)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimSetConfigurationTree)(const simChar* data);
typedef simInt (__cdecl *ptrSimSetSimulationTimeStep)(simFloat timeStep);
typedef simFloat (__cdecl *ptrSimGetSimulationTimeStep)();
typedef simInt (__cdecl *ptrSimGetRealTimeSimulation)();
typedef simInt (__cdecl *ptrSimIsRealTimeSimulationStepNeeded)();
typedef simInt (__cdecl *ptrSimAdjustRealTimeTimer)(simInt instanceIndex,simFloat deltaTime);
typedef simInt (__cdecl *ptrSimGetSimulationPassesPerRenderingPass)();
typedef simInt (__cdecl *ptrSimAdvanceSimulationByOneStep)();
typedef simInt (__cdecl *ptrSimStartSimulation)();
typedef simInt (__cdecl *ptrSimStopSimulation)();
typedef simInt (__cdecl *ptrSimPauseSimulation)();
typedef simVoid* (__cdecl *ptrSimBroadcastMessage)(simInt* auxiliaryData,simVoid* customData,simInt* replyData);
typedef simChar* (__cdecl *ptrSimGetModuleName)(simInt index,simUChar* moduleVersion);
typedef simInt (__cdecl *ptrSimFloatingViewAdd)(simFloat posX,simFloat posY,simFloat sizeX,simFloat sizeY,simInt options);
typedef simInt (__cdecl *ptrSimFloatingViewRemove)(simInt floatingViewHandle);
typedef simInt (__cdecl *ptrSimAdjustView)(simInt viewHandleOrIndex,simInt associatedViewableObjectHandle,simInt options,const simChar* viewLabel);
typedef simInt (__cdecl *ptrSimSetLastError)(const simChar* funcName,const simChar* errorMessage);
typedef simInt (__cdecl *ptrSimHandleGraph)(simInt graphHandle,simFloat simulationTime);
typedef simInt (__cdecl *ptrSimResetGraph)(simInt graphHandle);
typedef simInt (__cdecl *ptrSimSetNavigationMode)(simInt navigationMode);
typedef simInt (__cdecl *ptrSimGetNavigationMode)();
typedef simInt (__cdecl *ptrSimSetPage)(simInt index);
typedef simInt (__cdecl *ptrSimGetPage)();
typedef simInt (__cdecl *ptrSimDisplayDialog)(const simChar* titleText,const simChar* mainText,simInt dialogType,const simChar* initialText,const simFloat* titleColors,const simFloat* dialogColors,simInt* elementHandle);
typedef simInt (__cdecl *ptrSimGetDialogResult)(simInt genericDialogHandle);
typedef simChar* (__cdecl *ptrSimGetDialogInput)(simInt genericDialogHandle);
typedef simInt (__cdecl *ptrSimEndDialog)(simInt genericDialogHandle);
typedef simInt (__cdecl *ptrSimRegisterScriptCallbackFunction)(const simChar* funcNameAtPluginName,const simChar* callTips,simVoid(*callBack)(struct SScriptCallBack* cb));
typedef simInt (__cdecl *ptrSimRegisterScriptVariable)(const simChar* varNameAtPluginName,const simChar* varValue,simInt stackHandle);
typedef simInt (__cdecl *ptrSimSetJointTargetVelocity)(simInt objectHandle,simFloat targetVelocity);
typedef simInt (__cdecl *ptrSimGetJointTargetVelocity)(simInt objectHandle,simFloat* targetVelocity);
typedef simInt (__cdecl *ptrSimSetPathTargetNominalVelocity)(simInt objectHandle,simFloat targetNominalVelocity);
typedef simChar* (__cdecl *ptrSimGetScriptRawBuffer)(simInt scriptHandle,simInt bufferHandle);
typedef simInt (__cdecl *ptrSimSetScriptRawBuffer)(simInt scriptHandle,const simChar* buffer,simInt bufferSize);
typedef simInt (__cdecl *ptrSimReleaseScriptRawBuffer)(simInt scriptHandle,simInt bufferHandle);
typedef simInt (__cdecl *ptrSimCopyPasteObjects)(simInt* objectHandles,simInt objectCount,simInt options);
typedef simInt (__cdecl *ptrSimScaleSelectedObjects)(simFloat scalingFactor,simBool scalePositionsToo);
typedef simInt (__cdecl *ptrSimScaleObjects)(const simInt* objectHandles,simInt objectCount,simFloat scalingFactor,simBool scalePositionsToo);
typedef simInt (__cdecl *ptrSimDeleteSelectedObjects)();
typedef simInt (__cdecl *ptrSimGetObjectUniqueIdentifier)(simInt objectHandle,simInt* uniqueIdentifier);
typedef simInt (__cdecl *ptrSimGetNameSuffix)(const simChar* name);
typedef simInt (__cdecl *ptrSimSendData)(simInt targetID,simInt dataHeader,const simChar* dataName,const simChar* data,simInt dataLength,simInt antennaHandle,simFloat actionRadius,simFloat emissionAngle1,simFloat emissionAngle2,simFloat persistence);
typedef simChar* (__cdecl *ptrSimReceiveData)(simInt dataHeader,const simChar* dataName,simInt antennaHandle,simInt index,simInt* dataLength,simInt* senderID,simInt* dataHeaderR,simChar** dataNameR);
typedef simInt (__cdecl *ptrSimSetGraphUserData)(simInt graphHandle,const simChar* dataStreamName,simFloat data);
typedef simInt (__cdecl *ptrSimSetNameSuffix)(simInt nameSuffixNumber);
typedef simInt (__cdecl *ptrSimAddDrawingObject)(simInt objectType,simFloat size,simFloat duplicateTolerance,simInt parentObjectHandle,simInt maxItemCount,const simFloat* ambient_diffuse,const simFloat* setToNULL,const simFloat* specular,const simFloat* emission);
typedef simInt (__cdecl *ptrSimRemoveDrawingObject)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimAddDrawingObjectItem)(simInt objectHandle,const simFloat* itemData);
typedef simInt (__cdecl *ptrSimAddParticleObject)(simInt objectType,simFloat size,simFloat density,const simVoid* params,simFloat lifeTime,simInt maxItemCount,const simFloat* ambient_diffuse,const simFloat* setToNULL,const simFloat* specular,const simFloat* emission);
typedef simInt (__cdecl *ptrSimRemoveParticleObject)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimAddParticleObjectItem)(simInt objectHandle,const simFloat* itemData);
typedef simFloat (__cdecl *ptrSimGetObjectSizeFactor)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimAnnounceSceneContentChange)();
typedef simInt (__cdecl *ptrSimResetMilling)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimApplyMilling)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimSetIntegerSignal)(const simChar* signalName,simInt signalValue);
typedef simInt (__cdecl *ptrSimGetIntegerSignal)(const simChar* signalName,simInt* signalValue);
typedef simInt (__cdecl *ptrSimClearIntegerSignal)(const simChar* signalName);
typedef simInt (__cdecl *ptrSimSetFloatSignal)(const simChar* signalName,simFloat signalValue);
typedef simInt (__cdecl *ptrSimGetFloatSignal)(const simChar* signalName,simFloat* signalValue);
typedef simInt (__cdecl *ptrSimClearFloatSignal)(const simChar* signalName);
typedef simInt (__cdecl *ptrSimSetDoubleSignal)(const simChar* signalName,simDouble signalValue);
typedef simInt (__cdecl *ptrSimGetDoubleSignal)(const simChar* signalName,simDouble* signalValue);
typedef simInt (__cdecl *ptrSimClearDoubleSignal)(const simChar* signalName);
typedef simInt (__cdecl *ptrSimSetStringSignal)(const simChar* signalName,const simChar* signalValue,simInt stringLength);
typedef simChar* (__cdecl *ptrSimGetStringSignal)(const simChar* signalName,simInt* stringLength);
typedef simInt (__cdecl *ptrSimClearStringSignal)(const simChar* signalName);
typedef simChar* (__cdecl *ptrSimGetSignalName)(simInt signalIndex,simInt signalType);
typedef simInt (__cdecl *ptrSimSetObjectProperty)(simInt objectHandle,simInt prop);
typedef simInt (__cdecl *ptrSimGetObjectProperty)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimSetObjectSpecialProperty)(simInt objectHandle,simInt prop);
typedef simInt (__cdecl *ptrSimGetObjectSpecialProperty)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetPositionOnPath)(simInt pathHandle,simFloat relativeDistance,simFloat* position);
typedef simInt (__cdecl *ptrSimGetOrientationOnPath)(simInt pathHandle,simFloat relativeDistance,simFloat* eulerAngles);
typedef simInt (__cdecl *ptrSimGetDataOnPath)(simInt pathHandle,simFloat relativeDistance,simInt dataType,simInt* intData,simFloat* floatData);
typedef simInt (__cdecl *ptrSimGetClosestPositionOnPath)(simInt pathHandle,simFloat* absolutePosition,simFloat* pathPosition);
typedef simInt (__cdecl *ptrSimReadForceSensor)(simInt objectHandle,simFloat* forceVector,simFloat* torqueVector);
typedef simInt (__cdecl *ptrSimBreakForceSensor)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimGetShapeVertex)(simInt shapeHandle,simInt groupElementIndex,simInt vertexIndex,simFloat* relativePosition);
typedef simInt (__cdecl *ptrSimGetShapeTriangle)(simInt shapeHandle,simInt groupElementIndex,simInt triangleIndex,simInt* vertexIndices,simFloat* triangleNormals);
typedef simInt (__cdecl *ptrSimSetLightParameters)(simInt objectHandle,simInt state,const simFloat* setToNULL,const simFloat* diffusePart,const simFloat* specularPart);
typedef simInt (__cdecl *ptrSimGetLightParameters)(simInt objectHandle,simFloat* setToNULL,simFloat* diffusePart,simFloat* specularPart);
typedef simInt (__cdecl *ptrSimGetVelocity)(simInt shapeHandle,simFloat* linearVelocity,simFloat* angularVelocity);
typedef simInt (__cdecl *ptrSimGetObjectVelocity)(simInt objectHandle,simFloat* linearVelocity,simFloat* angularVelocity);
typedef simInt (__cdecl *ptrSimAddForceAndTorque)(simInt shapeHandle,const simFloat* force,const simFloat* torque);
typedef simInt (__cdecl *ptrSimAddForce)(simInt shapeHandle,const simFloat* position,const simFloat* force);
typedef simInt (__cdecl *ptrSimSetExplicitHandling)(simInt generalObjectHandle,int explicitFlags);
typedef simInt (__cdecl *ptrSimGetExplicitHandling)(simInt generalObjectHandle);
typedef simInt (__cdecl *ptrSimGetLinkDummy)(simInt dummyHandle);
typedef simInt (__cdecl *ptrSimSetLinkDummy)(simInt dummyHandle,simInt linkedDummyHandle);
typedef simInt (__cdecl *ptrSimSetModelProperty)(simInt objectHandle,simInt modelProperty);
typedef simInt (__cdecl *ptrSimGetModelProperty)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimSetShapeColor)(simInt shapeHandle,const simChar* colorName,simInt colorComponent,const simFloat* rgbData);
typedef simInt (__cdecl *ptrSimGetShapeColor)(simInt shapeHandle,const simChar* colorName,simInt colorComponent,simFloat* rgbData);
typedef simInt (__cdecl *ptrSimResetDynamicObject)(simInt objectHandle);
typedef simInt (__cdecl *ptrSimSetJointMode)(simInt jointHandle,simInt jointMode,simInt options);
typedef simInt (__cdecl *ptrSimGetJointMode)(simInt jointHandle,simInt* options);
typedef simInt (__cdecl *ptrSimSerialOpen)(const simChar* portString,simInt baudRate,simVoid* reserved1,simVoid* reserved2);
typedef simInt (__cdecl *ptrSimSerialClose)(simInt portHandle);
typedef simInt (__cdecl *ptrSimSerialSend)(simInt portHandle,const simChar* data,simInt dataLength);
typedef simInt (__cdecl *ptrSimSerialRead)(simInt portHandle,simChar* buffer,simInt dataLengthToRead);
typedef simInt (__cdecl *ptrSimSerialCheck)(simInt portHandle);
typedef simInt (__cdecl *ptrSimGetContactInfo)(simInt dynamicPass,simInt objectHandle,simInt index,simInt* objectHandles,simFloat* contactInfo);
typedef simInt (__cdecl *ptrSimSetThreadIsFree)(simBool freeMode);
typedef simInt (__cdecl *ptrSimTubeOpen)(simInt dataHeader,const simChar* dataName,simInt readBufferSize,simBool notUsedButKeepFalse);
typedef simInt (__cdecl *ptrSimTubeClose)(simInt tubeHandle);
typedef simInt (__cdecl *ptrSimTubeWrite)(simInt tubeHandle,const simChar* data,simInt dataLength);
typedef simChar* (__cdecl *ptrSimTubeRead)(simInt tubeHandle,simInt* dataLength);
typedef simInt (__cdecl *ptrSimTubeStatus)(simInt tubeHandle,simInt* readPacketsCount,simInt* writePacketsCount);
typedef simInt (__cdecl *ptrSimAuxiliaryConsoleOpen)(const simChar* title,simInt maxLines,simInt mode,const simInt* position,const simInt* size,const simFloat* textColor,const simFloat* backgroundColor);
typedef simInt (__cdecl *ptrSimAuxiliaryConsoleClose)(simInt consoleHandle);
typedef simInt (__cdecl *ptrSimAuxiliaryConsoleShow)(simInt consoleHandle,simBool showState);
typedef simInt (__cdecl *ptrSimAuxiliaryConsolePrint)(simInt consoleHandle,const simChar* text);
typedef simInt (__cdecl *ptrSimImportShape)(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat identicalVerticeTolerance,simFloat scalingFactor);
typedef simInt (__cdecl *ptrSimImportMesh)(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat identicalVerticeTolerance,simFloat scalingFactor,simFloat*** vertices,simInt** verticesSizes,simInt*** indices,simInt** indicesSizes,simFloat*** reserved,simChar*** names);
typedef simInt (__cdecl *ptrSimExportMesh)(simInt fileformat,const simChar* pathAndFilename,simInt options,simFloat scalingFactor,simInt elementCount,const simFloat** vertices,const simInt* verticesSizes,const simInt** indices,const simInt* indicesSizes,simFloat** reserved,const simChar** names);
typedef simInt (__cdecl *ptrSimCreateMeshShape)(simInt options,simFloat shadingAngle,const simFloat* vertices,simInt verticesSize,const simInt* indices,simInt indicesSize,simFloat* reserved);
typedef simInt (__cdecl *ptrSimCreatePureShape)(simInt primitiveType,simInt options,const simFloat* sizes,simFloat mass,const simInt* precision);
typedef simInt (__cdecl *ptrSimCreateHeightfieldShape)(simInt options,simFloat shadingAngle,simInt xPointCount,simInt yPointCount,simFloat xSize,const simFloat* heights);
typedef simInt (__cdecl *ptrSimGetShapeMesh)(simInt shapeHandle,simFloat** vertices,simInt* verticesSize,simInt** indices,simInt* indicesSize,simFloat** normals);
typedef simInt (__cdecl *ptrSimAddBanner)(const simChar* label,simFloat size,simInt options,const simFloat* positionAndEulerAngles,simInt parentObjectHandle,const simFloat* labelColors,const simFloat* backgroundColors);
typedef simInt (__cdecl *ptrSimRemoveBanner)(simInt bannerID);
typedef simInt (__cdecl *ptrSimCreateJoint)(simInt jointType,simInt jointMode,simInt options,const simFloat* sizes,const simFloat* colorA,const simFloat* colorB);
typedef simInt (__cdecl *ptrSimCreateDummy)(simFloat size,const simFloat* color);
typedef simInt (__cdecl *ptrSimCreateForceSensor)(simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color);
typedef simInt (__cdecl *ptrSimCreateVisionSensor)(simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color);
typedef simInt (__cdecl *ptrSimCreateProximitySensor)(simInt sensorType,simInt subType,simInt options,const simInt* intParams,const simFloat* floatParams,const simFloat* color);
typedef simInt (__cdecl *ptrSimCreatePath)(simInt attributes,const simInt* intParams,const simFloat* floatParams,const simFloat* color);
typedef simInt (__cdecl *ptrSimInsertPathCtrlPoints)(simInt pathHandle,simInt options,simInt startIndex,simInt ptCnt,const simVoid* ptData);
typedef simInt (__cdecl *ptrSimCutPathCtrlPoints)(simInt pathHandle,simInt startIndex,simInt ptCnt);
typedef simInt (__cdecl *ptrSimGetObjectIntParameter)(simInt objectHandle,simInt parameterID,simInt* parameter);
typedef simInt (__cdecl *ptrSimSetObjectIntParameter)(simInt objectHandle,simInt parameterID,simInt parameter);
typedef simInt (__cdecl *ptrSimGetObjectInt32Parameter)(simInt objectHandle,simInt parameterID,simInt* parameter);
typedef simInt (__cdecl *ptrSimSetObjectInt32Parameter)(simInt objectHandle,simInt parameterID,simInt parameter);
typedef simInt (__cdecl *ptrSimGetObjectFloatParameter)(simInt objectHandle,simInt parameterID,simFloat* parameter);
typedef simInt (__cdecl *ptrSimSetObjectFloatParameter)(simInt objectHandle,simInt parameterID,simFloat parameter);
typedef simChar* (__cdecl *ptrSimGetObjectStringParameter)(simInt objectHandle,simInt parameterID,simInt* parameterLength);
typedef simInt (__cdecl *ptrSimSetObjectStringParameter)(simInt objectHandle,simInt parameterID,simChar* parameter,simInt parameterLength);
typedef simInt (__cdecl *ptrSimSetSimulationPassesPerRenderingPass)(simInt p);
typedef simInt (__cdecl *ptrSimGetRotationAxis)(const simFloat* matrixStart,const simFloat* matrixGoal,simFloat* axis,simFloat* angle);
typedef simInt (__cdecl *ptrSimRotateAroundAxis)(const simFloat* matrixIn,const simFloat* axis,const simFloat* axisPos,simFloat angle,simFloat* matrixOut);
typedef simInt (__cdecl *ptrSimGetJointForce)(simInt jointHandle,simFloat* forceOrTorque);
typedef simInt (__cdecl *ptrSimGetJointMaxForce)(simInt jointHandle,simFloat* forceOrTorque);
typedef simInt (__cdecl *ptrSimSetArrayParameter)(simInt parameter,const simVoid* arrayOfValues);
typedef simInt (__cdecl *ptrSimGetArrayParameter)(simInt parameter,simVoid* arrayOfValues);
typedef simInt (__cdecl *ptrSimSetIkGroupProperties)(simInt ikGroupHandle,simInt resolutionMethod,simInt maxIterations,simFloat damping,void* reserved);
typedef simInt (__cdecl *ptrSimSetIkElementProperties)(simInt ikGroupHandle,simInt tipDummyHandle,simInt constraints,const simFloat* precision,const simFloat* weight,void* reserved);
typedef simInt (__cdecl *ptrSimCameraFitToView)(simInt viewHandleOrIndex,simInt objectCount,const simInt* objectHandles,simInt options,simFloat scaling);
typedef simInt (__cdecl *ptrSimPersistentDataWrite)(const simChar* dataName,const simChar* dataValue,simInt dataLength,simInt options);
typedef simChar* (__cdecl *ptrSimPersistentDataRead)(const simChar* dataName,simInt* dataLength);
typedef simInt (__cdecl *ptrSimIsHandleValid)(simInt generalObjectHandle,simInt generalObjectType);
typedef simInt (__cdecl *ptrSimHandleVisionSensor)(simInt visionSensorHandle,simFloat** auxValues,simInt** auxValuesCount);
typedef simInt (__cdecl *ptrSimReadVisionSensor)(simInt visionSensorHandle,simFloat** auxValues,simInt** auxValuesCount);
typedef simInt (__cdecl *ptrSimResetVisionSensor)(simInt visionSensorHandle);
typedef simInt (__cdecl *ptrSimCheckVisionSensor)(simInt visionSensorHandle,simInt entityHandle,simFloat** auxValues,simInt** auxValuesCount);
typedef simFloat* (__cdecl *ptrSimCheckVisionSensorEx)(simInt visionSensorHandle,simInt entityHandle,simBool returnImage);
typedef simInt (__cdecl *ptrSimGetVisionSensorResolution)(simInt visionSensorHandle,simInt* resolution);
typedef simFloat* (__cdecl *ptrSimGetVisionSensorImage)(simInt visionSensorHandle);
typedef simUChar* (__cdecl *ptrSimGetVisionSensorCharImage)(simInt visionSensorHandle,simInt* resolutionX,simInt* resolutionY);
typedef simInt (__cdecl *ptrSimSetVisionSensorImage)(simInt visionSensorHandle,const simFloat* image);
typedef simInt (__cdecl *ptrSimSetVisionSensorCharImage)(simInt visionSensorHandle,const simUChar* image);
typedef simFloat* (__cdecl *ptrSimGetVisionSensorDepthBuffer)(simInt visionSensorHandle);
typedef simInt (__cdecl *ptrSimGetObjectQuaternion)(simInt objectHandle,simInt relativeToObjectHandle,simFloat* quaternion);
typedef simInt (__cdecl *ptrSimSetObjectQuaternion)(simInt objectHandle,simInt relativeToObjectHandle,const simFloat* quaternion);
typedef simInt (__cdecl *ptrSimRMLPosition)(simInt dofs,simDouble timeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxVelAccelJerk,const simBool* selection,const simDouble* targetPosVel,simDouble* newPosVelAccel,simVoid* auxData);
typedef simInt (__cdecl *ptrSimRMLVelocity)(simInt dofs,simDouble timeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxAccelJerk,const simBool* selection,const simDouble* targetVel,simDouble* newPosVelAccel,simVoid* auxData);
typedef simInt (__cdecl *ptrSimRMLPos)(simInt dofs,simDouble smallestTimeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxVelAccelJerk,const simBool* selection,const simDouble* targetPosVel,simVoid* auxData);
typedef simInt (__cdecl *ptrSimRMLVel)(simInt dofs,simDouble smallestTimeStep,simInt flags,const simDouble* currentPosVelAccel,const simDouble* maxAccelJerk,const simBool* selection,const simDouble* targetVel,simVoid* auxData);
typedef simInt (__cdecl *ptrSimRMLStep)(simInt handle,simDouble timeStep,simDouble* newPosVelAccel,simVoid* auxData,simVoid* reserved);
typedef simInt (__cdecl *ptrSimRMLRemove)(simInt handle);
typedef simInt (__cdecl *ptrSimBuildMatrixQ)(const simFloat* position,const simFloat* quaternion,simFloat* matrix);
typedef simInt (__cdecl *ptrSimGetQuaternionFromMatrix)(const simFloat* matrix,simFloat* quaternion);
typedef simChar* (__cdecl *ptrSimFileDialog)(simInt mode,const simChar* title,const simChar* startPath,const simChar* initName,const simChar* extName,const simChar* ext);
typedef simInt (__cdecl *ptrSimMsgBox)(simInt dlgType,simInt buttons,const simChar* title,const simChar* message);
typedef simInt (__cdecl *ptrSimSetShapeMassAndInertia)(simInt shapeHandle,simFloat mass,const simFloat* inertiaMatrix,const simFloat* centerOfMass,const simFloat* transformation);
typedef simInt (__cdecl *ptrSimGetShapeMassAndInertia)(simInt shapeHandle,simFloat* mass,simFloat* inertiaMatrix,simFloat* centerOfMass,const simFloat* transformation);
typedef simInt (__cdecl *ptrSimGroupShapes)(const simInt* shapeHandles,simInt shapeCount);
typedef simInt* (__cdecl *ptrSimUngroupShape)(simInt shapeHandle,simInt* shapeCount);
typedef simInt (__cdecl *ptrSimConvexDecompose)(simInt shapeHandle,simInt options,const simInt* intParams,const simFloat* floatParams);
typedef simFloat* (__cdecl *ptrSimGetIkGroupMatrix)(simInt ikGroupHandle,simInt options,simInt* matrixSize);
typedef simInt (__cdecl *ptrSimAddGhost)(simInt ghostGroup,simInt objectHandle,simInt options,simFloat startTime,simFloat endTime,const simFloat* color);
typedef simInt (__cdecl *ptrSimModifyGhost)(simInt ghostGroup,simInt ghostId,simInt operation,simFloat floatValue,simInt options,simInt optionsMask,const simFloat* colorOrTransformation);
typedef simVoid (__cdecl *ptrSimQuitSimulator)(simBool ignoredArgument);
typedef simInt (__cdecl *ptrSimGetThreadId)();
typedef simInt (__cdecl *ptrSimLockResources)(simInt lockType,simInt reserved);
typedef simInt (__cdecl *ptrSimUnlockResources)(simInt lockHandle);
typedef simInt (__cdecl *ptrSimEnableEventCallback)(simInt eventCallbackType,const simChar* plugin,simInt reserved);
typedef simInt (__cdecl *ptrSimSetShapeMaterial)(simInt shapeHandle,simInt materialIdOrShapeHandle);
typedef simInt (__cdecl *ptrSimGetTextureId)(const simChar* textureName,simInt* resolution);
typedef simChar* (__cdecl *ptrSimReadTexture)(simInt textureId,simInt options,simInt posX,simInt posY,simInt sizeX,simInt sizeY);
typedef simInt (__cdecl *ptrSimWriteTexture)(simInt textureId,simInt options,const simChar* data,simInt posX,simInt posY,simInt sizeX,simInt sizeY,simFloat interpol);
typedef simInt (__cdecl *ptrSimCreateTexture)(const simChar* fileName,simInt options,const simFloat* planeSizes,const simFloat* scalingUV,const simFloat* xy_g,simInt fixedResolution,simInt* textureId,simInt* resolution,const simVoid* reserved);
typedef simInt (__cdecl *ptrSimWriteCustomDataBlock)(simInt objectHandle,const simChar* tagName,const simChar* data,simInt dataSize);
typedef simChar* (__cdecl *ptrSimReadCustomDataBlock)(simInt objectHandle,const simChar* tagName,simInt* dataSize);
typedef simChar* (__cdecl *ptrSimReadCustomDataBlockTags)(simInt objectHandle,simInt* tagCount);
typedef simInt (__cdecl *ptrSimAddPointCloud)(simInt pageMask,simInt layerMask,simInt objectHandle,simInt options,simFloat pointSize,simInt ptCnt,const simFloat* pointCoordinates,const simChar* defaultColors,const simChar* pointColors,const simFloat* pointNormals);
typedef simInt (__cdecl *ptrSimModifyPointCloud)(simInt pointCloudHandle,simInt operation,const simInt* intParam,const simFloat* floatParam);
typedef simInt (__cdecl *ptrSimGetShapeGeomInfo)(simInt shapeHandle,simInt* intData,simFloat* floatData,simVoid* reserved);
typedef simInt* (__cdecl *ptrSimGetObjectsInTree)(simInt treeBaseHandle,simInt objectType,simInt options,simInt* objectCount);
typedef simInt (__cdecl *ptrSimSetObjectSizeValues)(simInt objectHandle,const simFloat* sizeValues);
typedef simInt (__cdecl *ptrSimGetObjectSizeValues)(simInt objectHandle,simFloat* sizeValues);
typedef simInt (__cdecl *ptrSimScaleObject)(simInt objectHandle,simFloat xScale,simFloat yScale,simFloat zScale,simInt options);
typedef simInt (__cdecl *ptrSimSetShapeTexture)(simInt shapeHandle,simInt textureId,simInt mappingMode,simInt options,const simFloat* uvScaling,const simFloat* position,const simFloat* orientation);
typedef simInt (__cdecl *ptrSimGetShapeTextureId)(simInt shapeHandle);
typedef simInt* (__cdecl *ptrSimGetCollectionObjects)(simInt collectionHandle,simInt* objectCount);
typedef simInt (__cdecl *ptrSimSetScriptAttribute)(simInt scriptHandle,simInt attributeID,simFloat floatVal,simInt intOrBoolVal);
typedef simInt (__cdecl *ptrSimGetScriptAttribute)(simInt scriptHandle,simInt attributeID,simFloat* floatVal,simInt* intOrBoolVal);
typedef simInt (__cdecl *ptrSimReorientShapeBoundingBox)(simInt shapeHandle,simInt relativeToHandle,simInt reservedSetToZero);
typedef simInt (__cdecl *ptrSimSwitchThread)();
typedef simInt (__cdecl *ptrSimCreateIkGroup)(simInt options,const simInt* intParams,const simFloat* floatParams,const simVoid* reserved);
typedef simInt (__cdecl *ptrSimRemoveIkGroup)(simInt ikGroupHandle);
typedef simInt (__cdecl *ptrSimCreateIkElement)(simInt ikGroupHandle,simInt options,const simInt* intParams,const simFloat* floatParams,const simVoid* reserved);
typedef simInt (__cdecl *ptrSimCreateCollection)(const simChar* collectionName,simInt options);
typedef simInt (__cdecl *ptrSimAddObjectToCollection)(simInt collectionHandle,simInt objectHandle,simInt what,simInt options);
typedef simInt (__cdecl *ptrSimSaveImage)(const simUChar* image,const simInt* resolution,simInt options,const simChar* filename,simInt quality,simVoid* reserved);
typedef simUChar* (__cdecl *ptrSimLoadImage)(simInt* resolution,simInt options,const simChar* filename,simVoid* reserved);
typedef simUChar* (__cdecl *ptrSimGetScaledImage)(const simUChar* imageIn,const simInt* resolutionIn,simInt* resolutionOut,simInt options,simVoid* reserved);
typedef simInt (__cdecl *ptrSimTransformImage)(simUChar* image,const simInt* resolution,simInt options,const simFloat* floatParams,const simInt* intParams,simVoid* reserved);
typedef simInt (__cdecl *ptrSimGetQHull)(const simFloat* inVertices,simInt inVerticesL,simFloat** verticesOut,simInt* verticesOutL,simInt** indicesOut,simInt* indicesOutL,simInt reserved1,const simFloat* reserved2);
typedef simInt (__cdecl *ptrSimGetDecimatedMesh)(const simFloat* inVertices,simInt inVerticesL,const simInt* inIndices,simInt inIndicesL,simFloat** verticesOut,simInt* verticesOutL,simInt** indicesOut,simInt* indicesOutL,simFloat decimationPercent,simInt reserved1,const simFloat* reserved2);
typedef simInt (__cdecl *ptrSimExportIk)(const simChar* pathAndFilename,simInt reserved1,simVoid* reserved2);
typedef simInt (__cdecl *ptrSimCallScriptFunctionEx)(simInt scriptHandleOrType,const simChar* functionNameAtScriptName,simInt stackId);
typedef simInt (__cdecl *ptrSimComputeJacobian)(simInt ikGroupHandle,simInt options,simVoid* reserved);
typedef simInt (__cdecl *ptrSimGetConfigForTipPose)(simInt ikGroupHandle,simInt jointCnt,const simInt* jointHandles,simFloat thresholdDist,simInt maxTimeInMs,simFloat* retConfig,const simFloat* metric,simInt collisionPairCnt,const simInt* collisionPairs,const simInt* jointOptions,const simFloat* lowLimits,const simFloat* ranges,simVoid* reserved);
typedef simFloat* (__cdecl *ptrSimGenerateIkPath)(simInt ikGroupHandle,simInt jointCnt,const simInt* jointHandles,simInt ptCnt,simInt collisionPairCnt,const simInt* collisionPairs,const simInt* jointOptions,simVoid* reserved);
typedef simChar* (__cdecl *ptrSimGetExtensionString)(simInt objectHandle,simInt index,const char* key);
typedef simInt (__cdecl *ptrSimComputeMassAndInertia)(simInt shapeHandle,simFloat density);
typedef simInt (__cdecl *ptrSimCreateStack)();
typedef simInt (__cdecl *ptrSimReleaseStack)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimCopyStack)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimPushNullOntoStack)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimPushBoolOntoStack)(simInt stackHandle,simBool value);
typedef simInt (__cdecl *ptrSimPushInt32OntoStack)(simInt stackHandle,simInt value);
typedef simInt (__cdecl *ptrSimPushFloatOntoStack)(simInt stackHandle,simFloat value);
typedef simInt (__cdecl *ptrSimPushDoubleOntoStack)(simInt stackHandle,simDouble value);
typedef simInt (__cdecl *ptrSimPushStringOntoStack)(simInt stackHandle,const simChar* value,simInt stringSize);
typedef simInt (__cdecl *ptrSimPushUInt8TableOntoStack)(simInt stackHandle,const simUChar* values,simInt valueCnt);
typedef simInt (__cdecl *ptrSimPushInt32TableOntoStack)(simInt stackHandle,const simInt* values,simInt valueCnt);
typedef simInt (__cdecl *ptrSimPushFloatTableOntoStack)(simInt stackHandle,const simFloat* values,simInt valueCnt);
typedef simInt (__cdecl *ptrSimPushDoubleTableOntoStack)(simInt stackHandle,const simDouble* values,simInt valueCnt);
typedef simInt (__cdecl *ptrSimPushTableOntoStack)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimInsertDataIntoStackTable)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimGetStackSize)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimPopStackItem)(simInt stackHandle,simInt count);
typedef simInt (__cdecl *ptrSimMoveStackItemToTop)(simInt stackHandle,simInt cIndex);
typedef simInt (__cdecl *ptrSimIsStackValueNull)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimGetStackBoolValue)(simInt stackHandle,simBool* boolValue);
typedef simInt (__cdecl *ptrSimGetStackInt32Value)(simInt stackHandle,simInt* numberValue);
typedef simInt (__cdecl *ptrSimGetStackFloatValue)(simInt stackHandle,simFloat* numberValue);
typedef simInt (__cdecl *ptrSimGetStackDoubleValue)(simInt stackHandle,simDouble* numberValue);
typedef simChar* (__cdecl *ptrSimGetStackStringValue)(simInt stackHandle,simInt* stringSize);
typedef simInt (__cdecl *ptrSimGetStackTableInfo)(simInt stackHandle,simInt infoType);
typedef simInt (__cdecl *ptrSimGetStackUInt8Table)(simInt stackHandle,simUChar* array,simInt count);
typedef simInt (__cdecl *ptrSimGetStackInt32Table)(simInt stackHandle,simInt* array,simInt count);
typedef simInt (__cdecl *ptrSimGetStackFloatTable)(simInt stackHandle,simFloat* array,simInt count);
typedef simInt (__cdecl *ptrSimGetStackDoubleTable)(simInt stackHandle,simDouble* array,simInt count);
typedef simInt (__cdecl *ptrSimUnfoldStackTable)(simInt stackHandle);
typedef simInt (__cdecl *ptrSimDebugStack)(simInt stackHandle,simInt cIndex);
typedef simInt (__cdecl *ptrSimSetScriptVariable)(simInt scriptHandleOrType,const simChar* variableNameAtScriptName,simInt stackHandle);
typedef simFloat (__cdecl *ptrSimGetEngineFloatParameter)(simInt paramId,simInt objectHandle,const simVoid* object,simBool* ok);
typedef simInt (__cdecl *ptrSimGetEngineInt32Parameter)(simInt paramId,simInt objectHandle,const simVoid* object,simBool* ok);
typedef simBool (__cdecl *ptrSimGetEngineBoolParameter)(simInt paramId,simInt objectHandle,const simVoid* object,simBool* ok);
typedef simInt (__cdecl *ptrSimSetEngineFloatParameter)(simInt paramId,simInt objectHandle,const simVoid* object,simFloat val);
typedef simInt (__cdecl *ptrSimSetEngineInt32Parameter)(simInt paramId,simInt objectHandle,const simVoid* object,simInt val);
typedef simInt (__cdecl *ptrSimSetEngineBoolParameter)(simInt paramId,simInt objectHandle,const simVoid* object,simBool val);
typedef simInt (__cdecl *ptrSimCreateOctree)(simFloat voxelSize,simInt options,simFloat pointSize,simVoid* reserved);
typedef simInt (__cdecl *ptrSimCreatePointCloud)(simFloat maxVoxelSize,simInt maxPtCntPerVoxel,simInt options,simFloat pointSize,simVoid* reserved);
typedef simInt (__cdecl *ptrSimSetPointCloudOptions)(simInt pointCloudHandle,simFloat maxVoxelSize,simInt maxPtCntPerVoxel,simInt options,simFloat pointSize,simVoid* reserved);
typedef simInt (__cdecl *ptrSimGetPointCloudOptions)(simInt pointCloudHandle,simFloat* maxVoxelSize,simInt* maxPtCntPerVoxel,simInt* options,simFloat* pointSize,simVoid* reserved);
typedef simInt (__cdecl *ptrSimInsertVoxelsIntoOctree)(simInt octreeHandle,simInt options,const simFloat* pts,simInt ptCnt,const simUChar* color,const simUInt* tag,simVoid* reserved);
typedef simInt (__cdecl *ptrSimRemoveVoxelsFromOctree)(simInt octreeHandle,simInt options,const simFloat* pts,simInt ptCnt,simVoid* reserved);
typedef simInt (__cdecl *ptrSimInsertPointsIntoPointCloud)(simInt pointCloudHandle,simInt options,const simFloat* pts,simInt ptCnt,const simUChar* color,simVoid* optionalValues);
typedef simInt (__cdecl *ptrSimRemovePointsFromPointCloud)(simInt pointCloudHandle,simInt options,const simFloat* pts,simInt ptCnt,simFloat tolerance,simVoid* reserved);
typedef simInt (__cdecl *ptrSimIntersectPointsWithPointCloud)(simInt pointCloudHandle,simInt options,const simFloat* pts,simInt ptCnt,simFloat tolerance,simVoid* reserved);
typedef const float* (__cdecl *ptrSimGetOctreeVoxels)(simInt octreeHandle,simInt* ptCnt,simVoid* reserved);
typedef const float* (__cdecl *ptrSimGetPointCloudPoints)(simInt pointCloudHandle,simInt* ptCnt,simVoid* reserved);
typedef simInt (__cdecl *ptrSimInsertObjectIntoOctree)(simInt octreeHandle,simInt objectHandle,simInt options,const simUChar* color,simUInt tag,simVoid* reserved);
typedef simInt (__cdecl *ptrSimSubtractObjectFromOctree)(simInt octreeHandle,simInt objectHandle,simInt options,simVoid* reserved);
typedef simInt (__cdecl *ptrSimInsertObjectIntoPointCloud)(simInt pointCloudHandle,simInt objectHandle,simInt options,simFloat gridSize,const simUChar* color,simVoid* optionalValues);
typedef simInt (__cdecl *ptrSimSubtractObjectFromPointCloud)(simInt pointCloudHandle,simInt objectHandle,simInt options,simFloat tolerance,simVoid* reserved);
typedef simInt (__cdecl *ptrSimCheckOctreePointOccupancy)(simInt octreeHandle,simInt options,const simFloat* points,simInt ptCnt,simUInt* tag,simUInt64* location,simVoid* reserved);
typedef simChar* (__cdecl *ptrSimOpenTextEditor)(const simChar* initText,const simChar* xml,simInt* various);
typedef simChar* (__cdecl *ptrSimPackTable)(simInt stackHandle,simInt* bufferSize);
typedef simInt (__cdecl *ptrSimUnpackTable)(simInt stackHandle,const simChar* buffer,simInt bufferSize);
typedef simInt (__cdecl *ptrSimSetReferencedHandles)(simInt objectHandle,simInt count,const simInt* referencedHandles,const simInt* reserved1,const simInt* reserved2);
typedef simInt (__cdecl *ptrSimGetReferencedHandles)(simInt objectHandle,simInt** referencedHandles,simInt** reserved1,simInt** reserved2);
typedef simInt (__cdecl *ptrSimGetShapeViz)(simInt shapeHandle,simInt index,struct SShapeVizInfo* info);
typedef simInt (__cdecl *ptrSimExecuteScriptString)(simInt scriptHandleOrType,const simChar* stringAtScriptName,simInt stackHandle);
typedef simChar* (__cdecl *ptrSimGetApiFunc)(simInt scriptHandleOrType,const simChar* apiWord);
typedef simChar* (__cdecl *ptrSimGetApiInfo)(simInt scriptHandleOrType,const simChar* apiWord);
typedef simInt (__cdecl *ptrSimSetModuleInfo)(const simChar* moduleName,simInt infoType,const simChar* stringInfo,simInt intInfo);
typedef simInt (__cdecl *ptrSimGetModuleInfo)(const simChar* moduleName,simInt infoType,simChar** stringInfo,simInt* intInfo);
typedef simInt (__cdecl *ptrSimIsDeprecated)(const simChar* funcOrConst);
typedef simChar* (__cdecl *ptrSimGetPersistentDataTags)(simInt* tagCount);
typedef simInt (__cdecl *ptrSimEventNotification)(const simChar* event);
typedef simInt (__cdecl *ptrSimApplyTexture)(simInt shapeHandle,const simFloat* textureCoordinates,simInt textCoordSize,const simUChar* texture,const simInt* textureResolution,simInt options);
typedef simInt (__cdecl *ptrSimSetJointDependency)(simInt jointHandle,simInt masterJointHandle,simFloat offset,simFloat coeff);
typedef simInt (__cdecl *ptrSimSetStringNamedParam)(const simChar* paramName,const simChar* stringParam,simInt paramLength);
typedef simChar* (__cdecl *ptrSimGetStringNamedParam)(const simChar* paramName,simInt* paramLength);
typedef simChar* (__cdecl *ptrSimGetUserParameter)(simInt objectHandle,const simChar* parameterName,simInt* parameterLength);
typedef simInt (__cdecl *ptrSimSetUserParameter)(simInt objectHandle,const simChar* parameterName,const simChar* parameterValue,simInt parameterLength);


// Following courtesy of Stephen James:
typedef simInt (__cdecl *ptrSimExtLaunchUIThread)(const simChar* applicationName,simInt options,const simChar* sceneOrModelOrUiToLoad,const simChar* applicationDir_);
typedef simInt (__cdecl *ptrSimExtCanInitSimThread)();
typedef simInt (__cdecl *ptrSimExtSimThreadInit)();
typedef simInt (__cdecl *ptrSimExtSimThreadDestroy)();
typedef simInt (__cdecl *ptrSimExtPostExitRequest)();
typedef simInt (__cdecl *ptrSimExtGetExitRequest)();
typedef simInt (__cdecl *ptrSimExtStep)(simBool stepIfRunning);
typedef simInt (__cdecl *ptrSimExtCallScriptFunction)(simInt scriptHandleOrType, const simChar* functionNameAtScriptName,const simInt* inIntData, simInt inIntCnt,const simFloat* inFloatData, simInt inFloatCnt,const simChar** inStringData, simInt inStringCnt,const simChar* inBufferData, simInt inBufferCnt,simInt** outIntData, simInt* outIntCnt,simFloat** outFloatData, simInt* outFloatCnt,simChar*** outStringData, simInt* outStringCnt,simChar** outBufferData, simInt* outBufferSize);

typedef simInt (__cdecl *ptr_simGetContactCallbackCount)();
typedef const void* (__cdecl *ptr_simGetContactCallback)(simInt index);
typedef simVoid (__cdecl *ptr_simSetDynamicSimulationIconCode)(simVoid* object,simInt code);
typedef simVoid (__cdecl *ptr_simSetDynamicObjectFlagForVisualization)(simVoid* object,simInt flag);
typedef simInt (__cdecl *ptr_simGetObjectListSize)(simInt objType);
typedef const simVoid* (__cdecl *ptr_simGetObjectFromIndex)(simInt objType,simInt index);
typedef simInt (__cdecl *ptr_simGetObjectID)(const simVoid* object);
typedef simInt (__cdecl *ptr_simGetObjectType)(const simVoid* object);
typedef const simVoid** (__cdecl *ptr_simGetObjectChildren)(const simVoid* object,simInt* count);
typedef const simVoid* (__cdecl *ptr_simGetGeomProxyFromShape)(const simVoid* shape);
typedef const simVoid* (__cdecl *ptr_simGetParentObject)(const simVoid* object);
typedef const simVoid* (__cdecl *ptr_simGetObject)(int objID);
typedef const simVoid* (__cdecl *ptr_simGetIkGroupObject)(int ikGroupID);
typedef simInt (__cdecl *ptr_simMpHandleIkGroupObject)(const simVoid* ikGroup);
typedef simVoid (__cdecl *ptr_simGetObjectLocalTransformation)(const simVoid* object,simFloat* pos,simFloat* quat,simBool excludeFirstJointTransformation);
typedef simVoid (__cdecl *ptr_simSetObjectLocalTransformation)(simVoid* object,const simFloat* pos,const simFloat* quat);
typedef simVoid (__cdecl *ptr_simSetObjectCumulativeTransformation)(simVoid* object,const simFloat* pos,const simFloat* quat,simBool keepChildrenInPlace);
typedef simVoid (__cdecl *ptr_simGetObjectCumulativeTransformation)(const simVoid* object,simFloat* pos,simFloat* quat,simBool excludeFirstJointTransformation);
typedef simBool (__cdecl *ptr_simIsShapeDynamicallyStatic)(const simVoid* shape);
typedef simInt (__cdecl *ptr_simGetTreeDynamicProperty)(const simVoid* object);
typedef simInt (__cdecl *ptr_simGetDummyLinkType)(const simVoid* dummy,simInt* linkedDummyID);
typedef simInt (__cdecl *ptr_simGetJointMode)(const simVoid* joint);
typedef simBool (__cdecl *ptr_simIsJointInHybridOperation)(const simVoid* joint);
typedef simVoid (__cdecl *ptr_simDisableDynamicTreeForManipulation)(const simVoid* object,simBool disableFlag);
typedef simBool (__cdecl *ptr_simIsShapeDynamicallyRespondable)(const simVoid* shape);
typedef simInt (__cdecl *ptr_simGetDynamicCollisionMask)(const simVoid* shape);
typedef const simVoid* (__cdecl *ptr_simGetLastParentForLocalGlobalCollidable)(const simVoid* shape);
typedef simVoid (__cdecl *ptr_simSetShapeIsStaticAndNotRespondableButDynamicTag)(const simVoid* shape,simBool tag);
typedef simBool (__cdecl *ptr_simGetShapeIsStaticAndNotRespondableButDynamicTag)(const simVoid* shape);
typedef simVoid (__cdecl *ptr_simSetJointPosition)(const simVoid* joint,simFloat pos);
typedef simFloat (__cdecl *ptr_simGetJointPosition)(const simVoid* joint);
typedef simVoid (__cdecl *ptr_simSetDynamicMotorPositionControlTargetPosition)(const simVoid* joint,simFloat pos);
typedef simVoid (__cdecl *ptr_simGetInitialDynamicVelocity)(const simVoid* shape,simFloat* vel);
typedef simVoid (__cdecl *ptr_simSetInitialDynamicVelocity)(simVoid* shape,const simFloat* vel);
typedef simVoid (__cdecl *ptr_simGetInitialDynamicAngVelocity)(const simVoid* shape,simFloat* angularVel);
typedef simVoid (__cdecl *ptr_simSetInitialDynamicAngVelocity)(simVoid* shape,const simFloat* angularVel);
typedef simBool (__cdecl *ptr_simGetStartSleeping)(const simVoid* shape);
typedef simBool (__cdecl *ptr_simGetWasPutToSleepOnce)(const simVoid* shape);
typedef simBool (__cdecl *ptr_simGetDynamicsFullRefreshFlag)(const simVoid* object);
typedef simVoid (__cdecl *ptr_simSetDynamicsFullRefreshFlag)(const simVoid* object,simBool flag);
typedef simVoid (__cdecl *ptr_simSetGeomProxyDynamicsFullRefreshFlag)(simVoid* geomData,simBool flag);
typedef simBool (__cdecl *ptr_simGetGeomProxyDynamicsFullRefreshFlag)(const simVoid* geomData);
typedef simBool (__cdecl *ptr_simGetParentFollowsDynamic)(const simVoid* shape);
typedef simVoid (__cdecl *ptr_simSetShapeDynamicVelocity)(simVoid* shape,const simFloat* linear,const simFloat* angular);
typedef simVoid (__cdecl *ptr_simGetAdditionalForceAndTorque)(const simVoid* shape,simFloat* force,simFloat* torque);
typedef simVoid (__cdecl *ptr_simClearAdditionalForceAndTorque)(const simVoid* shape);
typedef simBool (__cdecl *ptr_simGetJointPositionInterval)(const simVoid* joint,simFloat* minValue,simFloat* rangeValue);
typedef simInt (__cdecl *ptr_simGetJointType)(const simVoid* joint);
typedef simBool (__cdecl *ptr_simIsForceSensorBroken)(const simVoid* forceSensor);
typedef simVoid (__cdecl *ptr_simGetDynamicForceSensorLocalTransformationPart2)(const simVoid* forceSensor,simFloat* pos,simFloat* quat);
typedef simBool (__cdecl *ptr_simIsDynamicMotorEnabled)(const simVoid* joint);
typedef simBool (__cdecl *ptr_simIsDynamicMotorPositionCtrlEnabled)(const simVoid* joint);
typedef simBool (__cdecl *ptr_simIsDynamicMotorTorqueModulationEnabled)(const simVoid* joint);
typedef simVoid (__cdecl *ptr_simGetMotorPid)(const simVoid* joint,simFloat* pParam,simFloat* iParam,simFloat* dParam);
typedef simFloat (__cdecl *ptr_simGetDynamicMotorTargetPosition)(const simVoid* joint);
typedef simFloat (__cdecl *ptr_simGetDynamicMotorTargetVelocity)(const simVoid* joint);
typedef simFloat (__cdecl *ptr_simGetDynamicMotorMaxForce)(const simVoid* joint);
typedef simFloat (__cdecl *ptr_simGetDynamicMotorUpperLimitVelocity)(const simVoid* joint);
typedef simVoid (__cdecl *ptr_simSetDynamicMotorReflectedPositionFromDynamicEngine)(simVoid* joint,simFloat pos);
typedef simVoid (__cdecl *ptr_simSetJointSphericalTransformation)(simVoid* joint,const simFloat* quat);
typedef simVoid (__cdecl *ptr_simAddForceSensorCumulativeForcesAndTorques)(simVoid* forceSensor,const simFloat* force,const simFloat* torque,int totalPassesCount);
typedef simVoid (__cdecl *ptr_simAddJointCumulativeForcesOrTorques)(simVoid* joint,simFloat forceOrTorque,int totalPassesCount);
typedef simVoid (__cdecl *ptr_simSetDynamicJointLocalTransformationPart2)(simVoid* joint,const simFloat* pos,const simFloat* quat);
typedef simVoid (__cdecl *ptr_simSetDynamicForceSensorLocalTransformationPart2)(simVoid* forceSensor,const simFloat* pos,const simFloat* quat);
typedef simVoid (__cdecl *ptr_simSetDynamicJointLocalTransformationPart2IsValid)(simVoid* joint,simBool valid);
typedef simVoid (__cdecl *ptr_simSetDynamicForceSensorLocalTransformationPart2IsValid)(simVoid* forceSensor,simBool valid);
typedef const simVoid* (__cdecl *ptr_simGetGeomWrapFromGeomProxy)(const simVoid* geomData);
typedef simVoid (__cdecl *ptr_simGetLocalInertiaFrame)(const simVoid* geomInfo,simFloat* pos,simFloat* quat);
typedef simInt (__cdecl *ptr_simGetPurePrimitiveType)(const simVoid* geomInfo);
typedef simBool (__cdecl *ptr_simIsGeomWrapGeometric)(const simVoid* geomInfo);
typedef simBool (__cdecl *ptr_simIsGeomWrapConvex)(const simVoid* geomInfo);
typedef simInt (__cdecl *ptr_simGetGeometricCount)(const simVoid* geomInfo);
typedef simVoid (__cdecl *ptr_simGetAllGeometrics)(const simVoid* geomInfo,simVoid** allGeometrics);
typedef simVoid (__cdecl *ptr_simGetPurePrimitiveSizes)(const simVoid* geometric,simFloat* sizes);
typedef simVoid (__cdecl *ptr_simMakeDynamicAnnouncement)(int announceType);
typedef simVoid (__cdecl *ptr_simGetVerticesLocalFrame)(const simVoid* geometric,simFloat* pos,simFloat* quat);
typedef const simFloat* (__cdecl *ptr_simGetHeightfieldData)(const simVoid* geometric,simInt* xCount,simInt* yCount,simFloat* minHeight,simFloat* maxHeight);
typedef simVoid (__cdecl *ptr_simGetCumulativeMeshes)(const simVoid* geomInfo,simFloat** vertices,simInt* verticesSize,simInt** indices,simInt* indicesSize);
typedef simFloat (__cdecl *ptr_simGetMass)(const simVoid* geomInfo);
typedef simVoid (__cdecl *ptr_simGetPrincipalMomentOfInertia)(const simVoid* geomInfo,simFloat* inertia);
typedef simVoid (__cdecl *ptr_simGetGravity)(simFloat* gravity);
typedef simInt (__cdecl *ptr_simGetTimeDiffInMs)(simInt previousTime);
typedef simBool (__cdecl *ptr_simDoEntitiesCollide)(simInt entity1ID,simInt entity2ID,simInt* cacheBuffer,simBool overrideCollidableFlagIfShape1,simBool overrideCollidableFlagIfShape2,simBool pathPlanningRoutineCalling);
typedef simBool (__cdecl *ptr_simGetDistanceBetweenEntitiesIfSmaller)(simInt entity1ID,simInt entity2ID,simFloat* distance,simFloat* ray,simInt* cacheBuffer,simBool overrideMeasurableFlagIfNonCollection1,simBool overrideMeasurableFlagIfNonCollection2,simBool pathPlanningRoutineCalling);
typedef simInt (__cdecl *ptr_simHandleJointControl)(const simVoid* joint,simInt auxV,const simInt* inputValuesInt,const simFloat* inputValuesFloat,simFloat* outputValues);
typedef simInt (__cdecl *ptr_simHandleCustomContact)(simInt objHandle1,simInt objHandle2,simInt engine,simInt* dataInt,simFloat* dataFloat);
typedef simFloat (__cdecl *ptr_simGetPureHollowScaling)(const simVoid* geometric);
typedef simInt (__cdecl *ptr_simGetJointCallbackCallOrder)(const simVoid* joint);
typedef simVoid (__cdecl *ptr_simDynCallback)(const simInt* intData,const simFloat* floatData);



extern ptrSimRunSimulator simRunSimulator;
extern ptrSimRunSimulatorEx simRunSimulatorEx;
extern ptrSimGetSimulatorMessage simGetSimulatorMessage;
extern ptrSimGetMainWindow simGetMainWindow;
extern ptrSimGetLastError simGetLastError;
extern ptrSimLoadModule simLoadModule;
extern ptrSimUnloadModule simUnloadModule;
extern ptrSimSendModuleMessage simSendModuleMessage;
extern ptrSimSetBooleanParameter simSetBooleanParameter;
extern ptrSimGetBooleanParameter simGetBooleanParameter;
extern ptrSimSetBoolParameter simSetBoolParameter;
extern ptrSimGetBoolParameter simGetBoolParameter;
extern ptrSimSetIntegerParameter simSetIntegerParameter;
extern ptrSimGetIntegerParameter simGetIntegerParameter;
extern ptrSimSetInt32Parameter simSetInt32Parameter;
extern ptrSimGetInt32Parameter simGetInt32Parameter;
extern ptrSimGetUInt64Parameter simGetUInt64Parameter;
extern ptrSimSetFloatingParameter simSetFloatingParameter;
extern ptrSimGetFloatingParameter simGetFloatingParameter;
extern ptrSimSetFloatParameter simSetFloatParameter;
extern ptrSimGetFloatParameter simGetFloatParameter;
extern ptrSimSetStringParameter simSetStringParameter;
extern ptrSimGetStringParameter simGetStringParameter;
extern ptrSimGetObjectHandle simGetObjectHandle;
extern ptrSimRemoveObject simRemoveObject;
extern ptrSimRemoveModel simRemoveModel;
extern ptrSimGetObjectName simGetObjectName;
extern ptrSimGetObjects simGetObjects;
extern ptrSimSetObjectName simSetObjectName;
extern ptrSimGetCollectionHandle simGetCollectionHandle;
extern ptrSimRemoveCollection simRemoveCollection;
extern ptrSimEmptyCollection simEmptyCollection;
extern ptrSimGetCollectionName simGetCollectionName;
extern ptrSimSetCollectionName simSetCollectionName;
extern ptrSimGetObjectMatrix simGetObjectMatrix;
extern ptrSimSetObjectMatrix simSetObjectMatrix;
extern ptrSimGetObjectPosition simGetObjectPosition;
extern ptrSimSetObjectPosition simSetObjectPosition;
extern ptrSimGetObjectOrientation simGetObjectOrientation;
extern ptrSimSetObjectOrientation simSetObjectOrientation;
extern ptrSimGetJointPosition simGetJointPosition;
extern ptrSimSetJointPosition simSetJointPosition;
extern ptrSimSetJointTargetPosition simSetJointTargetPosition;
extern ptrSimGetJointTargetPosition simGetJointTargetPosition;
extern ptrSimSetJointMaxForce simSetJointMaxForce;
extern ptrSimGetPathPosition simGetPathPosition;
extern ptrSimSetPathPosition simSetPathPosition;
extern ptrSimGetPathLength simGetPathLength;
extern ptrSimGetJointMatrix simGetJointMatrix;
extern ptrSimSetSphericalJointMatrix simSetSphericalJointMatrix;
extern ptrSimGetJointInterval simGetJointInterval;
extern ptrSimSetJointInterval simSetJointInterval;
extern ptrSimGetObjectParent simGetObjectParent;
extern ptrSimGetObjectChild simGetObjectChild;
extern ptrSimSetObjectParent simSetObjectParent;
extern ptrSimGetObjectType simGetObjectType;
extern ptrSimGetJointType simGetJointType;
extern ptrSimBuildIdentityMatrix simBuildIdentityMatrix;
extern ptrSimCopyMatrix simCopyMatrix;
extern ptrSimBuildMatrix simBuildMatrix;
extern ptrSimGetEulerAnglesFromMatrix simGetEulerAnglesFromMatrix;
extern ptrSimInvertMatrix simInvertMatrix;
extern ptrSimMultiplyMatrices simMultiplyMatrices;
extern ptrSimInterpolateMatrices simInterpolateMatrices;
extern ptrSimTransformVector simTransformVector;
extern ptrSimReservedCommand simReservedCommand;
extern ptrSimGetSimulationTime simGetSimulationTime;
extern ptrSimGetSimulationState simGetSimulationState;
extern ptrSimGetSystemTime simGetSystemTime;
extern ptrSimGetSystemTimeInMilliseconds simGetSystemTimeInMilliseconds;
extern ptrSimGetSystemTimeInMs simGetSystemTimeInMs;
extern ptrSimLoadScene simLoadScene;
extern ptrSimCloseScene simCloseScene;
extern ptrSimSaveScene simSaveScene;
extern ptrSimLoadModel simLoadModel;
extern ptrSimSaveModel simSaveModel;
extern ptrSimAddStatusbarMessage simAddStatusbarMessage;
extern ptrSimAddModuleMenuEntry simAddModuleMenuEntry;
extern ptrSimSetModuleMenuItemState simSetModuleMenuItemState;
extern ptrSimDoesFileExist simDoesFileExist;
extern ptrSimIsObjectInSelection simIsObjectInSelection;
extern ptrSimAddObjectToSelection simAddObjectToSelection;
extern ptrSimRemoveObjectFromSelection simRemoveObjectFromSelection;
extern ptrSimGetObjectSelectionSize simGetObjectSelectionSize;
extern ptrSimGetObjectLastSelection simGetObjectLastSelection;
extern ptrSimGetObjectSelection simGetObjectSelection;
extern ptrSimHandleCollision simHandleCollision;
extern ptrSimReadCollision simReadCollision;
extern ptrSimHandleDistance simHandleDistance;
extern ptrSimReadDistance simReadDistance;
extern ptrSimHandleProximitySensor simHandleProximitySensor;
extern ptrSimReadProximitySensor simReadProximitySensor;
extern ptrSimHandleMill simHandleMill;
extern ptrSimHandleIkGroup simHandleIkGroup;
extern ptrSimCheckIkGroup simCheckIkGroup;
extern ptrSimHandleDynamics simHandleDynamics;
extern ptrSimGetScriptHandle simGetScriptHandle;
extern ptrSimSetScriptText simSetScriptText;
extern ptrSimGetScriptText simGetScriptText;
extern ptrSimGetScriptProperty simGetScriptProperty;
extern ptrSimAssociateScriptWithObject simAssociateScriptWithObject;
extern ptrSimGetScript simGetScript;
extern ptrSimGetScriptAssociatedWithObject simGetScriptAssociatedWithObject;
extern ptrSimGetCustomizationScriptAssociatedWithObject simGetCustomizationScriptAssociatedWithObject;
extern ptrSimGetObjectAssociatedWithScript simGetObjectAssociatedWithScript;
extern ptrSimGetScriptName simGetScriptName;
extern ptrSimHandleMainScript simHandleMainScript;
extern ptrSimResetScript simResetScript;
extern ptrSimAddScript simAddScript;
extern ptrSimRemoveScript simRemoveScript;
extern ptrSimRefreshDialogs simRefreshDialogs;
extern ptrSimGetCollisionHandle simGetCollisionHandle;
extern ptrSimGetDistanceHandle simGetDistanceHandle;
extern ptrSimGetIkGroupHandle simGetIkGroupHandle;
extern ptrSimResetCollision simResetCollision;
extern ptrSimResetDistance simResetDistance;
extern ptrSimResetProximitySensor simResetProximitySensor;
extern ptrSimResetMill simResetMill;
extern ptrSimCheckProximitySensor simCheckProximitySensor;
extern ptrSimCheckProximitySensorEx simCheckProximitySensorEx;
extern ptrSimCheckProximitySensorEx2 simCheckProximitySensorEx2;
extern ptrSimCreateBuffer simCreateBuffer;
extern ptrSimReleaseBuffer simReleaseBuffer;
extern ptrSimCheckCollision simCheckCollision;
extern ptrSimCheckCollisionEx simCheckCollisionEx;
extern ptrSimCheckDistance simCheckDistance;
extern ptrSimGetObjectConfiguration simGetObjectConfiguration;
extern ptrSimSetObjectConfiguration simSetObjectConfiguration;
extern ptrSimGetConfigurationTree simGetConfigurationTree;
extern ptrSimSetConfigurationTree simSetConfigurationTree;
extern ptrSimSetSimulationTimeStep simSetSimulationTimeStep;
extern ptrSimGetSimulationTimeStep simGetSimulationTimeStep;
extern ptrSimGetRealTimeSimulation simGetRealTimeSimulation;
extern ptrSimIsRealTimeSimulationStepNeeded simIsRealTimeSimulationStepNeeded;
extern ptrSimAdjustRealTimeTimer simAdjustRealTimeTimer;
extern ptrSimGetSimulationPassesPerRenderingPass simGetSimulationPassesPerRenderingPass;
extern ptrSimAdvanceSimulationByOneStep simAdvanceSimulationByOneStep;
extern ptrSimStartSimulation simStartSimulation;
extern ptrSimStopSimulation simStopSimulation;
extern ptrSimPauseSimulation simPauseSimulation;
extern ptrSimBroadcastMessage simBroadcastMessage;
extern ptrSimGetModuleName simGetModuleName;
extern ptrSimFloatingViewAdd simFloatingViewAdd;
extern ptrSimFloatingViewRemove simFloatingViewRemove;
extern ptrSimAdjustView simAdjustView;
extern ptrSimSetLastError simSetLastError;
extern ptrSimHandleGraph simHandleGraph;
extern ptrSimResetGraph simResetGraph;
extern ptrSimSetNavigationMode simSetNavigationMode;
extern ptrSimGetNavigationMode simGetNavigationMode;
extern ptrSimSetPage simSetPage;
extern ptrSimGetPage simGetPage;
extern ptrSimDisplayDialog simDisplayDialog;
extern ptrSimGetDialogResult simGetDialogResult;
extern ptrSimGetDialogInput simGetDialogInput;
extern ptrSimEndDialog simEndDialog;
extern ptrSimRegisterScriptCallbackFunction simRegisterScriptCallbackFunction;
extern ptrSimRegisterScriptVariable simRegisterScriptVariable;
extern ptrSimSetJointTargetVelocity simSetJointTargetVelocity;
extern ptrSimGetJointTargetVelocity simGetJointTargetVelocity;
extern ptrSimSetPathTargetNominalVelocity simSetPathTargetNominalVelocity;
extern ptrSimGetScriptRawBuffer simGetScriptRawBuffer;
extern ptrSimSetScriptRawBuffer simSetScriptRawBuffer;
extern ptrSimReleaseScriptRawBuffer simReleaseScriptRawBuffer;
extern ptrSimCopyPasteObjects simCopyPasteObjects;
extern ptrSimScaleSelectedObjects simScaleSelectedObjects;
extern ptrSimScaleObjects simScaleObjects;
extern ptrSimDeleteSelectedObjects simDeleteSelectedObjects;
extern ptrSimGetObjectUniqueIdentifier simGetObjectUniqueIdentifier;
extern ptrSimGetNameSuffix simGetNameSuffix;
extern ptrSimSendData simSendData;
extern ptrSimReceiveData simReceiveData;
extern ptrSimSetGraphUserData simSetGraphUserData;
extern ptrSimSetNameSuffix simSetNameSuffix;
extern ptrSimAddDrawingObject simAddDrawingObject;
extern ptrSimRemoveDrawingObject simRemoveDrawingObject;
extern ptrSimAddDrawingObjectItem simAddDrawingObjectItem;
extern ptrSimAddParticleObject simAddParticleObject;
extern ptrSimRemoveParticleObject simRemoveParticleObject;
extern ptrSimAddParticleObjectItem simAddParticleObjectItem;
extern ptrSimGetObjectSizeFactor simGetObjectSizeFactor;
extern ptrSimAnnounceSceneContentChange simAnnounceSceneContentChange;
extern ptrSimResetMilling simResetMilling;
extern ptrSimApplyMilling simApplyMilling;
extern ptrSimSetIntegerSignal simSetIntegerSignal;
extern ptrSimGetIntegerSignal simGetIntegerSignal;
extern ptrSimClearIntegerSignal simClearIntegerSignal;
extern ptrSimSetFloatSignal simSetFloatSignal;
extern ptrSimGetFloatSignal simGetFloatSignal;
extern ptrSimClearFloatSignal simClearFloatSignal;
extern ptrSimSetDoubleSignal simSetDoubleSignal;
extern ptrSimGetDoubleSignal simGetDoubleSignal;
extern ptrSimClearDoubleSignal simClearDoubleSignal;
extern ptrSimSetStringSignal simSetStringSignal;
extern ptrSimGetStringSignal simGetStringSignal;
extern ptrSimClearStringSignal simClearStringSignal;
extern ptrSimGetSignalName simGetSignalName;
extern ptrSimSetObjectProperty simSetObjectProperty;
extern ptrSimGetObjectProperty simGetObjectProperty;
extern ptrSimSetObjectSpecialProperty simSetObjectSpecialProperty;
extern ptrSimGetObjectSpecialProperty simGetObjectSpecialProperty;
extern ptrSimGetPositionOnPath simGetPositionOnPath;
extern ptrSimGetDataOnPath simGetDataOnPath;
extern ptrSimGetOrientationOnPath simGetOrientationOnPath;
extern ptrSimGetClosestPositionOnPath simGetClosestPositionOnPath;
extern ptrSimReadForceSensor simReadForceSensor;
extern ptrSimBreakForceSensor simBreakForceSensor;
extern ptrSimGetShapeVertex simGetShapeVertex;
extern ptrSimGetShapeTriangle simGetShapeTriangle;
extern ptrSimSetLightParameters simSetLightParameters;
extern ptrSimGetLightParameters simGetLightParameters;
extern ptrSimGetVelocity simGetVelocity;
extern ptrSimGetObjectVelocity simGetObjectVelocity;
extern ptrSimAddForceAndTorque simAddForceAndTorque;
extern ptrSimAddForce simAddForce;
extern ptrSimSetExplicitHandling simSetExplicitHandling;
extern ptrSimGetExplicitHandling simGetExplicitHandling;
extern ptrSimGetLinkDummy simGetLinkDummy;
extern ptrSimSetLinkDummy simSetLinkDummy;
extern ptrSimSetModelProperty simSetModelProperty;
extern ptrSimGetModelProperty simGetModelProperty;
extern ptrSimSetShapeColor simSetShapeColor;
extern ptrSimGetShapeColor simGetShapeColor;
extern ptrSimResetDynamicObject simResetDynamicObject;
extern ptrSimSetJointMode simSetJointMode;
extern ptrSimGetJointMode simGetJointMode;
extern ptrSimSerialOpen simSerialOpen;
extern ptrSimSerialClose simSerialClose;
extern ptrSimSerialSend simSerialSend;
extern ptrSimSerialRead simSerialRead;
extern ptrSimSerialCheck simSerialCheck;
extern ptrSimGetContactInfo simGetContactInfo;
extern ptrSimSetThreadIsFree simSetThreadIsFree;
extern ptrSimTubeOpen simTubeOpen;
extern ptrSimTubeClose simTubeClose;
extern ptrSimTubeWrite simTubeWrite;
extern ptrSimTubeRead simTubeRead;
extern ptrSimTubeStatus simTubeStatus;
extern ptrSimAuxiliaryConsoleOpen simAuxiliaryConsoleOpen;
extern ptrSimAuxiliaryConsoleClose simAuxiliaryConsoleClose;
extern ptrSimAuxiliaryConsoleShow simAuxiliaryConsoleShow;
extern ptrSimAuxiliaryConsolePrint simAuxiliaryConsolePrint;
extern ptrSimImportShape simImportShape;
extern ptrSimImportMesh simImportMesh;
extern ptrSimExportMesh simExportMesh;
extern ptrSimCreateMeshShape simCreateMeshShape;
extern ptrSimCreatePureShape simCreatePureShape;
extern ptrSimCreateHeightfieldShape simCreateHeightfieldShape;
extern ptrSimGetShapeMesh simGetShapeMesh;
extern ptrSimAddBanner simAddBanner;
extern ptrSimRemoveBanner simRemoveBanner;
extern ptrSimCreateJoint simCreateJoint;
extern ptrSimCreateDummy simCreateDummy;
extern ptrSimCreateForceSensor simCreateForceSensor;
extern ptrSimCreateVisionSensor simCreateVisionSensor;
extern ptrSimCreateProximitySensor simCreateProximitySensor;
extern ptrSimCreatePath simCreatePath;
extern ptrSimInsertPathCtrlPoints simInsertPathCtrlPoints;
extern ptrSimCutPathCtrlPoints simCutPathCtrlPoints;
extern ptrSimGetObjectIntParameter simGetObjectIntParameter;
extern ptrSimSetObjectIntParameter simSetObjectIntParameter;
extern ptrSimGetObjectInt32Parameter simGetObjectInt32Parameter;
extern ptrSimSetObjectInt32Parameter simSetObjectInt32Parameter;
extern ptrSimGetObjectFloatParameter simGetObjectFloatParameter;
extern ptrSimSetObjectFloatParameter simSetObjectFloatParameter;
extern ptrSimGetObjectStringParameter simGetObjectStringParameter;
extern ptrSimSetObjectStringParameter simSetObjectStringParameter;
extern ptrSimSetSimulationPassesPerRenderingPass simSetSimulationPassesPerRenderingPass;
extern ptrSimGetRotationAxis simGetRotationAxis;
extern ptrSimRotateAroundAxis simRotateAroundAxis;
extern ptrSimGetJointForce simGetJointForce;
extern ptrSimGetJointMaxForce simGetJointMaxForce;
extern ptrSimSetArrayParameter simSetArrayParameter;
extern ptrSimGetArrayParameter simGetArrayParameter;
extern ptrSimSetIkGroupProperties simSetIkGroupProperties;
extern ptrSimSetIkElementProperties simSetIkElementProperties;
extern ptrSimCameraFitToView simCameraFitToView;
extern ptrSimPersistentDataWrite simPersistentDataWrite;
extern ptrSimPersistentDataRead simPersistentDataRead;
extern ptrSimIsHandleValid simIsHandleValid;
extern ptrSimHandleVisionSensor simHandleVisionSensor;
extern ptrSimReadVisionSensor simReadVisionSensor;
extern ptrSimResetVisionSensor simResetVisionSensor;
extern ptrSimCheckVisionSensor simCheckVisionSensor;
extern ptrSimCheckVisionSensorEx simCheckVisionSensorEx;
extern ptrSimGetVisionSensorResolution simGetVisionSensorResolution;
extern ptrSimGetVisionSensorImage simGetVisionSensorImage;
extern ptrSimGetVisionSensorCharImage simGetVisionSensorCharImage;
extern ptrSimSetVisionSensorImage simSetVisionSensorImage;
extern ptrSimSetVisionSensorCharImage simSetVisionSensorCharImage;
extern ptrSimGetVisionSensorDepthBuffer simGetVisionSensorDepthBuffer;
extern ptrSimGetObjectQuaternion simGetObjectQuaternion;
extern ptrSimSetObjectQuaternion simSetObjectQuaternion;
extern ptrSimRMLPosition simRMLPosition;
extern ptrSimRMLVelocity simRMLVelocity;
extern ptrSimRMLPos simRMLPos;
extern ptrSimRMLVel simRMLVel;
extern ptrSimRMLStep simRMLStep;
extern ptrSimRMLRemove simRMLRemove;
extern ptrSimBuildMatrixQ simBuildMatrixQ;
extern ptrSimGetQuaternionFromMatrix simGetQuaternionFromMatrix;
extern ptrSimFileDialog simFileDialog;
extern ptrSimMsgBox simMsgBox;
extern ptrSimSetShapeMassAndInertia simSetShapeMassAndInertia;
extern ptrSimGetShapeMassAndInertia simGetShapeMassAndInertia;
extern ptrSimGroupShapes simGroupShapes;
extern ptrSimUngroupShape simUngroupShape;
extern ptrSimConvexDecompose simConvexDecompose;
extern ptrSimGetIkGroupMatrix simGetIkGroupMatrix;
extern ptrSimAddGhost simAddGhost;
extern ptrSimModifyGhost simModifyGhost;
extern ptrSimQuitSimulator simQuitSimulator;
extern ptrSimGetThreadId simGetThreadId;
extern ptrSimLockResources simLockResources;
extern ptrSimUnlockResources simUnlockResources;
extern ptrSimEnableEventCallback simEnableEventCallback;
extern ptrSimSetShapeMaterial simSetShapeMaterial;
extern ptrSimGetTextureId simGetTextureId;
extern ptrSimReadTexture simReadTexture;
extern ptrSimWriteTexture simWriteTexture;
extern ptrSimCreateTexture simCreateTexture;
extern ptrSimWriteCustomDataBlock simWriteCustomDataBlock;
extern ptrSimReadCustomDataBlock simReadCustomDataBlock;
extern ptrSimReadCustomDataBlockTags simReadCustomDataBlockTags;
extern ptrSimAddPointCloud simAddPointCloud;
extern ptrSimModifyPointCloud simModifyPointCloud;
extern ptrSimGetShapeGeomInfo simGetShapeGeomInfo;
extern ptrSimGetObjectsInTree simGetObjectsInTree;
extern ptrSimSetObjectSizeValues simSetObjectSizeValues;
extern ptrSimGetObjectSizeValues simGetObjectSizeValues;
extern ptrSimScaleObject simScaleObject;
extern ptrSimSetShapeTexture simSetShapeTexture;
extern ptrSimGetShapeTextureId simGetShapeTextureId;
extern ptrSimGetCollectionObjects simGetCollectionObjects;
extern ptrSimSetScriptAttribute simSetScriptAttribute;
extern ptrSimGetScriptAttribute simGetScriptAttribute;
extern ptrSimReorientShapeBoundingBox simReorientShapeBoundingBox;
extern ptrSimSwitchThread simSwitchThread;
extern ptrSimCreateIkGroup simCreateIkGroup;
extern ptrSimRemoveIkGroup simRemoveIkGroup;
extern ptrSimCreateIkElement simCreateIkElement;
extern ptrSimCreateCollection simCreateCollection;
extern ptrSimAddObjectToCollection simAddObjectToCollection;
extern ptrSimSaveImage simSaveImage;
extern ptrSimLoadImage simLoadImage;
extern ptrSimGetScaledImage simGetScaledImage;
extern ptrSimTransformImage simTransformImage;
extern ptrSimGetQHull simGetQHull;
extern ptrSimGetDecimatedMesh simGetDecimatedMesh;
extern ptrSimExportIk simExportIk;
extern ptrSimCallScriptFunctionEx simCallScriptFunctionEx;
extern ptrSimComputeJacobian simComputeJacobian;
extern ptrSimGetConfigForTipPose simGetConfigForTipPose;
extern ptrSimGenerateIkPath simGenerateIkPath;
extern ptrSimGetExtensionString simGetExtensionString;
extern ptrSimComputeMassAndInertia simComputeMassAndInertia;
extern ptrSimCreateStack simCreateStack;
extern ptrSimReleaseStack simReleaseStack;
extern ptrSimCopyStack simCopyStack;
extern ptrSimPushNullOntoStack simPushNullOntoStack;
extern ptrSimPushBoolOntoStack simPushBoolOntoStack;
extern ptrSimPushInt32OntoStack simPushInt32OntoStack;
extern ptrSimPushFloatOntoStack simPushFloatOntoStack;
extern ptrSimPushDoubleOntoStack simPushDoubleOntoStack;
extern ptrSimPushStringOntoStack simPushStringOntoStack;
extern ptrSimPushUInt8TableOntoStack simPushUInt8TableOntoStack;
extern ptrSimPushInt32TableOntoStack simPushInt32TableOntoStack;
extern ptrSimPushFloatTableOntoStack simPushFloatTableOntoStack;
extern ptrSimPushDoubleTableOntoStack simPushDoubleTableOntoStack;
extern ptrSimPushTableOntoStack simPushTableOntoStack;
extern ptrSimInsertDataIntoStackTable simInsertDataIntoStackTable;
extern ptrSimGetStackSize simGetStackSize;
extern ptrSimPopStackItem simPopStackItem;
extern ptrSimMoveStackItemToTop simMoveStackItemToTop;
extern ptrSimIsStackValueNull simIsStackValueNull;
extern ptrSimGetStackBoolValue simGetStackBoolValue;
extern ptrSimGetStackInt32Value simGetStackInt32Value;
extern ptrSimGetStackFloatValue simGetStackFloatValue;
extern ptrSimGetStackDoubleValue simGetStackDoubleValue;
extern ptrSimGetStackStringValue simGetStackStringValue;
extern ptrSimGetStackTableInfo simGetStackTableInfo;
extern ptrSimGetStackUInt8Table simGetStackUInt8Table;
extern ptrSimGetStackInt32Table simGetStackInt32Table;
extern ptrSimGetStackFloatTable simGetStackFloatTable;
extern ptrSimGetStackDoubleTable simGetStackDoubleTable;
extern ptrSimUnfoldStackTable simUnfoldStackTable;
extern ptrSimDebugStack simDebugStack;
extern ptrSimSetScriptVariable simSetScriptVariable;
extern ptrSimGetEngineFloatParameter simGetEngineFloatParameter;
extern ptrSimGetEngineInt32Parameter simGetEngineInt32Parameter;
extern ptrSimGetEngineBoolParameter simGetEngineBoolParameter;
extern ptrSimSetEngineFloatParameter simSetEngineFloatParameter;
extern ptrSimSetEngineInt32Parameter simSetEngineInt32Parameter;
extern ptrSimSetEngineBoolParameter simSetEngineBoolParameter;
extern ptrSimCreateOctree simCreateOctree;
extern ptrSimCreatePointCloud simCreatePointCloud;
extern ptrSimSetPointCloudOptions simSetPointCloudOptions;
extern ptrSimGetPointCloudOptions simGetPointCloudOptions;
extern ptrSimInsertVoxelsIntoOctree simInsertVoxelsIntoOctree;
extern ptrSimRemoveVoxelsFromOctree simRemoveVoxelsFromOctree;
extern ptrSimInsertPointsIntoPointCloud simInsertPointsIntoPointCloud;
extern ptrSimRemovePointsFromPointCloud simRemovePointsFromPointCloud;
extern ptrSimIntersectPointsWithPointCloud simIntersectPointsWithPointCloud;
extern ptrSimGetOctreeVoxels simGetOctreeVoxels;
extern ptrSimGetPointCloudPoints simGetPointCloudPoints;
extern ptrSimInsertObjectIntoOctree simInsertObjectIntoOctree;
extern ptrSimSubtractObjectFromOctree simSubtractObjectFromOctree;
extern ptrSimInsertObjectIntoPointCloud simInsertObjectIntoPointCloud;
extern ptrSimSubtractObjectFromPointCloud simSubtractObjectFromPointCloud;
extern ptrSimCheckOctreePointOccupancy simCheckOctreePointOccupancy;
extern ptrSimOpenTextEditor simOpenTextEditor;
extern ptrSimPackTable simPackTable;
extern ptrSimUnpackTable simUnpackTable;
extern ptrSimSetReferencedHandles simSetReferencedHandles;
extern ptrSimGetReferencedHandles simGetReferencedHandles;
extern ptrSimGetShapeViz simGetShapeViz;
extern ptrSimExecuteScriptString simExecuteScriptString;
extern ptrSimGetApiFunc simGetApiFunc;
extern ptrSimGetApiInfo simGetApiInfo;
extern ptrSimSetModuleInfo simSetModuleInfo;
extern ptrSimGetModuleInfo simGetModuleInfo;
extern ptrSimIsDeprecated simIsDeprecated;
extern ptrSimGetPersistentDataTags simGetPersistentDataTags;
extern ptrSimEventNotification simEventNotification;
extern ptrSimApplyTexture simApplyTexture;
extern ptrSimSetJointDependency simSetJointDependency;
extern ptrSimSetStringNamedParam simSetStringNamedParam;
extern ptrSimGetStringNamedParam simGetStringNamedParam;
extern ptrSimGetUserParameter simGetUserParameter;
extern ptrSimSetUserParameter simSetUserParameter;


// Following courtesy of Stephen James:
extern ptrSimExtLaunchUIThread simExtLaunchUIThread;
extern ptrSimExtCanInitSimThread simExtCanInitSimThread;
extern ptrSimExtSimThreadInit simExtSimThreadInit;
extern ptrSimExtSimThreadDestroy simExtSimThreadDestroy;
extern ptrSimExtPostExitRequest simExtPostExitRequest;
extern ptrSimExtGetExitRequest simExtGetExitRequest;
extern ptrSimExtStep simExtStep;
extern ptrSimExtCallScriptFunction simExtCallScriptFunction;

extern ptr_simGetContactCallbackCount _simGetContactCallbackCount;
extern ptr_simGetContactCallback _simGetContactCallback;
extern ptr_simSetDynamicSimulationIconCode _simSetDynamicSimulationIconCode;
extern ptr_simSetDynamicObjectFlagForVisualization _simSetDynamicObjectFlagForVisualization;
extern ptr_simGetObjectListSize _simGetObjectListSize;
extern ptr_simGetObjectFromIndex _simGetObjectFromIndex;
extern ptr_simGetObjectID _simGetObjectID;
extern ptr_simGetObjectType _simGetObjectType;
extern ptr_simGetObjectChildren _simGetObjectChildren;
extern ptr_simGetGeomProxyFromShape _simGetGeomProxyFromShape;
extern ptr_simGetParentObject _simGetParentObject;
extern ptr_simGetObject _simGetObject;
extern ptr_simGetIkGroupObject _simGetIkGroupObject;
extern ptr_simMpHandleIkGroupObject _simMpHandleIkGroupObject;
extern ptr_simGetObjectLocalTransformation _simGetObjectLocalTransformation;
extern ptr_simSetObjectLocalTransformation _simSetObjectLocalTransformation;
extern ptr_simSetObjectCumulativeTransformation _simSetObjectCumulativeTransformation;
extern ptr_simGetObjectCumulativeTransformation _simGetObjectCumulativeTransformation;
extern ptr_simIsShapeDynamicallyStatic _simIsShapeDynamicallyStatic;
extern ptr_simGetTreeDynamicProperty _simGetTreeDynamicProperty;
extern ptr_simGetDummyLinkType _simGetDummyLinkType;
extern ptr_simGetJointMode _simGetJointMode;
extern ptr_simIsJointInHybridOperation _simIsJointInHybridOperation;
extern ptr_simDisableDynamicTreeForManipulation _simDisableDynamicTreeForManipulation;
extern ptr_simIsShapeDynamicallyRespondable _simIsShapeDynamicallyRespondable;
extern ptr_simGetDynamicCollisionMask _simGetDynamicCollisionMask;
extern ptr_simGetLastParentForLocalGlobalCollidable _simGetLastParentForLocalGlobalCollidable;
extern ptr_simSetShapeIsStaticAndNotRespondableButDynamicTag _simSetShapeIsStaticAndNotRespondableButDynamicTag;
extern ptr_simGetShapeIsStaticAndNotRespondableButDynamicTag _simGetShapeIsStaticAndNotRespondableButDynamicTag;
extern ptr_simSetJointPosition _simSetJointPosition;
extern ptr_simGetJointPosition _simGetJointPosition;
extern ptr_simSetDynamicMotorPositionControlTargetPosition _simSetDynamicMotorPositionControlTargetPosition;
extern ptr_simGetInitialDynamicVelocity _simGetInitialDynamicVelocity;
extern ptr_simSetInitialDynamicVelocity _simSetInitialDynamicVelocity;
extern ptr_simGetInitialDynamicAngVelocity _simGetInitialDynamicAngVelocity;
extern ptr_simSetInitialDynamicAngVelocity _simSetInitialDynamicAngVelocity;
extern ptr_simGetStartSleeping _simGetStartSleeping;
extern ptr_simGetWasPutToSleepOnce _simGetWasPutToSleepOnce;
extern ptr_simGetDynamicsFullRefreshFlag _simGetDynamicsFullRefreshFlag;
extern ptr_simSetDynamicsFullRefreshFlag _simSetDynamicsFullRefreshFlag;
extern ptr_simSetGeomProxyDynamicsFullRefreshFlag _simSetGeomProxyDynamicsFullRefreshFlag;
extern ptr_simGetGeomProxyDynamicsFullRefreshFlag _simGetGeomProxyDynamicsFullRefreshFlag;
extern ptr_simGetParentFollowsDynamic _simGetParentFollowsDynamic;
extern ptr_simSetShapeDynamicVelocity _simSetShapeDynamicVelocity;
extern ptr_simGetAdditionalForceAndTorque _simGetAdditionalForceAndTorque;
extern ptr_simClearAdditionalForceAndTorque _simClearAdditionalForceAndTorque;
extern ptr_simGetJointPositionInterval _simGetJointPositionInterval;
extern ptr_simGetJointType _simGetJointType;
extern ptr_simIsForceSensorBroken _simIsForceSensorBroken;
extern ptr_simGetDynamicForceSensorLocalTransformationPart2 _simGetDynamicForceSensorLocalTransformationPart2;
extern ptr_simIsDynamicMotorEnabled _simIsDynamicMotorEnabled;
extern ptr_simIsDynamicMotorPositionCtrlEnabled _simIsDynamicMotorPositionCtrlEnabled;
extern ptr_simIsDynamicMotorTorqueModulationEnabled _simIsDynamicMotorTorqueModulationEnabled;
extern ptr_simGetMotorPid _simGetMotorPid;
extern ptr_simGetDynamicMotorTargetPosition _simGetDynamicMotorTargetPosition;
extern ptr_simGetDynamicMotorTargetVelocity _simGetDynamicMotorTargetVelocity;
extern ptr_simGetDynamicMotorMaxForce _simGetDynamicMotorMaxForce;
extern ptr_simGetDynamicMotorUpperLimitVelocity _simGetDynamicMotorUpperLimitVelocity;
extern ptr_simSetDynamicMotorReflectedPositionFromDynamicEngine _simSetDynamicMotorReflectedPositionFromDynamicEngine;
extern ptr_simSetJointSphericalTransformation _simSetJointSphericalTransformation;
extern ptr_simAddForceSensorCumulativeForcesAndTorques _simAddForceSensorCumulativeForcesAndTorques;
extern ptr_simAddJointCumulativeForcesOrTorques _simAddJointCumulativeForcesOrTorques;
extern ptr_simSetDynamicJointLocalTransformationPart2 _simSetDynamicJointLocalTransformationPart2;
extern ptr_simSetDynamicForceSensorLocalTransformationPart2 _simSetDynamicForceSensorLocalTransformationPart2;
extern ptr_simSetDynamicJointLocalTransformationPart2IsValid _simSetDynamicJointLocalTransformationPart2IsValid;
extern ptr_simSetDynamicForceSensorLocalTransformationPart2IsValid _simSetDynamicForceSensorLocalTransformationPart2IsValid;
extern ptr_simGetGeomWrapFromGeomProxy _simGetGeomWrapFromGeomProxy;
extern ptr_simGetLocalInertiaFrame _simGetLocalInertiaFrame;
extern ptr_simGetPurePrimitiveType _simGetPurePrimitiveType;
extern ptr_simIsGeomWrapGeometric _simIsGeomWrapGeometric;
extern ptr_simIsGeomWrapConvex _simIsGeomWrapConvex;
extern ptr_simGetGeometricCount _simGetGeometricCount;
extern ptr_simGetAllGeometrics _simGetAllGeometrics;
extern ptr_simGetPurePrimitiveSizes _simGetPurePrimitiveSizes;
extern ptr_simMakeDynamicAnnouncement _simMakeDynamicAnnouncement;
extern ptr_simGetVerticesLocalFrame _simGetVerticesLocalFrame;
extern ptr_simGetHeightfieldData _simGetHeightfieldData;
extern ptr_simGetCumulativeMeshes _simGetCumulativeMeshes;
extern ptr_simGetMass _simGetMass;
extern ptr_simGetPrincipalMomentOfInertia _simGetPrincipalMomentOfInertia;
extern ptr_simGetGravity _simGetGravity;
extern ptr_simGetTimeDiffInMs _simGetTimeDiffInMs;
extern ptr_simDoEntitiesCollide _simDoEntitiesCollide;
extern ptr_simGetDistanceBetweenEntitiesIfSmaller _simGetDistanceBetweenEntitiesIfSmaller;
extern ptr_simHandleJointControl _simHandleJointControl;
extern ptr_simHandleCustomContact _simHandleCustomContact;
extern ptr_simGetPureHollowScaling _simGetPureHollowScaling;
extern ptr_simGetJointCallbackCallOrder _simGetJointCallbackCallOrder;
extern ptr_simDynCallback _simDynCallback;


// Deprecated begin
typedef simInt (__cdecl *ptrSimGetMaterialId)(const simChar* materialName);
typedef simInt (__cdecl *ptrSimGetShapeMaterial)(simInt shapeHandle);
typedef simInt (__cdecl *ptrSimHandleVarious)();
typedef simInt (__cdecl *ptrSimSerialPortOpen)(simInt portNumber,simInt baudRate,simVoid* reserved1,simVoid* reserved2);
typedef simInt (__cdecl *ptrSimSerialPortClose)(simInt portNumber);
typedef simInt (__cdecl *ptrSimSerialPortSend)(simInt portNumber,const simChar* data,simInt dataLength);
typedef simInt (__cdecl *ptrSimSerialPortRead)(simInt portNumber,simChar* buffer,simInt dataLengthToRead);
typedef simInt (__cdecl *ptrSimJointGetForce)(simInt jointHandle,simFloat* forceOrTorque);
typedef simInt (__cdecl *ptrSimGetPathPlanningHandle)(const simChar* pathPlanningObjectName);
typedef simInt (__cdecl *ptrSimGetMotionPlanningHandle)(const simChar* motionPlanningObjectName);
typedef simInt (__cdecl *ptrSimGetMpConfigForTipPose)(simInt motionPlanningObjectHandle,simInt options,simFloat closeNodesDistance,simInt trialCount,const simFloat* tipPose,simInt maxTimeInMs,simFloat* outputJointPositions,const simFloat* referenceConfigs,simInt referenceConfigCount,const simFloat* jointWeights,const simInt* jointBehaviour,simInt correctionPasses);
typedef simFloat* (__cdecl *ptrSimFindMpPath)(simInt motionPlanningObjectHandle,const simFloat* startConfig,const simFloat* goalConfig,simInt options,simFloat stepSize,simInt* outputConfigsCnt,simInt maxTimeInMs,simFloat* reserved,const simInt* auxIntParams,const simFloat* auxFloatParams);
typedef simFloat* (__cdecl *ptrSimSimplifyMpPath)(simInt motionPlanningObjectHandle,const simFloat* pathBuffer,simInt configCnt,simInt options,simFloat stepSize,simInt increment,simInt* outputConfigsCnt,simInt maxTimeInMs,simFloat* reserved,const simInt* auxIntParams,const simFloat* auxFloatParams);
typedef simFloat* (__cdecl *ptrSimFindIkPath)(simInt motionPlanningObjectHandle,const simFloat* startConfig,const simFloat* goalPose,simInt options,simFloat stepSize,simInt* outputConfigsCnt,simFloat* reserved,const simInt* auxIntParams,const simFloat* auxFloatParams);
typedef simFloat* (__cdecl *ptrSimGetMpConfigTransition)(simInt motionPlanningObjectHandle,const simFloat* startConfig,const simFloat* goalConfig,simInt options,const simInt* select,simFloat calcStepSize,simFloat maxOutStepSize,simInt wayPointCnt,const simFloat* wayPoints,simInt* outputConfigsCnt,const simInt* auxIntParams,const simFloat* auxFloatParams);
typedef simInt (__cdecl *ptrSimCreateMotionPlanning)(simInt jointCnt,const simInt* jointHandles,const simInt* jointRangeSubdivisions,const simFloat* jointMetricWeights,simInt options,const simInt* intParams,const simFloat* floatParams,const simVoid* reserved);
typedef simInt (__cdecl *ptrSimRemoveMotionPlanning)(simInt motionPlanningHandle);
typedef simInt (__cdecl *ptrSimSearchPath)(simInt pathPlanningObjectHandle,simFloat maximumSearchTime);
typedef simInt (__cdecl *ptrSimInitializePathSearch)(simInt pathPlanningObjectHandle,simFloat maximumSearchTime,simFloat searchTimeStep);
typedef simInt (__cdecl *ptrSimPerformPathSearchStep)(simInt temporaryPathSearchObject,simBool abortSearch);
typedef simInt (__cdecl *ptrSimLockInterface)(simBool locked);
typedef simInt (__cdecl *ptrSimCopyPasteSelectedObjects)();
typedef simInt (__cdecl *ptrSimResetPath)(simInt pathHandle);
typedef simInt (__cdecl *ptrSimHandlePath)(simInt pathHandle,simFloat deltaTime);
typedef simInt (__cdecl *ptrSimResetJoint)(simInt jointHandle);
typedef simInt (__cdecl *ptrSimHandleJoint)(simInt jointHandle,simFloat deltaTime);
typedef simInt (__cdecl *ptrSimAppendScriptArrayEntry)(const simChar* reservedSetToNull,simInt scriptHandleOrType,const simChar* arrayNameAtScriptName,const simChar* keyName,const simChar* data,const simInt* what);
typedef simInt (__cdecl *ptrSimClearScriptVariable)(const simChar* reservedSetToNull,simInt scriptHandleOrType,const simChar* variableNameAtScriptName);
typedef simVoid (__cdecl *ptr_simGetJointOdeParameters)(const simVoid* joint,simFloat* stopERP,simFloat* stopCFM,simFloat* bounce,simFloat* fudge,simFloat* normalCFM);
typedef simVoid (__cdecl *ptr_simGetJointBulletParameters)(const simVoid* joint,simFloat* stopERP,simFloat* stopCFM,simFloat* normalCFM);
typedef simVoid (__cdecl *ptr_simGetOdeMaxContactFrictionCFMandERP)(const simVoid* geomInfo,simInt* maxContacts,simFloat* friction,simFloat* cfm,simFloat* erp);
typedef simBool (__cdecl *ptr_simGetBulletCollisionMargin)(const simVoid* geomInfo,simFloat* margin,simInt* otherProp);
typedef simBool (__cdecl *ptr_simGetBulletStickyContact)(const simVoid* geomInfo);
typedef simFloat (__cdecl *ptr_simGetBulletRestitution)(const simVoid* geomInfo);
typedef simVoid (__cdecl *ptr_simGetVortexParameters)(const simVoid* object,simInt version,simFloat* floatParams,simInt* intParams);
typedef simVoid (__cdecl *ptr_simGetNewtonParameters)(const simVoid* object,simInt* version,simFloat* floatParams,simInt* intParams);
typedef simVoid (__cdecl *ptr_simGetDamping)(const simVoid* geomInfo,simFloat* linDamping,simFloat* angDamping);
typedef simFloat (__cdecl *ptr_simGetFriction)(const simVoid* geomInfo);
typedef simInt (__cdecl *ptrSimAddSceneCustomData)(simInt header,const simChar* data,simInt dataLength);
typedef simInt (__cdecl *ptrSimGetSceneCustomDataLength)(simInt header);
typedef simInt (__cdecl *ptrSimGetSceneCustomData)(simInt header,simChar* data);
typedef simInt (__cdecl *ptrSimAddObjectCustomData)(simInt objectHandle,simInt header,const simChar* data,simInt dataLength);
typedef simInt (__cdecl *ptrSimGetObjectCustomDataLength)(simInt objectHandle,simInt header);
typedef simInt (__cdecl *ptrSimGetObjectCustomData)(simInt objectHandle,simInt header,simChar* data);
typedef simInt (__cdecl *ptrSimCreateUI)(const simChar* uiName,simInt menuAttributes,const simInt* clientSize,const simInt* cellSize,simInt* buttonHandles);
typedef simInt (__cdecl *ptrSimCreateUIButton)(simInt uiHandle,const simInt* position,const simInt* size,simInt buttonProperty);
typedef simInt (__cdecl *ptrSimGetUIHandle)(const simChar* uiName);
typedef simInt (__cdecl *ptrSimGetUIProperty)(simInt uiHandle);
typedef simInt (__cdecl *ptrSimGetUIEventButton)(simInt uiHandle,simInt* auxiliaryValues);
typedef simInt (__cdecl *ptrSimSetUIProperty)(simInt uiHandle,simInt elementProperty);
typedef simInt (__cdecl *ptrSimGetUIButtonProperty)(simInt uiHandle,simInt buttonHandle);
typedef simInt (__cdecl *ptrSimSetUIButtonProperty)(simInt uiHandle,simInt buttonHandle,simInt buttonProperty);
typedef simInt (__cdecl *ptrSimGetUIButtonSize)(simInt uiHandle,simInt buttonHandle,simInt* size);
typedef simInt (__cdecl *ptrSimSetUIButtonLabel)(simInt uiHandle,simInt buttonHandle,const simChar* upStateLabel,const simChar* downStateLabel);
typedef simChar* (__cdecl *ptrSimGetUIButtonLabel)(simInt uiHandle,simInt buttonHandle);
typedef simInt (__cdecl *ptrSimSetUISlider)(simInt uiHandle,simInt buttonHandle,simInt position);
typedef simInt (__cdecl *ptrSimGetUISlider)(simInt uiHandle,simInt buttonHandle);
typedef simInt (__cdecl *ptrSimSetUIButtonColor)(simInt uiHandle,simInt buttonHandle,const simFloat* upStateColor,const simFloat* downStateColor,const simFloat* labelColor);
typedef simInt (__cdecl *ptrSimSetUIButtonTexture)(simInt uiHandle,simInt buttonHandle,const simInt* size,const simChar* textureData);
typedef simInt (__cdecl *ptrSimCreateUIButtonArray)(simInt uiHandle,simInt buttonHandle);
typedef simInt (__cdecl *ptrSimSetUIButtonArrayColor)(simInt uiHandle,simInt buttonHandle,const simInt* position,const simFloat* color);
typedef simInt (__cdecl *ptrSimDeleteUIButtonArray)(simInt uiHandle,simInt buttonHandle);
typedef simInt (__cdecl *ptrSimRemoveUI)(simInt uiHandle);
typedef simInt (__cdecl *ptrSimSetUIPosition)(simInt uiHandle,const simInt* position);
typedef simInt (__cdecl *ptrSimGetUIPosition)(simInt uiHandle,simInt* position);
typedef simInt (__cdecl *ptrSimLoadUI)(const simChar* filename,int maxCount,int* uiHandles);
typedef simInt (__cdecl *ptrSimSaveUI)(int count,const int* uiHandles,const simChar* filename);
typedef simInt (__cdecl *ptrSimHandleGeneralCallbackScript)(simInt callbackId,simInt callbackTag,simVoid* additionalData);
typedef simInt (__cdecl *ptrSimRegisterCustomLuaFunction)(const simChar* funcName,const simChar* callTips,const simInt* inputArgumentTypes,simVoid(*callBack)(struct SLuaCallBack* p));
typedef simInt (__cdecl *ptrSimRegisterCustomLuaVariable)(const simChar* varName,const simChar* varValue);
typedef simInt (__cdecl *ptrSimRegisterContactCallback)(simInt(*callBack)(simInt,simInt,simInt,simInt*,simFloat*));
typedef simInt (__cdecl *ptrSimGetMechanismHandle)(const simChar* mechanismName);
typedef simInt (__cdecl *ptrSimHandleMechanism)(simInt mechanismHandle);
typedef simInt (__cdecl *ptrSimHandleCustomizationScripts)(simInt callType);
typedef simInt (__cdecl *ptrSimCallScriptFunction)(simInt scriptHandleOrType,const simChar* functionNameAtScriptName,SLuaCallBack* data,const simChar* reservedSetToNull);
typedef simInt (__cdecl *ptrSimSetVisionSensorFilter)(simInt visionSensorHandle,simInt filterIndex,simInt options,const simInt* pSizes,const simUChar* bytes,const simInt* ints,const simFloat* floats,const simUChar* custom);
typedef simInt (__cdecl *ptrSimGetVisionSensorFilter)(simInt visionSensorHandle,simInt filterIndex,simInt* options,simInt* pSizes,simUChar** bytes,simInt** ints,simFloat** floats,simUChar** custom);
typedef simChar* (__cdecl *ptrSimGetScriptSimulationParameter)(simInt scriptHandle,const simChar* parameterName,simInt* parameterLength);
typedef simInt (__cdecl *ptrSimSetScriptSimulationParameter)(simInt scriptHandle,const simChar* parameterName,const simChar* parameterValue,simInt parameterLength);
typedef simInt (__cdecl *ptrSimSetJointForce)(simInt objectHandle,simFloat forceOrTorque);
extern ptrSimGetMaterialId simGetMaterialId;
extern ptrSimGetShapeMaterial simGetShapeMaterial;
extern ptrSimHandleVarious simHandleVarious;
extern ptrSimSerialPortOpen simSerialPortOpen;
extern ptrSimSerialPortClose simSerialPortClose;
extern ptrSimSerialPortSend simSerialPortSend;
extern ptrSimSerialPortRead simSerialPortRead;
extern ptrSimJointGetForce simJointGetForce;
extern ptrSimGetPathPlanningHandle simGetPathPlanningHandle;
extern ptrSimGetMotionPlanningHandle simGetMotionPlanningHandle;
extern ptrSimGetMpConfigForTipPose simGetMpConfigForTipPose;
extern ptrSimFindMpPath simFindMpPath;
extern ptrSimSimplifyMpPath simSimplifyMpPath;
extern ptrSimFindIkPath simFindIkPath;
extern ptrSimGetMpConfigTransition simGetMpConfigTransition;
extern ptrSimCreateMotionPlanning simCreateMotionPlanning;
extern ptrSimRemoveMotionPlanning simRemoveMotionPlanning;
extern ptrSimSearchPath simSearchPath;
extern ptrSimInitializePathSearch simInitializePathSearch;
extern ptrSimPerformPathSearchStep simPerformPathSearchStep;
extern ptrSimLockInterface simLockInterface;
extern ptrSimCopyPasteSelectedObjects simCopyPasteSelectedObjects;
extern ptrSimResetPath simResetPath;
extern ptrSimHandlePath simHandlePath;
extern ptrSimResetJoint simResetJoint;
extern ptrSimHandleJoint simHandleJoint;
extern ptrSimAppendScriptArrayEntry simAppendScriptArrayEntry;
extern ptrSimClearScriptVariable simClearScriptVariable;
extern ptr_simGetJointOdeParameters _simGetJointOdeParameters;
extern ptr_simGetJointBulletParameters _simGetJointBulletParameters;
extern ptr_simGetOdeMaxContactFrictionCFMandERP _simGetOdeMaxContactFrictionCFMandERP;
extern ptr_simGetBulletCollisionMargin _simGetBulletCollisionMargin;
extern ptr_simGetBulletStickyContact _simGetBulletStickyContact;
extern ptr_simGetBulletRestitution _simGetBulletRestitution;
extern ptr_simGetVortexParameters _simGetVortexParameters;
extern ptr_simGetNewtonParameters _simGetNewtonParameters;
extern ptr_simGetDamping _simGetDamping;
extern ptr_simGetFriction _simGetFriction;
extern ptrSimAddSceneCustomData simAddSceneCustomData;
extern ptrSimGetSceneCustomDataLength simGetSceneCustomDataLength;
extern ptrSimGetSceneCustomData simGetSceneCustomData;
extern ptrSimAddObjectCustomData simAddObjectCustomData;
extern ptrSimGetObjectCustomDataLength simGetObjectCustomDataLength;
extern ptrSimGetObjectCustomData simGetObjectCustomData;
extern ptrSimCreateUI simCreateUI;
extern ptrSimCreateUIButton simCreateUIButton;
extern ptrSimGetUIHandle simGetUIHandle;
extern ptrSimGetUIProperty simGetUIProperty;
extern ptrSimGetUIEventButton simGetUIEventButton;
extern ptrSimSetUIProperty simSetUIProperty;
extern ptrSimGetUIButtonProperty simGetUIButtonProperty;
extern ptrSimSetUIButtonProperty simSetUIButtonProperty;
extern ptrSimGetUIButtonSize simGetUIButtonSize;
extern ptrSimSetUIButtonLabel simSetUIButtonLabel;
extern ptrSimGetUIButtonLabel simGetUIButtonLabel;
extern ptrSimSetUISlider simSetUISlider;
extern ptrSimGetUISlider simGetUISlider;
extern ptrSimSetUIButtonColor simSetUIButtonColor;
extern ptrSimSetUIButtonTexture simSetUIButtonTexture;
extern ptrSimCreateUIButtonArray simCreateUIButtonArray;
extern ptrSimSetUIButtonArrayColor simSetUIButtonArrayColor;
extern ptrSimDeleteUIButtonArray simDeleteUIButtonArray;
extern ptrSimRemoveUI simRemoveUI;
extern ptrSimSetUIPosition simSetUIPosition;
extern ptrSimGetUIPosition simGetUIPosition;
extern ptrSimLoadUI simLoadUI;
extern ptrSimSaveUI simSaveUI;
extern ptrSimHandleGeneralCallbackScript simHandleGeneralCallbackScript;
extern ptrSimRegisterCustomLuaFunction simRegisterCustomLuaFunction;
extern ptrSimRegisterCustomLuaVariable simRegisterCustomLuaVariable;
extern ptrSimRegisterContactCallback simRegisterContactCallback;
extern ptrSimGetMechanismHandle simGetMechanismHandle;
extern ptrSimHandleMechanism simHandleMechanism;
extern ptrSimHandleCustomizationScripts simHandleCustomizationScripts;
extern ptrSimCallScriptFunction simCallScriptFunction;
extern ptrSimSetVisionSensorFilter simSetVisionSensorFilter;
extern ptrSimGetVisionSensorFilter simGetVisionSensorFilter;
extern ptrSimGetScriptSimulationParameter simGetScriptSimulationParameter;
extern ptrSimSetScriptSimulationParameter simSetScriptSimulationParameter;
extern ptrSimSetJointForce simSetJointForce;
// Deprecated end

#endif // !defined(SIMLIB_INCLUDED_)
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.42">@path ./v-rep_plugin/coppelia/include/
#if !defined(SIMTYPES_INCLUDED_)
#define SIMTYPES_INCLUDED_

// Various types used in the interface functions:
typedef unsigned char simBool;
typedef char simChar;
typedef int simInt;
typedef float simFloat;
typedef double simDouble;
typedef void simVoid;
typedef unsigned char simUChar;
typedef unsigned int simUInt;
typedef unsigned long long int simUInt64;

struct SScriptCallBack
{
    simInt objectID;
    simInt scriptID;
    simInt stackID;
    simChar waitUntilZero;
    simChar* raiseErrorWithMessage;
};

struct SShapeVizInfo
{
    simFloat* vertices;
    simInt verticesSize;
    simInt* indices;
    simInt indicesSize;
    simFloat shadingAngle;
    simFloat* normals;
    simFloat colors[9];
    simChar* texture; /*rgba*/
    simInt textureId;
    simInt textureRes[2];
    simFloat* textureCoords;
    simInt textureApplyMode;
    simInt textureOptions;
};

struct SLuaCallBack
{
    simInt objectID;
    simBool* inputBool;
    simInt* inputInt;
    simFloat* inputFloat;
    simChar* inputChar;
    simInt inputArgCount;
    simInt* inputArgTypeAndSize;
    simBool* outputBool;
    simInt* outputInt;
    simFloat* outputFloat;
    simChar* outputChar;
    simInt outputArgCount;
    simInt* outputArgTypeAndSize;
    simChar waitUntilZero;
    simChar* inputCharBuff;
    simChar* outputCharBuff;
    simInt scriptID;
    simDouble* inputDouble;
    simDouble* outputDouble;
};

typedef int (*contactCallback)(int,int,int,int*,float*);
typedef int (*jointCtrlCallback)(int,int,int,const int*,const float*,float*);

#endif // !defined(SIMTYPES_INCLUDED_)
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.43">@path ./v-rep_plugin/coppelia/include/
#pragma once

#include &lt;vector&gt;
#include &lt;string&gt;

#ifdef _WIN32
    #include &lt;winsock2.h&gt;
    #include &lt;Windows.h&gt;
    #include &lt;process.h&gt;
    #ifndef QT_COMPIL
        #pragma message("Adding library: Winmm.lib")
        #pragma comment(lib,"Winmm.lib")
        #pragma message("Adding library: Ws2_32.lib")
        #pragma comment(lib,"Ws2_32.lib")
    #endif
    typedef timeval             _timeval;
    typedef int                 _socklen;
#elif defined (__linux) || defined (__APPLE__)
    #include &lt;string.h&gt;
    #include &lt;sys/time.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;netdb.h&gt;
    #define SOCKET int
    #define INVALID_SOCKET (-1)
    typedef socklen_t _socklen;
#endif


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.44">class CSocketInConnection
{
public:
    CSocketInConnection(int theConnectionPort,unsigned short maxPacketSize=250,char headerID1=59,char headerID2=57);
    virtual ~CSocketInConnection();

    bool connectToClient();
    char* receiveData(int&amp; dataSize);
    bool replyToReceivedData(char* data,int dataSize);

    std::string getConnectedMachineIP();

protected:
    bool _sendSimplePacket(char* packet,int packetLength,unsigned short packetsLeft);
    int _receiveSimplePacket(std::vector&lt;char&gt;&amp; packet);

    unsigned int _getTimeInMs();
    unsigned int _getTimeDiffInMs(unsigned int lastTime);


    SOCKET _socketServer;
    SOCKET _socketClient;
    struct sockaddr_in _socketLocal;

    fd_set _socketTheSet;
#ifdef _WIN32
    WSADATA _socketWsaData;
#endif /* _WIN32 */

    int _socketConnectionPort;
    bool _socketConnectWasOk;
    std::string _socketConnectedMachineIP;

    char _headerByte1;
    char _headerByte2;
    unsigned short _maxPacketSize;
};
</t>
<t tx="leo.20220407205632.45">@path ./v-rep_plugin/coppelia/include/
#pragma once

#include &lt;vector&gt;
#include &lt;string&gt;

#ifdef _WIN32
    #include &lt;Windows.h&gt;
    #include &lt;process.h&gt;
    #ifndef QT_COMPIL
        #pragma message("Adding library: Winmm.lib")
        #pragma comment(lib,"Winmm.lib")
        #pragma message("Adding library: Ws2_32.lib")
        #pragma comment(lib,"Ws2_32.lib")
    #endif
#elif defined (__linux) || defined (__APPLE__)
    #include &lt;sys/time.h&gt;
    #include &lt;unistd.h&gt;
    #include &lt;sys/socket.h&gt;
    #include &lt;arpa/inet.h&gt;
    #include &lt;netdb.h&gt;
    #define SOCKET int
    #define INVALID_SOCKET (-1)
#endif

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.46">class CSocketOutConnection  
{
public:
    CSocketOutConnection(const char* theConnectionAddress,int theConnectionPort,unsigned short maxPacketSize=250,char headerID1=59,char headerID2=57);
    virtual ~CSocketOutConnection();

    int connectToServer();
    bool sendData(const char* data,int dataSize);
    char* receiveReplyData(int&amp; dataSize);

protected:
    bool _sendSimplePacket(const char* packet,int packetLength,unsigned short packetsLeft);
    int _receiveSimplePacket(std::vector&lt;char&gt;&amp; packet);

    int _getTimeInMs();
    int _getTimeDiffInMs(int lastTime);

    std::string         _socketConnectionAddress;
    int                 _socketConnectionPort;

#ifdef _WIN32
    WSADATA _socketWsaData;
#else

#endif
    SOCKET _socketConn;
    struct sockaddr_in _socketServer;

    char _headerByte1;
    char _headerByte2;
    unsigned short _maxPacketSize;
};
</t>
<t tx="leo.20220407205632.47"></t>
<t tx="leo.20220407205632.48">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once

#include &lt;vector&gt;
#include "stackObject.h"

class CStackMap;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.49">class CStackArray : public CStackObject
{
public:
    CStackArray();
    virtual ~CStackArray();

    std::string toString() const;

    bool buildFromStack(int stackId);
    void buildOntoStack(int stackId);

    void appendTopStackItem(int stackId);

    CStackObject* copyYourself();

    bool pushNull();
    bool pushBool(bool d);
    bool pushFloat(float d);
    bool pushDouble(double d);
    bool pushInt(int d);
    bool pushString(const std::string&amp; d);
    bool pushString(const char* d,size_t bufferLength);
    bool pushArray(CStackArray* arr);
    bool pushMap(CStackMap* map);
    bool setDoubleArray(const double* d,size_t l);
    bool setIntArray(const int* d,size_t l);

    bool isNumberArray();
    size_t getSize();

    bool isNull(size_t index);
    bool isBool(size_t index);
    bool isNumber(size_t index);
    bool isString(size_t index);
    bool isArray(size_t index,size_t minSize=0);
    bool isMap(size_t index);
    
    void setCircularRef();
    bool isCircularRef();

    bool getBool(size_t index);
    float getFloat(size_t index);
    double getDouble(size_t index);
    int getInt(size_t index);
    std::string getString(size_t index);
    CStackArray* getArray(size_t index);
    CStackMap* getMap(size_t index);

    const std::vector&lt;CStackObject*&gt;* getObjects();
    const std::vector&lt;double&gt;* getDoubles();
    const std::vector&lt;int&gt;* getInts();
    const double* getDoublePointer();
    const int* getIntPointer();

protected:
    std::vector&lt;CStackObject*&gt; _objectValues;
    std::vector&lt;double&gt; _doubleValues;
    std::vector&lt;int&gt; _intValues;
    bool _circularRef;
};
</t>
<t tx="leo.20220407205632.5">void CStackNumber::setIntValue(int n)
{
    _value=(int)n;
}

</t>
<t tx="leo.20220407205632.50">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once

#include "stackObject.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.51">class CStackBool : public CStackObject
{
public:
    CStackBool(bool theValue);
    virtual ~CStackBool();

    std::string toString() const;

    CStackObject* copyYourself();

    bool getValue();
    void setValue(bool theValue);

protected:
    bool _value;
};
</t>
<t tx="leo.20220407205632.52">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once

#include "stackObject.h"
#include &lt;map&gt;

class CStackArray;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.53">class CStackMap : public CStackObject
{
public:
    CStackMap();
    virtual ~CStackMap();

    std::string toString() const;

    void appendTopStackItem(const char* key,int stackId);
    void appendTopStackItem(int key,int stackId);
    void appendTopStackItem(bool key,int stackId);

    CStackObject* copyYourself();

    void setNull(const char* key);
    void setBool(const char* key,bool d);
    void setFloat(const char* key,float d);
    void setDouble(const char* key,double d);
    void setInt(const char* key,int d);
    void setString(const char* key,const std::string&amp; d);
    void setString(const char* key,const char* d,size_t bufferLength);
    void setArray(const char* key,CStackArray* arr);
    void setMap(const char* key,CStackMap* map);

    void setNull(int key);
    void setBool(int key,bool d);
    void setFloat(int key,float d);
    void setDouble(int key,double d);
    void setInt(int key,int d);
    void setString(int key,const std::string&amp; d);
    void setString(int key,const char* d,size_t bufferLength);
    void setArray(int key,CStackArray* arr);
    void setMap(int key,CStackMap* map);

    void setNull(bool key);
    void setBool(bool key,bool d);
    void setFloat(bool key,float d);
    void setDouble(bool key,double d);
    void setInt(bool key,int d);
    void setString(bool key,const std::string&amp; d);
    void setString(bool key,const char* d,size_t bufferLength);
    void setArray(bool key,CStackArray* arr);
    void setMap(bool key,CStackMap* map);

    bool isKeyPresent(const char* key);
    bool isNull(const char* key);
    bool isBool(const char* key);
    bool isNumber(const char* key);
    bool isString(const char* key);
    bool isArray(const char* key,size_t minSize=0);
    bool isMap(const char* key);

    bool isKeyPresent(int key);
    bool isNull(int key);
    bool isBool(int key);
    bool isNumber(int key);
    bool isString(int key);
    bool isArray(int key,size_t minSize=0);
    bool isMap(int key);

    bool isKeyPresent(bool key);
    bool isNull(bool key);
    bool isBool(bool key);
    bool isNumber(bool key);
    bool isString(bool key);
    bool isArray(bool key,size_t minSize=0);
    bool isMap(bool key);

    bool getBool(const char* key);
    float getFloat(const char* key);
    double getDouble(const char* key);
    int getInt(const char* key);
    std::string getString(const char* key);
    CStackArray* getArray(const char* key);
    CStackMap* getMap(const char* key);

    bool getBool(int key);
    float getFloat(int key);
    double getDouble(int key);
    int getInt(int key);
    std::string getString(int key);
    CStackArray* getArray(int key);
    CStackMap* getMap(int key);

    bool getBool(bool key);
    float getFloat(bool key);
    double getDouble(bool key);
    int getInt(bool key);
    std::string getString(bool key);
    CStackArray* getArray(bool key);
    CStackMap* getMap(bool key);

    bool contains(const char* key,int theType=-1,size_t theMinSizeIfArray=0,bool onlyNumbersInArray=false);
    bool contains(int key,int theType=-1,size_t theMinSizeIfArray=0,bool onlyNumbersInArray=false);
    bool contains(bool key,int theType=-1,size_t theMinSizeIfArray=0,bool onlyNumbersInArray=false);

    std::map&lt;std::string,CStackObject*&gt;* getKeyValuePairs();
    std::map&lt;std::string,CStackObject*&gt;* getKeyValuePairsKStr();
    std::map&lt;int,CStackObject*&gt;* getKeyValuePairsKInt();
    std::map&lt;bool,CStackObject*&gt;* getKeyValuePairsKBool();

protected:
    void _remove(const char* key);
    void _remove(int key);
    void _remove(bool key);

    std::map&lt;std::string,CStackObject*&gt; _objectValuesKStr;
    std::map&lt;int,CStackObject*&gt; _objectValuesKInt;
    std::map&lt;bool,CStackObject*&gt; _objectValuesKBool;
};
</t>
<t tx="leo.20220407205632.54">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once

#include "stackObject.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.55">class CStackNull : public CStackObject
{
public:
    CStackNull();
    virtual ~CStackNull();

    std::string toString() const;

    CStackObject* copyYourself();
};
</t>
<t tx="leo.20220407205632.56">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once

#include "stackObject.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.57">class CStackNumber : public CStackObject
{
public:
    CStackNumber(double n);
    virtual ~CStackNumber();

    std::string toString() const;

    CStackObject* copyYourself();

    float getFloatValue();
    int getIntValue();
    long getLongValue();
    double getValue();
    void setFloatValue(float n);
    void setIntValue(int n);
    void setLongValue(long n);
    void setValue(double n);

protected:
    double _value;
};
</t>
<t tx="leo.20220407205632.58">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once
#include "simLib.h"
#include &lt;string&gt;

enum {  STACK_NULL=0,
        STACK_NUMBER,
        STACK_BOOL,
        STACK_STRING,
        STACK_ARRAY,
        STACK_MAP
};

class CStackNull;
class CStackNumber;
class CStackBool;
class CStackString;
class CStackArray;
class CStackMap;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.59">class CStackObject
{
public:
    CStackObject();
    virtual ~CStackObject();

    virtual CStackObject* copyYourself();

    int getObjectType() const;

    static void buildItemOntoStack(int stackId,CStackObject* obj);
    static CStackObject* buildItemFromTopStackPosition(int stackId);

    CStackNull* asNull();
    CStackNumber* asNumber();
    CStackBool* asBool();
    CStackString* asString();
    CStackArray* asArray();
    CStackMap* asMap();

    virtual std::string toString() const = 0;
    std::string getObjectTypeString() const;

protected:
    int _objectType;
};
</t>
<t tx="leo.20220407205632.6">void CStackNumber::setLongValue(long n)
{
    _value=(long)n;
}

</t>
<t tx="leo.20220407205632.60">@path ./v-rep_plugin/coppelia/include/stack/
#pragma once

#include "stackObject.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.61">class CStackString : public CStackObject
{
public:
    CStackString(const char* str,int l);
    virtual ~CStackString();

    std::string toString() const;

    CStackObject* copyYourself();

    std::string getValue();
    void setValue(const char* str,int l);

protected:
    std::string _value;
};
</t>
<t tx="leo.20220407205632.62"></t>
<t tx="leo.20220407205632.63">@path ./v-rep_plugin/include/
#pragma once

#include "basic_concurrent_queue.h"
#include "vector_concurrent_queue.h"
#include "pair_concurrent_queue.h"

#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.64">class Extruder {
public:
    Extruder(const std::string &amp;ename, const std::string &amp;bname);

    // Set initial height minus object half-size
    void SetInitialTransformation(const std::vector&lt;float&gt; &amp;transf);
    std::vector&lt;float&gt; GetInitialTransformation();
    void CalculateWorldPoint(const std::vector&lt;double&gt; &amp;cpos, float wp[3]);
    void CalculateWorldPoint(float cpos[3], float wp[3]);

    void CalculateRealPoint(const std::vector&lt;double&gt; &amp;cpos, std::vector&lt;double&gt; &amp;bpos);
    double CalculateRealDistancePoints(const std::vector&lt;double&gt; &amp;lpos, const std::vector&lt;double&gt; &amp;cpos);

    void SetFilamentType(int type_id);
    int GetFilamentType();
    void SetFilamentColor(int color_id);
    float* GetFilamentColor();
    void SetFilamentSize(float size);
    float GetFilamentSize();
    void SetFilamentResolution(float res);
    float GetFilamentResolution();

public:
    std::string ext_name;
    int ext_handle;
    std::string bed_name;
    int bed_handle;
    std::string octree_name;
    int octree_handle;
    double octree_leaf_size;
    std::map&lt;int, std::vector&lt;float&gt; &gt; color_map;

    // G0 instructions filament
    std::vector&lt;float&gt; alternative_color1;
    float alternative_size1;

    std::vector&lt;int&gt; paint_handle;
    VectorConcurrentQueue&lt;float&gt; paint_items;
    VectorConcurrentQueue&lt;float&gt; paint_items2;

    //std::deque&lt;int&gt; object_list;
    //BasicConcurrentQueue&lt;int&gt; all_drawing;

    void PaintInfo(const int type, std::vector&lt;float&gt; &amp;color, float &amp;size);
    PairConcurrentQueue&lt; bool, int &gt; paint;

public:
    int drawobj_mode;
    float drawobj_color[3];
    float drawobj_size;
    size_t buffer_size;
    //last detected and transformed point (extruder to world)
    float last_printer_point[5];

private:
    float filament_resolution;
    
    std::vector&lt;float&gt; init_transf;
    std::mutex mutex_filament;
};
</t>
<t tx="leo.20220407205632.65">@path ./v-rep_plugin/include/
#pragma once

#include "Trajectory.h"

#include &lt;deque&gt;
#include &lt;string&gt;

enum KEYCODE {
    RapidMove = 1000,
    IncRapidMove = 1002,
    LinearMove = 1020,
    IncLinearMove = 1022,
    ArcMoveCenter = 1040,
    ArcMoveRadius = 1042,
    CircleMove = 1044,
    IncArcMoveCenter = 1046,
    IncArcMoveRadius = 1048,
    IncCircleMove = 1050,
    Dwell = 1080
};

struct package
{
    KEYCODE keycode;
    bool bool1;
    bool bool2;
    bool extrude;

    std::string text;

    double coord1;

    double vec1[5];
    double vec2[5];
    
    int int1;

    double vel[3]; //current, target and next velocity
    double acc[3]; //3-axis acceleration values

    int line;
};

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.66">class Listener
{
public:
    Listener();

    void Interpret(std::string JSON_msg);

private:
    void Deserialize(std::string JSON_msg);
    void PushAction();

    void PullCurrentPosition(double *cjp);

private:
    package m_pack;
    std::vector&lt;double&gt; m_last_position;

    std::shared_ptr&lt;Motion::Trajectory&gt; m_trajectory;

    //FIFO - push back, pop top
    //std::deque&lt;std::vector&lt;double&gt; &gt; m_joint_queue;
};
</t>
<t tx="leo.20220407205632.67">@path ./v-rep_plugin/include/
#pragma once

namespace Motion {

    enum Plane {XY, XZ, YZ};

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.68">    class Path
    {
    public:
        Path();

        enum Planes { XY, XZ, YZ };
    
        void SetLinearPath(double xi[3], double xf[3]);
        void SetArcPath(double start[3], double finish[3], double center[3], Plane plane, bool clkwise);
        void SetArcPath(double start[3], double finish[3], double radius, Plane plane, bool clkwise);
        void SetCirclePath(double start[3], double center[3], Plane plane, bool clkwise);
        // 5-axis functionality
        void SetBCPath(double xi[2], double xf[2]);
    
        void GetLinearPath(double *u_vec);
        void GetArcPath(double &amp;gamma, double &amp;alpha, double *center);
        void GetArcPath(double &amp;gamma, double &amp;alpha, double &amp;radius);
        // 5-axis functionality
        void GetBCPath(double *u_bc_vec);

        double get_path_length();
        // 5-axis functionality
        double get_bc_path_length();

    private:
        //Both
        double m_tolerance;
        double m_path_length;
        double m_bc_path_length;

        //Linear path
        double m_unit_vec[3];
        double m_unit_bc_vec[2];

        //Arc path
        double m_gamma; //arc angle
        double m_alpha; //start angle
        double m_center[3];
        double m_radius;

    };

}
</t>
<t tx="leo.20220407205632.69">@path ./v-rep_plugin/include/
#pragma once

#include "basic_concurrent_queue.h"
#include "vector_concurrent_queue.h"

#include &lt;atomic&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.7">void CStackNumber::setValue(double n)
{
    _value=n;
}

CStackObject* CStackNumber::copyYourself()
{
    CStackNumber* retVal=new CStackNumber(_value);
    return(retVal);
}
</t>
<t tx="leo.20220407205632.70">class Printer {
public:
    Printer(const std::string &amp;pname, const int pdofs);

public:
    int handle;
    std::string name;
    int dofs;
    std::vector&lt;int&gt; joint_handles;
    std::atomic&lt;bool&gt; collisions_enabled;
    std::vector&lt;int&gt; collision_handles;
    bool ready;

public:
    //Current line
    BasicConcurrentQueue&lt;int&gt; line;
    VectorConcurrentQueue&lt;double&gt; target_jpos;

public:
    std::vector&lt;double&gt; get_cur_pos();
    void set_cur_pos(const std::vector&lt;double&gt; &amp;pos);

private:
    std::vector&lt;double&gt; cur_pos;
    std::mutex mutex_cpos;

};
</t>
<t tx="leo.20220407205632.71">@path ./v-rep_plugin/include/
//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2008 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#pragma once

#include &lt;boost/asio.hpp&gt;
#include &lt;boost/bind.hpp&gt;
#include &lt;boost/thread.hpp&gt;

#include "Listener.h"
#include "Speaker.h"

#include &lt;cstdlib&gt;
#include &lt;iostream&gt;

using boost::asio::ip::tcp;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.72">class SessionEcho
{
public:
    SessionEcho(boost::asio::io_service* io_service);
    tcp::socket&amp; get_socket();

    void start();
    void handle_read(const boost::system::error_code&amp; error, size_t bytes_transferred);
    void handle_write(const boost::system::error_code&amp; error);

private:
    tcp::socket socket_;
    enum {
        max_length = 512
    };
    char data_[max_length];

    std::unique_ptr&lt;Listener&gt; m_listener;
};

</t>
<t tx="leo.20220407205632.73">class SessionSend
{
public:
    SessionSend(boost::asio::io_service* io_service);
    tcp::socket&amp; get_socket();
    
    void deliver(int line, bool collision);
    void write();
    void handle_write(const boost::system::error_code&amp; error);

private:
    tcp::socket socket_;
    enum { 
        max_length = 1024
    };
    char data_[max_length];

    std::shared_ptr&lt;Speaker&gt; m_speaker;
};

</t>
<t tx="leo.20220407205632.74">class Server
{
public:
    Server(boost::asio::io_service* io_service, short port1, short port2 );
    //tcp::acceptor&amp; get_acceptor();

    void start_accept();
    void handle_accept_echo(const boost::system::error_code&amp; error);
    void handle_accept_send(const boost::system::error_code&amp; error);

    void broadcast(int line, bool collision);

    void cancel_sessions();

private:
    boost::asio::io_service* io_service_;

    tcp::acceptor acceptor_echo_;
    tcp::acceptor acceptor_send_;

    std::shared_ptr&lt;SessionEcho&gt; session_echo;
    std::shared_ptr&lt;SessionSend&gt; session_send;
};

//////////////////////////////////////////////////////////////////////

</t>
<t tx="leo.20220407205632.75">class CommunicationManager {
public:
    CommunicationManager();
    ~CommunicationManager();
    std::shared_ptr&lt;Server&gt; get_server();

    void LaunchServer();
    void StopServer();

private:
    boost::asio::io_service ios;
    std::shared_ptr&lt;boost::thread&gt; bt;
    std::shared_ptr&lt;Server&gt; server;
};
</t>
<t tx="leo.20220407205632.76">@path ./v-rep_plugin/include/
#pragma once

#include "string_concurrent_queue.h"

#include &lt;mutex&gt;
#include &lt;string&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.77">class Speaker
{
public:
    Speaker();

    // Serializes messages into JSON format - Called from simulator thread
    void Formulate(int line, bool collision);
    
    // Returns the number of messages stored in queue
    int NumberMessages();

    // Retrieves the current message and deletes it
    // Only 1 message stored and sent at a time
    std::string ReadMessage();

private:
    // Stores JSON messages - FIFO
    StringConcurrentQueue JSON_scq;
};
</t>
<t tx="leo.20220407205632.78">@path ./v-rep_plugin/include/
#pragma once

#include "Path.h"
#include "VelocityProfile.h"

#include &lt;memory&gt;

//! Trajectory Class
// Generates Robot trajectories for the robot based on a specified path and velocity profile.
//
// Path: defines the geometric shape of the trajectory.
// VelocityProfile: defines the timing law on how the path is followed.
//
// Based on the input commands the Trajectory class outputs an array of [x,y,z] actuator coordinates
// sampled at a specified 'dt'. This 'dt' should be coordinated with the simulation cycle.

namespace Motion {

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.79">    class Trajectory
    {
    public:
        Trajectory(double dt);

        void RapidTrajectory(double start[5], double finish[5], double vel[3], double acc);
        void LinearTrajectory(double start[5], double finish[5], double vel[3], double acc, bool interpolation);
        void ArcTrajectory(double start[5], double finish[5], double center[3], Plane plane, bool clkwise, double vel[3], double acc, bool interpolation);
        void ArcTrajectory(double start[5], double finish[5], double radius, Plane plane, bool clkwise, double vel[3], double acc, bool interpolation);
        void CircleTrajectory(double start[5], double center[5], Plane plane, bool clkwise, double vel[3], double acc, bool interpolation);
        void Dwell(double start[5], double time);

        void GetTrajectory(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;joints);

    private:
        std::vector&lt;double&gt; linspace(double a, double b, size_t N);
        void vector_split(double in[5], double out1[3], double out2[2]);

    private:
        //sampling time
        double m_dt; 

        std::unique_ptr&lt;Path&gt; m_path;
        std::unique_ptr&lt;VelocityProfile&gt; m_vel_prof;

        //vector of vector of 5 joint double values
        std::vector&lt;std::vector&lt;double&gt; &gt; m_joints;
    };

}

</t>
<t tx="leo.20220407205632.8">@path ./v-rep_plugin/coppelia/common/stack/
#include "stackObject.h"
#include "stackNull.h"
#include "stackNumber.h"
#include "stackBool.h"
#include "stackString.h"
#include "stackArray.h"
#include "stackMap.h"

CStackObject::CStackObject()
{
}

CStackObject::~CStackObject()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.80">@path ./v-rep_plugin/include/
#pragma once

#include &lt;vector&gt;

namespace Motion {

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.81">    class VelocityProfile
    {
    public:
        VelocityProfile(double dt);

        void SetRampProfile(double vel[3], double acc, double length);
        void SetInterpolationProfile(double vel_i, double vel_f, double length);

        void GetProfile(double &amp;path_time, std::vector&lt;double&gt; &amp;path_pos);
        bool quadroots(double a, double b, double c, double &amp;r1, double &amp;r2);

    private:
        double m_dt;

        std::vector&lt;double&gt; m_path_pos;
        double m_path_time;
    };

}

</t>
<t tx="leo.20220407205632.82">@path ./v-rep_plugin/include/
#ifndef V_REPEXT_BASIC_CONCURRENT_QUEUE
#define V_REPEXT_BASIC_CONCURRENT_QUEUE

#include &lt;deque&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;

template &lt;typename T&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.83">class BasicConcurrentQueue {
public:
    BasicConcurrentQueue();

    void push_front(const T t);
    void push_back(const T t);

    T&amp; front();
    T&amp; back();
    //Not retrived the reference, because the object is destroyed right after
    T only_back();

    T&amp; operator[](std::size_t idx);
    
    void pop_back();
    void clear();

    bool empty();
    int size();

private:
    std::deque&lt;T&gt; m_deque;
    std::mutex m_mutex;
    std::condition_variable m_cond;
};

template&lt;typename T&gt;
BasicConcurrentQueue&lt;T&gt;::BasicConcurrentQueue()
{}

template&lt;typename T&gt;
</t>
<t tx="leo.20220407205632.84">void BasicConcurrentQueue&lt;T&gt;::push_front(const T t) {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_front(t);
    lk.unlock();
    m_cond.notify_one();
}

template&lt;typename T&gt;
</t>
<t tx="leo.20220407205632.85">void BasicConcurrentQueue&lt;T&gt;::push_back(const T t) {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_back(t);
    lk.unlock();
    m_cond.notify_one();
}

template&lt;typename T&gt;
T&amp; BasicConcurrentQueue&lt;T&gt;::front() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.front();
}

template&lt;typename T&gt;
T&amp; BasicConcurrentQueue&lt;T&gt;::back() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.back();
}

template&lt;typename T&gt;
T BasicConcurrentQueue&lt;T&gt;::only_back() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    T val = m_deque.back();
    m_deque.clear();
    return val;
}

///DANGEROUS
template&lt;typename T&gt;
T&amp; BasicConcurrentQueue&lt;T&gt;::operator[](std::size_t idx) {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque[idx];
}

template&lt;typename T&gt;
</t>
<t tx="leo.20220407205632.86">void BasicConcurrentQueue&lt;T&gt;::pop_back() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    m_deque.pop_back();
}

template&lt;typename T&gt;
</t>
<t tx="leo.20220407205632.87">void BasicConcurrentQueue&lt;T&gt;::clear() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.clear();
    lk.unlock();
}

template&lt;typename T&gt;
</t>
<t tx="leo.20220407205632.88">bool BasicConcurrentQueue&lt;T&gt;::empty() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    bool empty = m_deque.empty();
    lk.unlock();
    return empty;
}

template&lt;typename T&gt;
</t>
<t tx="leo.20220407205632.89">int BasicConcurrentQueue&lt;T&gt;::size() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    size_t sz = m_deque.size();
    lk.unlock();
    return sz;
}

#endif //V_REPEXT_BASIC_CONCURRENT_QUEUE
</t>
<t tx="leo.20220407205632.9">int CStackObject::getObjectType() const
{
    return(_objectType);
}

CStackObject* CStackObject::copyYourself()
{
    return(NULL);
}

</t>
<t tx="leo.20220407205632.90">@path ./v-rep_plugin/include/
#ifndef V_REPEXT_PAIR_CONCURRENT_QUEUE
#define V_REPEXT_PAIR_CONCURRENT_QUEUE

#include &lt;deque&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;
#include &lt;utility&gt;
#include &lt;condition_variable&gt;

/*!
 * \brief The PairConcurrentQueue class
 * Consider template if required other vector types
 */
template &lt;typename T1, typename T2&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.91">class PairConcurrentQueue {
public:
    PairConcurrentQueue();

    bool empty();
    int size();
    void clear();
    void push_front(const std::pair&lt;T1, T2&gt; &amp;t);
    void push_back(const std::pair&lt;T1, T2&gt; &amp;t);
    void push_front(const T1 t1, const T2 t2);
    void push_back(const T1 t1, const T2 t2);
    std::pair&lt;T1, T2&gt; back();
    std::pair&lt;T1, T2&gt; at(size_t index);
    void pop_back();

private:
    std::deque&lt; std::pair&lt;T1, T2&gt; &gt; m_deque;
    std::mutex m_mutex;
    std::condition_variable m_cond;
};

template &lt;typename T1, typename T2&gt;
PairConcurrentQueue&lt;T1, T2&gt;::PairConcurrentQueue()
{}

template &lt;typename T1, typename T2&gt;
</t>
<t tx="leo.20220407205632.92">bool PairConcurrentQueue&lt;T1, T2&gt;::empty()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    bool empty = m_deque.empty();
    lk.unlock();
    return empty;
}

template &lt;typename T1, typename T2&gt;
</t>
<t tx="leo.20220407205632.93">int PairConcurrentQueue&lt;T1, T2&gt;::size()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    size_t sz = m_deque.size();
    lk.unlock();
    return sz;
}

template &lt;typename T1, typename T2&gt;
</t>
<t tx="leo.20220407205632.94">void PairConcurrentQueue&lt;T1, T2&gt;::clear()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.clear();
    lk.unlock();
}

template &lt;typename T1, typename T2&gt;
</t>
<t tx="leo.20220407205632.95">void PairConcurrentQueue&lt;T1, T2&gt;::push_front(const std::pair&lt;T1, T2&gt; &amp;t)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_front(t);
    lk.unlock();
    m_cond.notify_one();
}

template &lt;typename T1, typename T2&gt;
</t>
<t tx="leo.20220407205632.96">void PairConcurrentQueue&lt;T1, T2&gt;::push_back(const std::pair&lt;T1, T2&gt; &amp;t)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_back(t);
    lk.unlock();
    m_cond.notify_one();
}

template&lt;typename T1, typename T2&gt;
inline void PairConcurrentQueue&lt;T1, T2&gt;::push_front(const T1 t1, const T2 t2)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.emplace_front(t1, t2);
    lk.unlock();
    m_cond.notify_one();
}

template&lt;typename T1, typename T2&gt;
inline void PairConcurrentQueue&lt;T1, T2&gt;::push_back(const T1 t1, const T2 t2)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.emplace_back(t1, t2);
    lk.unlock();
    m_cond.notify_one();
}

template &lt;typename T1, typename T2&gt;
std::pair&lt;T1, T2&gt; PairConcurrentQueue&lt;T1, T2&gt;::back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.back();
}

template &lt;typename T1, typename T2&gt;
std::pair&lt;T1, T2&gt; PairConcurrentQueue&lt;T1, T2&gt;::at(size_t index)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.at(index);	
}

template &lt;typename T1, typename T2&gt;
</t>
<t tx="leo.20220407205632.97">void PairConcurrentQueue&lt;T1, T2&gt;::pop_back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    m_deque.pop_back();
}



#endif //V_REPEXT_PAIR_CONCURRENT_QUEUE
</t>
<t tx="leo.20220407205632.98">@path ./v-rep_plugin/include/
#ifndef V_REPEXT_STRING_CONCURRENT_QUEUE
#define V_REPEXT_STRING_CONCURRENT_QUEUE

#include &lt;deque&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;string&gt;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205632.99">class StringConcurrentQueue {
public:
    StringConcurrentQueue();

    int size();
    bool empty();
    void clear();
    void push_front(const std::string &amp;t);
    void push_back(const std::string &amp;t);
    
    std::string&amp; back();
    void pop_back();

    std::string consume_back();

private:
    std::deque&lt;std::string&gt; m_deque;
    std::mutex m_mutex;
    std::condition_variable m_cond;

};

#endif //V_REPEXT_STRING_CONCURRENT_QUEUE
</t>
<t tx="leo.20220407205633.1"></t>
<t tx="leo.20220407205633.10">    static std::FILE *stream()
    {
        return stdout;
    }
#ifdef _WIN32
</t>
<t tx="leo.20220407205633.100">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 5;
    scoped_pad p(field_size, padinfo_, dest);

    fmt_helper::pad2(tm_time.tm_hour, dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_min, dest);
}
</t>
<t tx="leo.20220407205633.101">class T_formatter final : public flag_formatter
{
public:
    explicit T_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// ISO 8601 offset from UTC in timezone (+-HH:MM)
</t>
<t tx="leo.20220407205633.102">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 8;
    scoped_pad p(field_size, padinfo_, dest);

    fmt_helper::pad2(tm_time.tm_hour, dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_min, dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_sec, dest);
}
</t>
<t tx="leo.20220407205633.103">class z_formatter final : public flag_formatter
{
public:
    explicit z_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    const std::chrono::seconds cache_refresh = std::chrono::seconds(5);

    z_formatter() = default;
    z_formatter(const z_formatter &amp;) = delete;
    z_formatter &amp;operator=(const z_formatter &amp;) = delete;

    @others
};

// Thread id
</t>
<t tx="leo.20220407205633.104">    void format(const details::log_msg &amp;msg, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
    {
        const size_t field_size = 6;
        scoped_pad p(field_size, padinfo_, dest);

#ifdef _WIN32
        int total_minutes = get_cached_offset(msg, tm_time);
#else
        // No need to chache under gcc,
        // it is very fast (already stored in tm.tm_gmtoff)
        (void)(msg);
        int total_minutes = os::utc_minutes_offset(tm_time);
#endif
        bool is_negative = total_minutes &lt; 0;
        if (is_negative)
        {
            total_minutes = -total_minutes;
            dest.push_back('-');
        }
        else
        {
            dest.push_back('+');
        }

        fmt_helper::pad2(total_minutes / 60, dest); // hours
        dest.push_back(':');
        fmt_helper::pad2(total_minutes % 60, dest); // minutes
    }

private:
    log_clock::time_point last_update_{std::chrono::seconds(0)};
#ifdef _WIN32
    int offset_minutes_{0};

</t>
<t tx="leo.20220407205633.105">    int get_cached_offset(const log_msg &amp;msg, const std::tm &amp;tm_time)
    {
        if (msg.time - last_update_ &gt;= cache_refresh)
        {
            offset_minutes_ = os::utc_minutes_offset(tm_time);
            last_update_ = msg.time;
        }
        return offset_minutes_;
    }
#endif
</t>
<t tx="leo.20220407205633.106">class t_formatter final : public flag_formatter
{
public:
    explicit t_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// Current pid
</t>
<t tx="leo.20220407205633.107">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    if (padinfo_.enabled())
    {
        const auto field_size = fmt_helper::count_digits(msg.thread_id);
        scoped_pad p(field_size, padinfo_, dest);
        fmt_helper::append_int(msg.thread_id, dest);
    }
    else
    {
        fmt_helper::append_int(msg.thread_id, dest);
    }
}
</t>
<t tx="leo.20220407205633.108">class pid_formatter final : public flag_formatter
{
public:
    explicit pid_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// message counter formatter
</t>
<t tx="leo.20220407205633.109">void format(const details::log_msg &amp;, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    const auto pid = static_cast&lt;uint32_t&gt;(details::os::pid());
    if (padinfo_.enabled())
    {
        const size_t field_size = fmt::internal::count_digits(pid);
        scoped_pad p(field_size, padinfo_, dest);
        fmt_helper::append_int(pid, dest);
    }
    else
    {
        fmt_helper::append_int(pid, dest);
    }
}
</t>
<t tx="leo.20220407205633.11">    static HANDLE handle()
    {
        return ::GetStdHandle(STD_OUTPUT_HANDLE);
    }
#endif
};

struct console_stderr
{
</t>
<t tx="leo.20220407205633.110">class i_formatter final : public flag_formatter
{
public:
    explicit i_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

</t>
<t tx="leo.20220407205633.111">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 6;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad6(msg.msg_id, dest);
}
</t>
<t tx="leo.20220407205633.112">class v_formatter final : public flag_formatter
{
public:
    explicit v_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

</t>
<t tx="leo.20220407205633.113">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    if (padinfo_.enabled())
    {
        scoped_pad p(msg.payload, padinfo_, dest);
        fmt_helper::append_string_view(msg.payload, dest);
    }
    else
    {
        fmt_helper::append_string_view(msg.payload, dest);
    }
}
</t>
<t tx="leo.20220407205633.114">class ch_formatter final : public flag_formatter
{
public:
    explicit ch_formatter(char ch)
        : ch_(ch)
    {
    }

    @others
};

// aggregate user chars to display as is
</t>
<t tx="leo.20220407205633.115">    void format(const details::log_msg &amp;, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
    {
        const size_t field_size = 1;
        scoped_pad p(field_size, padinfo_, dest);
        dest.push_back(ch_);
    }

private:
    char ch_;
</t>
<t tx="leo.20220407205633.116">class aggregate_formatter final : public flag_formatter
{
public:
    aggregate_formatter() = default;

    @others
};

// mark the color range. expect it to be in the form of "%^colored text%$"
</t>
<t tx="leo.20220407205633.117">void add_ch(char ch)
{
    str_ += ch;
}
</t>
<t tx="leo.20220407205633.118">    void format(const details::log_msg &amp;, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
    {
        fmt_helper::append_string_view(str_, dest);
    }

private:
    std::string str_;
</t>
<t tx="leo.20220407205633.119">class color_start_formatter final : public flag_formatter
{
public:
    explicit color_start_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};
</t>
<t tx="leo.20220407205633.12">    static std::FILE *stream()
    {
        return stderr;
    }
#ifdef _WIN32
</t>
<t tx="leo.20220407205633.120">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    msg.color_range_start = dest.size();
}
</t>
<t tx="leo.20220407205633.121">class color_stop_formatter final : public flag_formatter
{
public:
    explicit color_stop_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// print source location
</t>
<t tx="leo.20220407205633.122">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    msg.color_range_end = dest.size();
}
</t>
<t tx="leo.20220407205633.123">class source_location_formatter final : public flag_formatter
{
public:
    explicit source_location_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};
// print source filename
</t>
<t tx="leo.20220407205633.124">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    if (msg.source.empty())
    {
        return;
    }
    if (padinfo_.enabled())
    {
        const auto text_size = std::char_traits&lt;char&gt;::length(msg.source.filename) + fmt_helper::count_digits(msg.source.line) + 1;
        scoped_pad p(text_size, padinfo_, dest);
        fmt_helper::append_string_view(msg.source.filename, dest);
        dest.push_back(':');
        fmt_helper::append_int(msg.source.line, dest);
    }
    else
    {
        fmt_helper::append_string_view(msg.source.filename, dest);
        dest.push_back(':');
        fmt_helper::append_int(msg.source.line, dest);
    }
}
</t>
<t tx="leo.20220407205633.125">class source_filename_formatter final : public flag_formatter
{
public:
    explicit source_filename_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

</t>
<t tx="leo.20220407205633.126">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    if (msg.source.empty())
    {
        return;
    }
    scoped_pad p(msg.source.filename, padinfo_, dest);
    fmt_helper::append_string_view(msg.source.filename, dest);
}
</t>
<t tx="leo.20220407205633.127">class source_linenum_formatter final : public flag_formatter
{
public:
    explicit source_linenum_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// Full info formatter
// pattern: [%Y-%m-%d %H:%M:%S.%e] [%n] [%l] %v
</t>
<t tx="leo.20220407205633.128">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    if (msg.source.empty())
    {
        return;
    }
    if (padinfo_.enabled())
    {
        const size_t field_size = fmt::internal::count_digits(msg.source.line);
        scoped_pad p(field_size, padinfo_, dest);
        fmt_helper::append_int(msg.source.line, dest);
    }
    else
    {
        fmt_helper::append_int(msg.source.line, dest);
    }
}
</t>
<t tx="leo.20220407205633.129">class full_formatter final : public flag_formatter
{
public:
    explicit full_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

} // namespace details

</t>
<t tx="leo.20220407205633.13">    static HANDLE handle()
    {
        return ::GetStdHandle(STD_ERROR_HANDLE);
    }
#endif
};

struct console_mutex
{
    using mutex_t = std::mutex;
</t>
<t tx="leo.20220407205633.130">    void format(const details::log_msg &amp;msg, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
    {
        using std::chrono::duration_cast;
        using std::chrono::milliseconds;
        using std::chrono::seconds;

#ifndef SPDLOG_NO_DATETIME

        // cache the date/time part for the next second.
        auto duration = msg.time.time_since_epoch();
        auto secs = duration_cast&lt;seconds&gt;(duration);

        if (cache_timestamp_ != secs || cached_datetime_.size() == 0)
        {
            cached_datetime_.clear();
            cached_datetime_.push_back('[');
            fmt_helper::append_int(tm_time.tm_year + 1900, cached_datetime_);
            cached_datetime_.push_back('-');

            fmt_helper::pad2(tm_time.tm_mon + 1, cached_datetime_);
            cached_datetime_.push_back('-');

            fmt_helper::pad2(tm_time.tm_mday, cached_datetime_);
            cached_datetime_.push_back(' ');

            fmt_helper::pad2(tm_time.tm_hour, cached_datetime_);
            cached_datetime_.push_back(':');

            fmt_helper::pad2(tm_time.tm_min, cached_datetime_);
            cached_datetime_.push_back(':');

            fmt_helper::pad2(tm_time.tm_sec, cached_datetime_);
            cached_datetime_.push_back('.');

            cache_timestamp_ = secs;
        }
        fmt_helper::append_buf(cached_datetime_, dest);

        auto millis = fmt_helper::time_fraction&lt;milliseconds&gt;(msg.time);
        fmt_helper::pad3(static_cast&lt;uint32_t&gt;(millis.count()), dest);
        dest.push_back(']');
        dest.push_back(' ');

#else // no datetime needed
        (void)tm_time;
#endif

#ifndef SPDLOG_NO_NAME
        if (!msg.logger_name-&gt;empty())
        {
            dest.push_back('[');
            // fmt_helper::append_str(*msg.logger_name, dest);
            fmt_helper::append_string_view(*msg.logger_name, dest);
            dest.push_back(']');
            dest.push_back(' ');
        }
#endif

        dest.push_back('[');
        // wrap the level name with color
        msg.color_range_start = dest.size();
        // fmt_helper::append_string_view(level::to_c_str(msg.level), dest);
        fmt_helper::append_string_view(level::to_string_view(msg.level), dest);
        msg.color_range_end = dest.size();
        dest.push_back(']');
        dest.push_back(' ');

        // add source location if present
        if (!msg.source.empty())
        {
            dest.push_back('[');
            fmt_helper::append_string_view(msg.source.filename, dest);
            dest.push_back(':');
            fmt_helper::append_int(msg.source.line, dest);
            dest.push_back(']');
            dest.push_back(' ');
        }
        // fmt_helper::append_string_view(msg.msg(), dest);
        fmt_helper::append_string_view(msg.payload, dest);
    }

private:
    std::chrono::seconds cache_timestamp_{0};
    fmt::basic_memory_buffer&lt;char, 128&gt; cached_datetime_;
</t>
<t tx="leo.20220407205633.131">class pattern_formatter final : public formatter
{
public:
    explicit pattern_formatter(
        std::string pattern, pattern_time_type time_type = pattern_time_type::local, std::string eol = spdlog::details::os::default_eol)
        : pattern_(std::move(pattern))
        , eol_(std::move(eol))
        , pattern_time_type_(time_type)
        , last_log_secs_(0)
    {
        std::memset(&amp;cached_tm_, 0, sizeof(cached_tm_));
        compile_pattern_(pattern_);
    }

    // use by default full formatter for if pattern is not given
    explicit pattern_formatter(pattern_time_type time_type = pattern_time_type::local, std::string eol = spdlog::details::os::default_eol)
        : pattern_("%+")
        , eol_(std::move(eol))
        , pattern_time_type_(time_type)
        , last_log_secs_(0)
    {
        std::memset(&amp;cached_tm_, 0, sizeof(cached_tm_));
        formatters_.push_back(details::make_unique&lt;details::full_formatter&gt;(details::padding_info{}));
    }

    pattern_formatter(const pattern_formatter &amp;other) = delete;
    pattern_formatter &amp;operator=(const pattern_formatter &amp;other) = delete;

    std::unique_ptr&lt;formatter&gt; clone() const override
    {
        return details::make_unique&lt;pattern_formatter&gt;(pattern_, pattern_time_type_, eol_);
    }

    @others
};
} // namespace spdlog
</t>
<t tx="leo.20220407205633.132">    void format(const details::log_msg &amp;msg, fmt::memory_buffer &amp;dest) override
    {
#ifndef SPDLOG_NO_DATETIME
        auto secs = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(msg.time.time_since_epoch());
        if (secs != last_log_secs_)
        {
            cached_tm_ = get_time_(msg);
            last_log_secs_ = secs;
        }
#endif
        for (auto &amp;f : formatters_)
        {
            f-&gt;format(msg, cached_tm_, dest);
        }
        // write eol
        details::fmt_helper::append_string_view(eol_, dest);
    }

private:
    std::string pattern_;
    std::string eol_;
    pattern_time_type pattern_time_type_;
    std::tm cached_tm_;
    std::chrono::seconds last_log_secs_;

    std::vector&lt;std::unique_ptr&lt;details::flag_formatter&gt;&gt; formatters_;

    std::tm get_time_(const details::log_msg &amp;msg)
    {
        if (pattern_time_type_ == pattern_time_type::local)
        {
            return details::os::localtime(log_clock::to_time_t(msg.time));
        }
        return details::os::gmtime(log_clock::to_time_t(msg.time));
    }

</t>
<t tx="leo.20220407205633.133">    void handle_flag_(char flag, details::padding_info padding)
    {
        switch (flag)
        {

        case ('+'): // default formatter
            formatters_.push_back(details::make_unique&lt;details::full_formatter&gt;(padding));
            break;

        case 'n': // logger name
            formatters_.push_back(details::make_unique&lt;details::name_formatter&gt;(padding));
            break;

        case 'l': // level
            formatters_.push_back(details::make_unique&lt;details::level_formatter&gt;(padding));
            break;

        case 'L': // short level
            formatters_.push_back(details::make_unique&lt;details::short_level_formatter&gt;(padding));
            break;

        case ('t'): // thread id
            formatters_.push_back(details::make_unique&lt;details::t_formatter&gt;(padding));
            break;

        case ('v'): // the message text
            formatters_.push_back(details::make_unique&lt;details::v_formatter&gt;(padding));
            break;

        case ('a'): // weekday
            formatters_.push_back(details::make_unique&lt;details::a_formatter&gt;(padding));
            break;

        case ('A'): // short weekday
            formatters_.push_back(details::make_unique&lt;details::A_formatter&gt;(padding));
            break;

        case ('b'):
        case ('h'): // month
            formatters_.push_back(details::make_unique&lt;details::b_formatter&gt;(padding));
            break;

        case ('B'): // short month
            formatters_.push_back(details::make_unique&lt;details::B_formatter&gt;(padding));
            break;

        case ('c'): // datetime
            formatters_.push_back(details::make_unique&lt;details::c_formatter&gt;(padding));
            break;

        case ('C'): // year 2 digits
            formatters_.push_back(details::make_unique&lt;details::C_formatter&gt;(padding));
            break;

        case ('Y'): // year 4 digits
            formatters_.push_back(details::make_unique&lt;details::Y_formatter&gt;(padding));
            break;

        case ('D'):
        case ('x'): // datetime MM/DD/YY
            formatters_.push_back(details::make_unique&lt;details::D_formatter&gt;(padding));
            break;

        case ('m'): // month 1-12
            formatters_.push_back(details::make_unique&lt;details::m_formatter&gt;(padding));
            break;

        case ('d'): // day of month 1-31
            formatters_.push_back(details::make_unique&lt;details::d_formatter&gt;(padding));
            break;

        case ('H'): // hours 24
            formatters_.push_back(details::make_unique&lt;details::H_formatter&gt;(padding));
            break;

        case ('I'): // hours 12
            formatters_.push_back(details::make_unique&lt;details::I_formatter&gt;(padding));
            break;

        case ('M'): // minutes
            formatters_.push_back(details::make_unique&lt;details::M_formatter&gt;(padding));
            break;

        case ('S'): // seconds
            formatters_.push_back(details::make_unique&lt;details::S_formatter&gt;(padding));
            break;

        case ('e'): // milliseconds
            formatters_.push_back(details::make_unique&lt;details::e_formatter&gt;(padding));
            break;

        case ('f'): // microseconds
            formatters_.push_back(details::make_unique&lt;details::f_formatter&gt;(padding));
            break;

        case ('F'): // nanoseconds
            formatters_.push_back(details::make_unique&lt;details::F_formatter&gt;(padding));
            break;

        case ('E'): // seconds since epoch
            formatters_.push_back(details::make_unique&lt;details::E_formatter&gt;(padding));
            break;

        case ('p'): // am/pm
            formatters_.push_back(details::make_unique&lt;details::p_formatter&gt;(padding));
            break;

        case ('r'): // 12 hour clock 02:55:02 pm
            formatters_.push_back(details::make_unique&lt;details::r_formatter&gt;(padding));
            break;

        case ('R'): // 24-hour HH:MM time
            formatters_.push_back(details::make_unique&lt;details::R_formatter&gt;(padding));
            break;

        case ('T'):
        case ('X'): // ISO 8601 time format (HH:MM:SS)
            formatters_.push_back(details::make_unique&lt;details::T_formatter&gt;(padding));
            break;

        case ('z'): // timezone
            formatters_.push_back(details::make_unique&lt;details::z_formatter&gt;(padding));
            break;

        case ('P'): // pid
            formatters_.push_back(details::make_unique&lt;details::pid_formatter&gt;(padding));
            break;

#ifdef SPDLOG_ENABLE_MESSAGE_COUNTER
        case ('i'):
            formatters_.push_back(details::make_unique&lt;details::i_formatter&gt;(padding));
            break;
#endif
        case ('^'): // color range start
            formatters_.push_back(details::make_unique&lt;details::color_start_formatter&gt;(padding));
            break;

        case ('$'): // color range end
            formatters_.push_back(details::make_unique&lt;details::color_stop_formatter&gt;(padding));
            break;

        case ('@'): // source location (filename:filenumber)
            formatters_.push_back(details::make_unique&lt;details::source_location_formatter&gt;(padding));
            break;

        case ('s'): // source filename
            formatters_.push_back(details::make_unique&lt;details::source_filename_formatter&gt;(padding));
            break;

        case ('#'): // source line number
            formatters_.push_back(details::make_unique&lt;details::source_linenum_formatter&gt;(padding));
            break;

        case ('%'): // % char
            formatters_.push_back(details::make_unique&lt;details::ch_formatter&gt;('%'));
            break;

        default: // Unknown flag appears as is
            auto unknown_flag = details::make_unique&lt;details::aggregate_formatter&gt;();
            unknown_flag-&gt;add_ch('%');
            unknown_flag-&gt;add_ch(flag);
            formatters_.push_back((std::move(unknown_flag)));
            break;
        }
    }

    // Extract given pad spec (e.g. %8X)
    // Advance the given it pass the end of the padding spec found (if any)
    // Return padding.
    details::padding_info handle_padspec_(std::string::const_iterator &amp;it, std::string::const_iterator end)
    {
        using details::padding_info;
        using details::scoped_pad;
        const size_t max_width = 128;
        if (it == end)
        {
            return padding_info{};
        }

        padding_info::pad_side side;
        switch (*it)
        {
        case '-':
            side = padding_info::right;
            ++it;
            break;
        case '=':
            side = padding_info::center;
            ++it;
            break;
        default:
            side = details::padding_info::left;
            break;
        }

        if (it == end || !std::isdigit(static_cast&lt;unsigned char&gt;(*it)))
        {
            return padding_info{0, side};
        }

        auto width = static_cast&lt;size_t&gt;(*it - '0');
        for (++it; it != end &amp;&amp; std::isdigit(static_cast&lt;unsigned char&gt;(*it)); ++it)
        {
            auto digit = static_cast&lt;size_t&gt;(*it - '0');
            width = width * 10 + digit;
        }
        return details::padding_info{std::min&lt;size_t&gt;(width, max_width), side};
    }

</t>
<t tx="leo.20220407205633.134">void compile_pattern_(const std::string &amp;pattern)
{
    auto end = pattern.end();
    std::unique_ptr&lt;details::aggregate_formatter&gt; user_chars;
    formatters_.clear();
    for (auto it = pattern.begin(); it != end; ++it)
    {
        if (*it == '%')
        {
            if (user_chars) // append user chars found so far
            {
                formatters_.push_back(std::move(user_chars));
            }

            auto padding = handle_padspec_(++it, end);

            if (it != end)
            {
                handle_flag_(*it, padding);
            }
            else
            {
                break;
            }
        }
        else // chars not following the % sign should be displayed as is
        {
            if (!user_chars)
            {
                user_chars = details::make_unique&lt;details::aggregate_formatter&gt;();
            }
            user_chars-&gt;add_ch(*it);
        }
    }
    if (user_chars) // append raw chars found so far
    {
        formatters_.push_back(std::move(user_chars));
    }
}
</t>
<t tx="leo.20220407205633.135">@path ./v-rep_plugin/spdlog/details/

//
// Copyright(c) 2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

// periodic worker thread - periodically executes the given callback function.
//
// RAII over the owned thread:
//    creates the thread on construction.
//    stops and joins the thread on destruction (if the thread is executing a callback, wait for it to finish first).

#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;functional&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
namespace spdlog {
namespace details {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.136">class periodic_worker
{
public:
    periodic_worker(const std::function&lt;void()&gt; &amp;callback_fun, std::chrono::seconds interval)
    {
        active_ = (interval &gt; std::chrono::seconds::zero());
        if (!active_)
        {
            return;
        }

        worker_thread_ = std::thread([this, callback_fun, interval]() {
            for (;;)
            {
                std::unique_lock&lt;std::mutex&gt; lock(this-&gt;mutex_);
                if (this-&gt;cv_.wait_for(lock, interval, [this] { return !this-&gt;active_; }))
                {
                    return; // active_ == false, so exit this thread
                }
                callback_fun();
            }
        });
    }

    periodic_worker(const periodic_worker &amp;) = delete;
    periodic_worker &amp;operator=(const periodic_worker &amp;) = delete;

    // stop the worker thread and join it
    ~periodic_worker()
    {
        if (worker_thread_.joinable())
        {
            {
                std::lock_guard&lt;std::mutex&gt; lock(mutex_);
                active_ = false;
            }
            cv_.notify_one();
            worker_thread_.join();
        }
    }

private:
    bool active_;
    std::thread worker_thread_;
    std::mutex mutex_;
    std::condition_variable cv_;
};
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.137">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

// Loggers registy of unique name-&gt;logger pointer
// An attempt to create a logger with an already existing name will be ignored
// If user requests a non existing logger, nullptr will be returned
// This class is thread safe

#include "spdlog/common.h"
#include "spdlog/details/periodic_worker.h"
#include "spdlog/logger.h"

#ifndef SPDLOG_DISABLE_DEFAULT_LOGGER
// support for the default stdout color logger
#ifdef _WIN32
#include "spdlog/sinks/wincolor_sink.h"
#else
#include "spdlog/sinks/ansicolor_sink.h"
#endif
#endif // SPDLOG_DISABLE_DEFAULT_LOGGER

#include &lt;chrono&gt;
#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

namespace spdlog {
namespace details {
class thread_pool;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.138">class registry
{
public:
    registry(const registry &amp;) = delete;
    registry &amp;operator=(const registry &amp;) = delete;

    @others
};

} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.139">void register_logger(std::shared_ptr&lt;logger&gt; new_logger)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    register_logger_(std::move(new_logger));
}

</t>
<t tx="leo.20220407205633.14">    static mutex_t &amp;mutex()
    {
        static mutex_t s_mutex;
        return s_mutex;
    }
};

struct console_nullmutex
{
    using mutex_t = null_mutex;
</t>
<t tx="leo.20220407205633.140">void initialize_logger(std::shared_ptr&lt;logger&gt; new_logger)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    new_logger-&gt;set_formatter(formatter_-&gt;clone());

    if (err_handler_)
    {
        new_logger-&gt;set_error_handler(err_handler_);
    }

    new_logger-&gt;set_level(level_);
    new_logger-&gt;flush_on(flush_level_);

    if (automatic_registration_)
    {
        register_logger_(std::move(new_logger));
    }
}

std::shared_ptr&lt;logger&gt; get(const std::string &amp;logger_name)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    auto found = loggers_.find(logger_name);
    return found == loggers_.end() ? nullptr : found-&gt;second;
}

std::shared_ptr&lt;logger&gt; default_logger()
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    return default_logger_;
}

// Return raw ptr to the default logger.
// To be used directly by the spdlog default api (e.g. spdlog::info)
// This make the default API faster, but cannot be used concurrently with set_default_logger().
// e.g do not call set_default_logger() from one thread while calling spdlog::info() from another.
logger *get_default_raw()
{
    return default_logger_.get();
}

// set default logger.
// default logger is stored in default_logger_ (for faster retrieval) and in the loggers_ map.
</t>
<t tx="leo.20220407205633.141">void set_default_logger(std::shared_ptr&lt;logger&gt; new_default_logger)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    // remove previous default logger from the map
    if (default_logger_ != nullptr)
    {
        loggers_.erase(default_logger_-&gt;name());
    }
    if (new_default_logger != nullptr)
    {
        loggers_[new_default_logger-&gt;name()] = new_default_logger;
    }
    default_logger_ = std::move(new_default_logger);
}

</t>
<t tx="leo.20220407205633.142">void set_tp(std::shared_ptr&lt;thread_pool&gt; tp)
{
    std::lock_guard&lt;std::recursive_mutex&gt; lock(tp_mutex_);
    tp_ = std::move(tp);
}

std::shared_ptr&lt;thread_pool&gt; get_tp()
{
    std::lock_guard&lt;std::recursive_mutex&gt; lock(tp_mutex_);
    return tp_;
}

// Set global formatter. Each sink in each logger will get a clone of this object
</t>
<t tx="leo.20220407205633.143">void set_formatter(std::unique_ptr&lt;formatter&gt; formatter)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    formatter_ = std::move(formatter);
    for (auto &amp;l : loggers_)
    {
        l.second-&gt;set_formatter(formatter_-&gt;clone());
    }
}

</t>
<t tx="leo.20220407205633.144">void set_level(level::level_enum log_level)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    for (auto &amp;l : loggers_)
    {
        l.second-&gt;set_level(log_level);
    }
    level_ = log_level;
}

</t>
<t tx="leo.20220407205633.145">void flush_on(level::level_enum log_level)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    for (auto &amp;l : loggers_)
    {
        l.second-&gt;flush_on(log_level);
    }
    flush_level_ = log_level;
}

</t>
<t tx="leo.20220407205633.146">void flush_every(std::chrono::seconds interval)
{
    std::lock_guard&lt;std::mutex&gt; lock(flusher_mutex_);
    std::function&lt;void()&gt; clbk = std::bind(&amp;registry::flush_all, this);
    periodic_flusher_ = details::make_unique&lt;periodic_worker&gt;(clbk, interval);
}

</t>
<t tx="leo.20220407205633.147">void set_error_handler(log_err_handler handler)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    for (auto &amp;l : loggers_)
    {
        l.second-&gt;set_error_handler(handler);
    }
    err_handler_ = handler;
}

</t>
<t tx="leo.20220407205633.148">void apply_all(const std::function&lt;void(const std::shared_ptr&lt;logger&gt;)&gt; &amp;fun)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    for (auto &amp;l : loggers_)
    {
        fun(l.second);
    }
}

</t>
<t tx="leo.20220407205633.149">void flush_all()
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    for (auto &amp;l : loggers_)
    {
        l.second-&gt;flush();
    }
}

</t>
<t tx="leo.20220407205633.15">    static mutex_t &amp;mutex()
    {
        static mutex_t s_mutex;
        return s_mutex;
    }
};
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.150">void drop(const std::string &amp;logger_name)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    loggers_.erase(logger_name);
    if (default_logger_ &amp;&amp; default_logger_-&gt;name() == logger_name)
    {
        default_logger_.reset();
    }
}

</t>
<t tx="leo.20220407205633.151">void drop_all()
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    loggers_.clear();
    default_logger_.reset();
}

// clean all resources and threads started by the registry
</t>
<t tx="leo.20220407205633.152">void shutdown()
{
    {
        std::lock_guard&lt;std::mutex&gt; lock(flusher_mutex_);
        periodic_flusher_.reset();
    }

    drop_all();

    {
        std::lock_guard&lt;std::recursive_mutex&gt; lock(tp_mutex_);
        tp_.reset();
    }
}

std::recursive_mutex &amp;tp_mutex()
{
    return tp_mutex_;
}

</t>
<t tx="leo.20220407205633.153">void set_automatic_registration(bool automatic_regsistration)
{
    std::lock_guard&lt;std::mutex&gt; lock(logger_map_mutex_);
    automatic_registration_ = automatic_regsistration;
}

</t>
<t tx="leo.20220407205633.154">    static registry &amp;instance()
    {
        static registry s_instance;
        return s_instance;
    }

private:
    registry()
        : formatter_(new pattern_formatter())
    {

#ifndef SPDLOG_DISABLE_DEFAULT_LOGGER
        // create default logger (ansicolor_stdout_sink_mt or wincolor_stdout_sink_mt in windows).
#ifdef _WIN32
        auto color_sink = std::make_shared&lt;sinks::wincolor_stdout_sink_mt&gt;();
#else
        auto color_sink = std::make_shared&lt;sinks::ansicolor_stdout_sink_mt&gt;();
#endif

        const char *default_logger_name = "";
        default_logger_ = std::make_shared&lt;spdlog::logger&gt;(default_logger_name, std::move(color_sink));
        loggers_[default_logger_name] = default_logger_;

#endif // SPDLOG_DISABLE_DEFAULT_LOGGER
    }

    ~registry() = default;

</t>
<t tx="leo.20220407205633.155">void throw_if_exists_(const std::string &amp;logger_name)
{
    if (loggers_.find(logger_name) != loggers_.end())
    {
        throw spdlog_ex("logger with name '" + logger_name + "' already exists");
    }
}

</t>
<t tx="leo.20220407205633.156">void register_logger_(std::shared_ptr&lt;logger&gt; new_logger)
{
    auto logger_name = new_logger-&gt;name();
    throw_if_exists_(logger_name);
    loggers_[logger_name] = std::move(new_logger);
}

std::mutex logger_map_mutex_, flusher_mutex_;
std::recursive_mutex tp_mutex_;
std::unordered_map&lt;std::string, std::shared_ptr&lt;logger&gt;&gt; loggers_;
std::unique_ptr&lt;formatter&gt; formatter_;
level::level_enum level_ = spdlog::logger::default_level();
level::level_enum flush_level_ = level::off;
log_err_handler err_handler_;
std::shared_ptr&lt;thread_pool&gt; tp_;
std::unique_ptr&lt;periodic_worker&gt; periodic_flusher_;
std::shared_ptr&lt;logger&gt; default_logger_;
bool automatic_registration_ = true;
</t>
<t tx="leo.20220407205633.157">@path ./v-rep_plugin/spdlog/details/
#pragma once

#include "spdlog/details/fmt_helper.h"
#include "spdlog/details/log_msg.h"
#include "spdlog/details/mpmc_blocking_q.h"
#include "spdlog/details/os.h"

#include &lt;chrono&gt;
#include &lt;memory&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

namespace spdlog {
namespace details {

using async_logger_ptr = std::shared_ptr&lt;spdlog::async_logger&gt;;

enum class async_msg_type
{
    log,
    flush,
    terminate
};

// Async msg to move to/from the queue
// Movable only. should never be copied
struct async_msg
{
    async_msg_type msg_type;
    level::level_enum level;
    log_clock::time_point time;
    size_t thread_id;
    fmt::basic_memory_buffer&lt;char, 176&gt; raw;

    size_t msg_id;
    source_loc source;
    async_logger_ptr worker_ptr;

    async_msg() = default;
    ~async_msg() = default;

    // should only be moved in or out of the queue..
    async_msg(const async_msg &amp;) = delete;

// support for vs2013 move
#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1800
    async_msg(async_msg &amp;&amp;other) SPDLOG_NOEXCEPT : msg_type(other.msg_type),
                                                   level(other.level),
                                                   time(other.time),
                                                   thread_id(other.thread_id),
                                                   raw(move(other.raw)),
                                                   msg_id(other.msg_id),
                                                   source(other.source),
                                                   worker_ptr(std::move(other.worker_ptr))
    {
    }

    async_msg &amp;operator=(async_msg &amp;&amp;other) SPDLOG_NOEXCEPT
    {
        msg_type = other.msg_type;
        level = other.level;
        time = other.time;
        thread_id = other.thread_id;
        raw = std::move(other.raw);
        msg_id = other.msg_id;
        source = other.source;
        worker_ptr = std::move(other.worker_ptr);
        return *this;
    }
#else // (_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1800
    async_msg(async_msg &amp;&amp;) = default;
    async_msg &amp;operator=(async_msg &amp;&amp;) = default;
#endif

    // construct from log_msg with given type
    async_msg(async_logger_ptr &amp;&amp;worker, async_msg_type the_type, details::log_msg &amp;m)
        : msg_type(the_type)
        , level(m.level)
        , time(m.time)
        , thread_id(m.thread_id)
        , msg_id(m.msg_id)
        , source(m.source)
        , worker_ptr(std::move(worker))
    {
        fmt_helper::append_string_view(m.payload, raw);
    }

    async_msg(async_logger_ptr &amp;&amp;worker, async_msg_type the_type)
        : msg_type(the_type)
        , level(level::off)
        , time()
        , thread_id(0)
        , msg_id(0)
        , source()
        , worker_ptr(std::move(worker))
    {
    }

    explicit async_msg(async_msg_type the_type)
        : async_msg(nullptr, the_type)
    {
    }

    // copy into log_msg
    log_msg to_log_msg()
    {
        log_msg msg(&amp;worker_ptr-&gt;name(), level, string_view_t(raw.data(), raw.size()));
        msg.time = time;
        msg.thread_id = thread_id;
        msg.msg_id = msg_id;
        msg.source = source;
        msg.color_range_start = 0;
        msg.color_range_end = 0;
        return msg;
    }
};

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.158">class thread_pool
{
public:
    using item_type = async_msg;
    using q_type = details::mpmc_blocking_queue&lt;item_type&gt;;

    thread_pool(size_t q_max_items, size_t threads_n)
        : q_(q_max_items)
    {
        // std::cout &lt;&lt; "thread_pool()  q_size_bytes: " &lt;&lt; q_size_bytes &lt;&lt;
        // "\tthreads_n: " &lt;&lt; threads_n &lt;&lt; std::endl;
        if (threads_n == 0 || threads_n &gt; 1000)
        {
            throw spdlog_ex("spdlog::thread_pool(): invalid threads_n param (valid "
                            "range is 1-1000)");
        }
        for (size_t i = 0; i &lt; threads_n; i++)
        {
            threads_.emplace_back(&amp;thread_pool::worker_loop_, this);
        }
    }

    // message all threads to terminate gracefully join them
    ~thread_pool()
    {
        try
        {
            for (size_t i = 0; i &lt; threads_.size(); i++)
            {
                post_async_msg_(async_msg(async_msg_type::terminate), async_overflow_policy::block);
            }

            for (auto &amp;t : threads_)
            {
                t.join();
            }
        }
        catch (...)
        {
        }
    }

    thread_pool(const thread_pool &amp;) = delete;
    thread_pool &amp;operator=(thread_pool &amp;&amp;) = delete;

    @others
};

} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.159">void post_log(async_logger_ptr &amp;&amp;worker_ptr, details::log_msg &amp;msg, async_overflow_policy overflow_policy)
{
    async_msg async_m(std::move(worker_ptr), async_msg_type::log, msg);
    post_async_msg_(std::move(async_m), overflow_policy);
}

</t>
<t tx="leo.20220407205633.16">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

// Helper class for file sinks.
// When failing to open a file, retry several times(5) with a delay interval(10 ms).
// Throw spdlog_ex exception on errors.

#include "spdlog/details/log_msg.h"
#include "spdlog/details/os.h"

#include &lt;cerrno&gt;
#include &lt;chrono&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;tuple&gt;

namespace spdlog {
namespace details {

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.160">    void post_flush(async_logger_ptr &amp;&amp;worker_ptr, async_overflow_policy overflow_policy)
    {
        post_async_msg_(async_msg(std::move(worker_ptr), async_msg_type::flush), overflow_policy);
    }

    size_t overrun_counter()
    {
        return q_.overrun_counter();
    }

private:
    q_type q_;

    std::vector&lt;std::thread&gt; threads_;

</t>
<t tx="leo.20220407205633.161">void post_async_msg_(async_msg &amp;&amp;new_msg, async_overflow_policy overflow_policy)
{
    if (overflow_policy == async_overflow_policy::block)
    {
        q_.enqueue(std::move(new_msg));
    }
    else
    {
        q_.enqueue_nowait(std::move(new_msg));
    }
}

</t>
<t tx="leo.20220407205633.162">void worker_loop_()
{
    while (process_next_msg_()) {};
}

// process next message in the queue
// return true if this thread should still be active (while no terminate msg
// was received)
</t>
<t tx="leo.20220407205633.163">bool process_next_msg_()
{
    async_msg incoming_async_msg;
    bool dequeued = q_.dequeue_for(incoming_async_msg, std::chrono::seconds(10));
    if (!dequeued)
    {
        return true;
    }

    switch (incoming_async_msg.msg_type)
    {
    case async_msg_type::log:
    {
        auto msg = incoming_async_msg.to_log_msg();
        incoming_async_msg.worker_ptr-&gt;backend_log_(msg);
        return true;
    }
    case async_msg_type::flush:
    {
        incoming_async_msg.worker_ptr-&gt;backend_flush_();
        return true;
    }

    case async_msg_type::terminate:
    {
        return false;
    }
    }
    assert(false &amp;&amp; "Unexpected async_msg_type");
    return true;
}
</t>
<t tx="leo.20220407205633.164"></t>
<t tx="leo.20220407205633.165">@path ./v-rep_plugin/spdlog/fmt/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

//
// Support for logging binary data as hex
// format flags:
// {:X} - print in uppercase.
// {:s} - don't separate each byte with space.
// {:p} - don't print the position on each line start.
// {:n} - don't split the output to lines.

//
// Examples:
//
// std::vector&lt;char&gt; v(200, 0x0b);
// logger-&gt;info("Some buffer {}", spdlog::to_hex(v));
// char buf[128];
// logger-&gt;info("Some buffer {:X}", spdlog::to_hex(std::begin(buf), std::end(buf)));

namespace spdlog {
namespace details {

template&lt;typename It&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.166">class bytes_range
{
public:
    bytes_range(It range_begin, It range_end)
        : begin_(range_begin)
        , end_(range_end)
    {
    }

    It begin() const
    {
        return begin_;
    }
    It end() const
    {
        return end_;
    }

private:
    It begin_, end_;
};
} // namespace details

// create a bytes_range that wraps the given container
template&lt;typename Container&gt;
inline details::bytes_range&lt;typename Container::const_iterator&gt; to_hex(const Container &amp;container)
{
    static_assert(sizeof(typename Container::value_type) == 1, "sizeof(Container::value_type) != 1");
    using Iter = typename Container::const_iterator;
    return details::bytes_range&lt;Iter&gt;(std::begin(container), std::end(container));
}

// create bytes_range from ranges
template&lt;typename It&gt;
inline details::bytes_range&lt;It&gt; to_hex(const It range_begin, const It range_end)
{
    return details::bytes_range&lt;It&gt;(range_begin, range_end);
}

} // namespace spdlog

namespace fmt {

template&lt;typename T&gt;
struct formatter&lt;spdlog::details::bytes_range&lt;T&gt;&gt;
{
    const std::size_t line_size = 100;
    const char delimiter = ' ';

    bool put_newlines = true;
    bool put_delimiters = true;
    bool use_uppercase = false;
    bool put_positions = true; // position on start of each line

    // parse the format string flags
    template&lt;typename ParseContext&gt;
</t>
<t tx="leo.20220407205633.167">auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin())
{
    auto it = ctx.begin();
    while (*it &amp;&amp; *it != '}')
    {
        switch (*it)
        {
        case 'X':
            use_uppercase = true;
            break;
        case 's':
            put_delimiters = false;
            break;
        case 'p':
            put_positions = false;
            break;
        case 'n':
            put_newlines = false;
            break;
        }

        ++it;
    }
    return it;
}

// format the given bytes range as hex
template&lt;typename FormatContext, typename Container&gt;
</t>
<t tx="leo.20220407205633.168">    auto format(const spdlog::details::bytes_range&lt;Container&gt; &amp;the_range, FormatContext &amp;ctx) -&gt; decltype(ctx.out())
    {
        SPDLOG_CONSTEXPR const char *hex_upper = "0123456789ABCDEF";
        SPDLOG_CONSTEXPR const char *hex_lower = "0123456789abcdef";
        const char *hex_chars = use_uppercase ? hex_upper : hex_lower;

        std::size_t pos = 0;
        std::size_t column = line_size;
        auto inserter = ctx.begin();

        for (auto &amp;item : the_range)
        {
            auto ch = static_cast&lt;unsigned char&gt;(item);
            pos++;

            if (put_newlines &amp;&amp; column &gt;= line_size)
            {
                column = put_newline(inserter, pos);

                // put first byte without delimiter in front of it
                *inserter++ = hex_chars[(ch &gt;&gt; 4) &amp; 0x0f];
                *inserter++ = hex_chars[ch &amp; 0x0f];
                column += 2;
                continue;
            }

            if (put_delimiters)
            {
                *inserter++ = delimiter;
                ++column;
            }

            *inserter++ = hex_chars[(ch &gt;&gt; 4) &amp; 0x0f];
            *inserter++ = hex_chars[ch &amp; 0x0f];
            column += 2;
        }
        return inserter;
    }

    // put newline(and position header)
    // return the next column
    template&lt;typename It&gt;
    std::size_t put_newline(It inserter, std::size_t pos)
    {
#ifdef _WIN32
        *inserter++ = '\r';
#endif
        *inserter++ = '\n';

        if (put_positions)
        {
            fmt::format_to(inserter, "{:&lt;04X}: ", pos - 1);
            return 7;
        }
        else
        {
            return 1;
        }
    }
};
} // namespace fmt
</t>
<t tx="leo.20220407205633.169">@path ./v-rep_plugin/spdlog/fmt/
//
// Copyright(c) 2016-2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

//
// Include a bundled header-only copy of fmtlib or an external one.
// By default spdlog include its own copy.
//

#if !defined(SPDLOG_FMT_EXTERNAL)
#ifndef FMT_HEADER_ONLY
#define FMT_HEADER_ONLY
#endif
#ifndef FMT_USE_WINDOWS_H
#define FMT_USE_WINDOWS_H 0
#endif
#include "bundled/core.h"
#include "bundled/format.h"
#else // external fmtlib
#include &lt;fmt/core.h&gt;
#include &lt;fmt/format.h&gt;
#endif
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.17">class file_helper
{

public:
    const int open_tries = 5;
    const int open_interval = 10;

    explicit file_helper() = default;

    file_helper(const file_helper &amp;) = delete;
    file_helper &amp;operator=(const file_helper &amp;) = delete;

    ~file_helper()
    {
        close();
    }

    @others
};
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.170">@path ./v-rep_plugin/spdlog/fmt/
//
// Copyright(c) 2016 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// include bundled or external copy of fmtlib's ostream support
//
#if !defined(SPDLOG_FMT_EXTERNAL)
#ifndef FMT_HEADER_ONLY
#define FMT_HEADER_ONLY
#endif
#include "bundled/ostream.h"
#include "fmt.h"
#else
#include &lt;fmt/ostream.h&gt;
#endif
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.171"></t>
<t tx="leo.20220407205633.172">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++ - the core API
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.
//
// Copyright (c) 2018 - present, Remotion (Igor Schulz)
// All Rights Reserved
// {fmt} support for rgb color output.

#ifndef FMT_COLORS_H_
#define FMT_COLORS_H_

#include "format.h"

FMT_BEGIN_NAMESPACE

// rgb is a struct for red, green and blue colors.
// We use rgb as name because some editors will show it as color direct in the
// editor.
struct rgb
{
    FMT_CONSTEXPR_DECL rgb()
        : r(0)
        , g(0)
        , b(0)
    {
    }
    FMT_CONSTEXPR_DECL rgb(uint8_t r_, uint8_t g_, uint8_t b_)
        : r(r_)
        , g(g_)
        , b(b_)
    {
    }
    FMT_CONSTEXPR_DECL rgb(uint32_t hex)
        : r((hex &gt;&gt; 16) &amp; 0xFF)
        , g((hex &gt;&gt; 8) &amp; 0xFF)
        , b((hex)&amp;0xFF)
    {
    }
    uint8_t r;
    uint8_t g;
    uint8_t b;
};

namespace internal {

FMT_CONSTEXPR inline void to_esc(uint8_t c, char out[], int offset)
{
    out[offset + 0] = static_cast&lt;char&gt;('0' + c / 100);
    out[offset + 1] = static_cast&lt;char&gt;('0' + c / 10 % 10);
    out[offset + 2] = static_cast&lt;char&gt;('0' + c % 10);
}

} // namespace internal

FMT_FUNC void vprint_rgb(rgb fd, string_view format, format_args args)
{
    char escape_fd[] = "\x1b[38;2;000;000;000m";
    static FMT_CONSTEXPR_DECL const char RESET_COLOR[] = "\x1b[0m";
    internal::to_esc(fd.r, escape_fd, 7);
    internal::to_esc(fd.g, escape_fd, 11);
    internal::to_esc(fd.b, escape_fd, 15);

    std::fputs(escape_fd, stdout);
    vprint(format, args);
    std::fputs(RESET_COLOR, stdout);
}

FMT_FUNC void vprint_rgb(rgb fd, rgb bg, string_view format, format_args args)
{
    char escape_fd[] = "\x1b[38;2;000;000;000m"; // foreground color
    char escape_bg[] = "\x1b[48;2;000;000;000m"; // background color
    static FMT_CONSTEXPR_DECL const char RESET_COLOR[] = "\x1b[0m";
    internal::to_esc(fd.r, escape_fd, 7);
    internal::to_esc(fd.g, escape_fd, 11);
    internal::to_esc(fd.b, escape_fd, 15);

    internal::to_esc(bg.r, escape_bg, 7);
    internal::to_esc(bg.g, escape_bg, 11);
    internal::to_esc(bg.b, escape_bg, 15);

    std::fputs(escape_fd, stdout);
    std::fputs(escape_bg, stdout);
    vprint(format, args);
    std::fputs(RESET_COLOR, stdout);
}

template&lt;typename... Args&gt;
inline void print_rgb(rgb fd, string_view format_str, const Args &amp;... args)
{
    vprint_rgb(fd, format_str, make_format_args(args...));
}

// rgb foreground color
template&lt;typename... Args&gt;
inline void print(rgb fd, string_view format_str, const Args &amp;... args)
{
    vprint_rgb(fd, format_str, make_format_args(args...));
}

// rgb foreground color and background color
template&lt;typename... Args&gt;
inline void print(rgb fd, rgb bg, string_view format_str, const Args &amp;... args)
{
    vprint_rgb(fd, bg, format_str, make_format_args(args...));
}

enum class color : uint32_t
{
    alice_blue = 0xF0F8FF,              // rgb(240,248,255)
    antique_white = 0xFAEBD7,           // rgb(250,235,215)
    aqua = 0x00FFFF,                    // rgb(0,255,255)
    aquamarine = 0x7FFFD4,              // rgb(127,255,212)
    azure = 0xF0FFFF,                   // rgb(240,255,255)
    beige = 0xF5F5DC,                   // rgb(245,245,220)
    bisque = 0xFFE4C4,                  // rgb(255,228,196)
    black = 0x000000,                   // rgb(0,0,0)
    blanched_almond = 0xFFEBCD,         // rgb(255,235,205)
    blue = 0x0000FF,                    // rgb(0,0,255)
    blue_violet = 0x8A2BE2,             // rgb(138,43,226)
    brown = 0xA52A2A,                   // rgb(165,42,42)
    burly_wood = 0xDEB887,              // rgb(222,184,135)
    cadet_blue = 0x5F9EA0,              // rgb(95,158,160)
    chartreuse = 0x7FFF00,              // rgb(127,255,0)
    dark_green = 0x006400,              // rgb(0,100,0)
    dark_khaki = 0xBDB76B,              // rgb(189,183,107)
    dark_magenta = 0x8B008B,            // rgb(139,0,139)
    dark_olive_green = 0x556B2F,        // rgb(85,107,47)
    dark_orange = 0xFF8C00,             // rgb(255,140,0)
    dark_orchid = 0x9932CC,             // rgb(153,50,204)
    dark_red = 0x8B0000,                // rgb(139,0,0)
    dark_salmon = 0xE9967A,             // rgb(233,150,122)
    dark_sea_green = 0x8FBC8F,          // rgb(143,188,143)
    dark_slate_blue = 0x483D8B,         // rgb(72,61,139)
    dark_slate_gray = 0x2F4F4F,         // rgb(47,79,79)
    dark_turquoise = 0x00CED1,          // rgb(0,206,209)
    dark_violet = 0x9400D3,             // rgb(148,0,211)
    deep_pink = 0xFF1493,               // rgb(255,20,147)
    deep_sky_blue = 0x00BFFF,           // rgb(0,191,255)
    dim_gray = 0x696969,                // rgb(105,105,105)
    dodger_blue = 0x1E90FF,             // rgb(30,144,255)
    fire_brick = 0xB22222,              // rgb(178,34,34)
    floral_white = 0xFFFAF0,            // rgb(255,250,240)
    forest_green = 0x228B22,            // rgb(34,139,34)
    fuchsia = 0xFF00FF,                 // rgb(255,0,255)
    gainsboro = 0xDCDCDC,               // rgb(220,220,220)
    ghost_white = 0xF8F8FF,             // rgb(248,248,255)
    gold = 0xFFD700,                    // rgb(255,215,0)
    golden_rod = 0xDAA520,              // rgb(218,165,32)
    gray = 0x808080,                    // rgb(128,128,128)
    green = 0x008000,                   // rgb(0,128,0)
    green_yellow = 0xADFF2F,            // rgb(173,255,47)
    honey_dew = 0xF0FFF0,               // rgb(240,255,240)
    hot_pink = 0xFF69B4,                // rgb(255,105,180)
    indian_red = 0xCD5C5C,              // rgb(205,92,92)
    indigo = 0x4B0082,                  // rgb(75,0,130)
    ivory = 0xFFFFF0,                   // rgb(255,255,240)
    khaki = 0xF0E68C,                   // rgb(240,230,140)
    lavender = 0xE6E6FA,                // rgb(230,230,250)
    lavender_blush = 0xFFF0F5,          // rgb(255,240,245)
    lawn_green = 0x7CFC00,              // rgb(124,252,0)
    lemon_chiffon = 0xFFFACD,           // rgb(255,250,205)
    light_blue = 0xADD8E6,              // rgb(173,216,230)
    light_coral = 0xF08080,             // rgb(240,128,128)
    light_cyan = 0xE0FFFF,              // rgb(224,255,255)
    light_golden_rod_yellow = 0xFAFAD2, // rgb(250,250,210)
    light_gray = 0xD3D3D3,              // rgb(211,211,211)
    light_green = 0x90EE90,             // rgb(144,238,144)
    light_pink = 0xFFB6C1,              // rgb(255,182,193)
    light_salmon = 0xFFA07A,            // rgb(255,160,122)
    light_sea_green = 0x20B2AA,         // rgb(32,178,170)
    light_sky_blue = 0x87CEFA,          // rgb(135,206,250)
    light_slate_gray = 0x778899,        // rgb(119,136,153)
    light_steel_blue = 0xB0C4DE,        // rgb(176,196,222)
    light_yellow = 0xFFFFE0,            // rgb(255,255,224)
    lime = 0x00FF00,                    // rgb(0,255,0)
    lime_green = 0x32CD32,              // rgb(50,205,50)
    linen = 0xFAF0E6,                   // rgb(250,240,230)
    magenta = 0xFF00FF,                 // rgb(255,0,255)
    maroon = 0x800000,                  // rgb(128,0,0)
    medium_aqua_marine = 0x66CDAA,      // rgb(102,205,170)
    medium_blue = 0x0000CD,             // rgb(0,0,205)
    medium_orchid = 0xBA55D3,           // rgb(186,85,211)
    medium_purple = 0x9370DB,           // rgb(147,112,219)
    medium_sea_green = 0x3CB371,        // rgb(60,179,113)
    medium_slate_blue = 0x7B68EE,       // rgb(123,104,238)
    medium_spring_green = 0x00FA9A,     // rgb(0,250,154)
    medium_turquoise = 0x48D1CC,        // rgb(72,209,204)
    medium_violet_red = 0xC71585,       // rgb(199,21,133)
    midnight_blue = 0x191970,           // rgb(25,25,112)
    mint_cream = 0xF5FFFA,              // rgb(245,255,250)
    misty_rose = 0xFFE4E1,              // rgb(255,228,225)
    moccasin = 0xFFE4B5,                // rgb(255,228,181)
    navajo_white = 0xFFDEAD,            // rgb(255,222,173)
    navy = 0x000080,                    // rgb(0,0,128)
    old_lace = 0xFDF5E6,                // rgb(253,245,230)
    olive = 0x808000,                   // rgb(128,128,0)
    olive_drab = 0x6B8E23,              // rgb(107,142,35)
    orange = 0xFFA500,                  // rgb(255,165,0)
    orange_red = 0xFF4500,              // rgb(255,69,0)
    orchid = 0xDA70D6,                  // rgb(218,112,214)
    pale_golden_rod = 0xEEE8AA,         // rgb(238,232,170)
    pale_green = 0x98FB98,              // rgb(152,251,152)
    pale_turquoise = 0xAFEEEE,          // rgb(175,238,238)
    pale_violet_red = 0xDB7093,         // rgb(219,112,147)
    papaya_whip = 0xFFEFD5,             // rgb(255,239,213)
    peach_puff = 0xFFDAB9,              // rgb(255,218,185)
    peru = 0xCD853F,                    // rgb(205,133,63)
    pink = 0xFFC0CB,                    // rgb(255,192,203)
    plum = 0xDDA0DD,                    // rgb(221,160,221)
    powder_blue = 0xB0E0E6,             // rgb(176,224,230)
    purple = 0x800080,                  // rgb(128,0,128)
    rebecca_purple = 0x663399,          // rgb(102,51,153)
    red = 0xFF0000,                     // rgb(255,0,0)
    rosy_brown = 0xBC8F8F,              // rgb(188,143,143)
    royal_blue = 0x4169E1,              // rgb(65,105,225)
    saddle_brown = 0x8B4513,            // rgb(139,69,19)
    salmon = 0xFA8072,                  // rgb(250,128,114)
    sandy_brown = 0xF4A460,             // rgb(244,164,96)
    sea_green = 0x2E8B57,               // rgb(46,139,87)
    sea_shell = 0xFFF5EE,               // rgb(255,245,238)
    sienna = 0xA0522D,                  // rgb(160,82,45)
    silver = 0xC0C0C0,                  // rgb(192,192,192)
    sky_blue = 0x87CEEB,                // rgb(135,206,235)
    slate_blue = 0x6A5ACD,              // rgb(106,90,205)
    slate_gray = 0x708090,              // rgb(112,128,144)
    snow = 0xFFFAFA,                    // rgb(255,250,250)
    spring_green = 0x00FF7F,            // rgb(0,255,127)
    steel_blue = 0x4682B4,              // rgb(70,130,180)
    tan = 0xD2B48C,                     // rgb(210,180,140)
    teal = 0x008080,                    // rgb(0,128,128)
    thistle = 0xD8BFD8,                 // rgb(216,191,216)
    tomato = 0xFF6347,                  // rgb(255,99,71)
    turquoise = 0x40E0D0,               // rgb(64,224,208)
    violet = 0xEE82EE,                  // rgb(238,130,238)
    wheat = 0xF5DEB3,                   // rgb(245,222,179)
    white = 0xFFFFFF,                   // rgb(255,255,255)
    white_smoke = 0xF5F5F5,             // rgb(245,245,245)
    yellow = 0xFFFF00,                  // rgb(255,255,0)
    yellow_green = 0x9ACD32,            // rgb(154,205,50)
};                                      // enum class colors

FMT_END_NAMESPACE

#endif // FMT_COLORS_H_
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.173">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++ - the core API
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_CORE_H_
#define FMT_CORE_H_

#include &lt;cassert&gt;
#include &lt;cstdio&gt;  // std::FILE
#include &lt;cstring&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;

// The fmt library version in the form major * 10000 + minor * 100 + patch.
#define FMT_VERSION 50201

#ifdef __has_feature
# define FMT_HAS_FEATURE(x) __has_feature(x)
#else
# define FMT_HAS_FEATURE(x) 0
#endif

#if defined(__has_include) &amp;&amp; !defined(__INTELLISENSE__) &amp;&amp; \
    (!defined(__INTEL_COMPILER) || __INTEL_COMPILER &gt;= 1600)
# define FMT_HAS_INCLUDE(x) __has_include(x)
#else
# define FMT_HAS_INCLUDE(x) 0
#endif

#ifdef __has_cpp_attribute
# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
#else
# define FMT_HAS_CPP_ATTRIBUTE(x) 0
#endif

#if defined(__GNUC__) &amp;&amp; !defined(__clang__)
# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
#else
# define FMT_GCC_VERSION 0
#endif

#if __cplusplus &gt;= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
# define FMT_HAS_GXX_CXX11 FMT_GCC_VERSION
#else
# define FMT_HAS_GXX_CXX11 0
#endif

#ifdef _MSC_VER
# define FMT_MSC_VER _MSC_VER
#else
# define FMT_MSC_VER 0
#endif

// Check if relaxed C++14 constexpr is supported.
// GCC doesn't allow throw in constexpr until version 6 (bug 67371).
#ifndef FMT_USE_CONSTEXPR
# define FMT_USE_CONSTEXPR \
  (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VER &gt;= 1910 || \
   (FMT_GCC_VERSION &gt;= 600 &amp;&amp; __cplusplus &gt;= 201402L))
#endif
#if FMT_USE_CONSTEXPR
# define FMT_CONSTEXPR constexpr
# define FMT_CONSTEXPR_DECL constexpr
#else
# define FMT_CONSTEXPR inline
# define FMT_CONSTEXPR_DECL
#endif

#ifndef FMT_USE_CONSTEXPR11
# define FMT_USE_CONSTEXPR11 \
    (FMT_MSC_VER &gt;= 1900 || FMT_GCC_VERSION &gt;= 406 || FMT_USE_CONSTEXPR)
#endif
#if FMT_USE_CONSTEXPR11
# define FMT_CONSTEXPR11 constexpr
#else
# define FMT_CONSTEXPR11
#endif

#ifndef FMT_OVERRIDE
# if FMT_HAS_FEATURE(cxx_override) || \
     (FMT_GCC_VERSION &gt;= 408 &amp;&amp; FMT_HAS_GXX_CXX11) || FMT_MSC_VER &gt;= 1900
#  define FMT_OVERRIDE override
# else
#  define FMT_OVERRIDE
# endif
#endif

#if FMT_HAS_FEATURE(cxx_explicit_conversions) || FMT_MSC_VER &gt;= 1800
# define FMT_EXPLICIT explicit
#else
# define FMT_EXPLICIT
#endif

#ifndef FMT_NULL
# if FMT_HAS_FEATURE(cxx_nullptr) || \
   (FMT_GCC_VERSION &gt;= 408 &amp;&amp; FMT_HAS_GXX_CXX11) || FMT_MSC_VER &gt;= 1600
#  define FMT_NULL nullptr
#  define FMT_USE_NULLPTR 1
# else
#  define FMT_NULL NULL
# endif
#endif

#ifndef FMT_USE_NULLPTR
# define FMT_USE_NULLPTR 0
#endif

#if FMT_HAS_CPP_ATTRIBUTE(noreturn)
# define FMT_NORETURN [[noreturn]]
#else
# define FMT_NORETURN
#endif

// Check if exceptions are disabled.
#if defined(__GNUC__) &amp;&amp; !defined(__EXCEPTIONS)
# define FMT_EXCEPTIONS 0
#elif FMT_MSC_VER &amp;&amp; !_HAS_EXCEPTIONS
# define FMT_EXCEPTIONS 0
#endif
#ifndef FMT_EXCEPTIONS
# define FMT_EXCEPTIONS 1
#endif

// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).
#ifndef FMT_USE_NOEXCEPT
# define FMT_USE_NOEXCEPT 0
#endif

#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \
    (FMT_GCC_VERSION &gt;= 408 &amp;&amp; FMT_HAS_GXX_CXX11) || FMT_MSC_VER &gt;= 1900
# define FMT_DETECTED_NOEXCEPT noexcept
# define FMT_HAS_CXX11_NOEXCEPT 1
#else
# define FMT_DETECTED_NOEXCEPT throw()
# define FMT_HAS_CXX11_NOEXCEPT 0
#endif

#ifndef FMT_NOEXCEPT
# if FMT_EXCEPTIONS || FMT_HAS_CXX11_NOEXCEPT
#  define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT
# else
#  define FMT_NOEXCEPT
# endif
#endif

// This is needed because GCC still uses throw() in its headers when exceptions
// are disabled.
#if FMT_GCC_VERSION
# define FMT_DTOR_NOEXCEPT FMT_DETECTED_NOEXCEPT
#else
# define FMT_DTOR_NOEXCEPT FMT_NOEXCEPT
#endif

#ifndef FMT_BEGIN_NAMESPACE
# if FMT_HAS_FEATURE(cxx_inline_namespaces) || FMT_GCC_VERSION &gt;= 404 || \
     FMT_MSC_VER &gt;= 1900
#  define FMT_INLINE_NAMESPACE inline namespace
#  define FMT_END_NAMESPACE }}
# else
#  define FMT_INLINE_NAMESPACE namespace
#  define FMT_END_NAMESPACE } using namespace v5; }
# endif
# define FMT_BEGIN_NAMESPACE namespace fmt { FMT_INLINE_NAMESPACE v5 {
#endif

#if !defined(FMT_HEADER_ONLY) &amp;&amp; defined(_WIN32)
# ifdef FMT_EXPORT
#  define FMT_API __declspec(dllexport)
# elif defined(FMT_SHARED)
#  define FMT_API __declspec(dllimport)
# endif
#endif
#ifndef FMT_API
# define FMT_API
#endif

#ifndef FMT_ASSERT
# define FMT_ASSERT(condition, message) assert((condition) &amp;&amp; message)
#endif

// libc++ supports string_view in pre-c++17.
#if (FMT_HAS_INCLUDE(&lt;string_view&gt;) &amp;&amp; \
      (__cplusplus &gt; 201402L || defined(_LIBCPP_VERSION))) || \
    (defined(_MSVC_LANG) &amp;&amp; _MSVC_LANG &gt; 201402L &amp;&amp; _MSC_VER &gt;= 1910)
# include &lt;string_view&gt;
# define FMT_USE_STD_STRING_VIEW
#elif (FMT_HAS_INCLUDE(&lt;experimental/string_view&gt;) &amp;&amp; \
       __cplusplus &gt;= 201402L)
# include &lt;experimental/string_view&gt;
# define FMT_USE_EXPERIMENTAL_STRING_VIEW
#endif

// std::result_of is defined in &lt;functional&gt; in gcc 4.4.
#if FMT_GCC_VERSION &amp;&amp; FMT_GCC_VERSION &lt;= 404
# include &lt;functional&gt;
#endif

FMT_BEGIN_NAMESPACE
namespace internal {

// An implementation of declval for pre-C++11 compilers such as gcc 4.
template &lt;typename T&gt;
typename std::add_rvalue_reference&lt;T&gt;::type declval() FMT_NOEXCEPT;

template &lt;typename&gt;
struct result_of;

template &lt;typename F, typename... Args&gt;
struct result_of&lt;F(Args...)&gt; {
  // A workaround for gcc 4.4 that doesn't allow F to be a reference.
  @others
}

// A constexpr std::char_traits::length replacement for pre-C++17.
template &lt;typename Char&gt;
FMT_CONSTEXPR size_t length(const Char *s) {
  const Char *start = s;
  while (*s) ++s;
  return s - start;
}
#if FMT_GCC_VERSION
FMT_CONSTEXPR size_t length(const char *s) { return std::strlen(s); }
#endif
}  // namespace internal

/**
  An implementation of ``std::basic_string_view`` for pre-C++17. It provides a
  subset of the API. ``fmt::basic_string_view`` is used for format strings even
  if ``std::string_view`` is available to prevent issues when a library is
  compiled with a different ``-std`` option than the client code (which is not
  recommended).
 */
template &lt;typename Char&gt;
typedef basic_string_view&lt;char&gt; string_view;
typedef basic_string_view&lt;wchar_t&gt; wstring_view;

template &lt;typename Context&gt;
class basic_format_arg;

template &lt;typename Context&gt;
class basic_format_args;

template &lt;typename T&gt;
struct no_formatter_error : std::false_type {};

// A formatter for objects of type T.
template &lt;typename T, typename Char = char, typename Enable = void&gt;
struct formatter {
  static_assert(no_formatter_error&lt;T&gt;::value,
template &lt;typename T, typename Char, typename Enable = void&gt;
struct convert_to_int {
  enum {
    value = !std::is_arithmetic&lt;T&gt;::value &amp;&amp; std::is_convertible&lt;T, int&gt;::value
  };
};

namespace internal {

/** A contiguous memory buffer with an optional growing ability. */
template &lt;typename T&gt;
typedef basic_buffer&lt;char&gt; buffer;
typedef basic_buffer&lt;wchar_t&gt; wbuffer;

// A container-backed buffer.
template &lt;typename Container&gt;
};

// Formatting of wide characters and strings into a narrow output is disallowed:
//   fmt::format("{}", L"test"); // error
// To fix this, use a wide format string:
//   fmt::format(L"{}", L"test");
template &lt;typename Char&gt;
inline void require_wchar() {
  static_assert(
template &lt;typename T&gt;
struct is_named_arg : std::false_type {};

template &lt;typename T, typename Char&gt;
struct is_named_arg&lt;named_arg&lt;T, Char&gt;&gt; : std::true_type {};

enum type {
  none_type, named_arg_type,
  // Integer types should go first,
}

FMT_CONSTEXPR bool is_arithmetic(type t) {
  FMT_ASSERT(t != internal::named_arg_type, "invalid argument type");
  return t &gt; internal::none_type &amp;&amp; t &lt;= internal::last_numeric_type;
}

template &lt;typename Char&gt;
struct string_value {
  const Char *value;
  std::size_t size;
};

template &lt;typename Context&gt;
struct custom_value {
  const void *value;
  void (*format)(const void *arg, Context &amp;ctx);
};

// A formatting argument value.
template &lt;typename Context&gt;
template &lt;typename Context, typename T, type TYPE&gt;
struct init {
  T val;
  static const type type_tag = TYPE;

  FMT_CONSTEXPR init(const T &amp;v) : val(v) {}
  FMT_CONSTEXPR operator value&lt;Context&gt;() const { return value&lt;Context&gt;(val); }
};

template &lt;typename Context, typename T&gt;
FMT_CONSTEXPR basic_format_arg&lt;Context&gt; make_arg(const T &amp;value);

#define FMT_MAKE_VALUE(TAG, ArgType, ValueType) \
  template &lt;typename C&gt; \
  FMT_CONSTEXPR init&lt;C, ValueType, TAG&gt; make_value(ArgType val) { \
    return static_cast&lt;ValueType&gt;(val); \
  }

#define FMT_MAKE_VALUE_SAME(TAG, Type) \
  template &lt;typename C&gt; \
  FMT_CONSTEXPR init&lt;C, Type, TAG&gt; make_value(Type val) { return val; }

FMT_MAKE_VALUE(bool_type, bool, int)
FMT_MAKE_VALUE(int_type, short, int)
FMT_MAKE_VALUE(uint_type, unsigned short, unsigned)
FMT_MAKE_VALUE_SAME(int_type, int)
FMT_MAKE_VALUE_SAME(uint_type, unsigned)

// To minimize the number of types we need to deal with, long is translated
// either to int or to long long depending on its size.
typedef std::conditional&lt;sizeof(long) == sizeof(int), int, long long&gt;::type
FMT_MAKE_VALUE_SAME(ulong_long_type, unsigned long long)
FMT_MAKE_VALUE(int_type, signed char, int)
FMT_MAKE_VALUE(uint_type, unsigned char, unsigned)
FMT_MAKE_VALUE(char_type, char, int)

#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)
template &lt;typename C&gt;
inline init&lt;C, int, char_type&gt; make_value(wchar_t val) {
  require_wchar&lt;typename C::char_type&gt;();
  return static_cast&lt;int&gt;(val);
}
#endif

FMT_MAKE_VALUE(double_type, float, double)
FMT_MAKE_VALUE_SAME(double_type, double)
FMT_MAKE_VALUE_SAME(long_double_type, long double)

// Formatting of wide strings into a narrow buffer and multibyte strings
// into a wide buffer is disallowed (https://github.com/fmtlib/fmt/pull/606).
FMT_MAKE_VALUE(cstring_type, typename C::char_type*,
               const typename C::char_type*)
               basic_string_view&lt;typename C::char_type&gt;)
FMT_MAKE_VALUE(string_type, const std::basic_string&lt;typename C::char_type&gt;&amp;,
               basic_string_view&lt;typename C::char_type&gt;)
FMT_MAKE_VALUE(pointer_type, void*, const void*)
FMT_MAKE_VALUE_SAME(pointer_type, const void*)

#if FMT_USE_NULLPTR
FMT_MAKE_VALUE(pointer_type, std::nullptr_t, const void*)
#endif

// Formatting of arbitrary pointers is disallowed. If you want to output a
// pointer cast it to "void *" or "const void *". In particular, this forbids
// formatting of "[const] volatile char *" which is printed as bool by
// iostreams.
template &lt;typename C, typename T&gt;
typename std::enable_if&lt;!std::is_same&lt;T, typename C::char_type&gt;::value&gt;::type
    make_value(const T *) {
  static_assert(!sizeof(T), "formatting of non-void pointers is disallowed");
}

template &lt;typename C, typename T&gt;
inline typename std::enable_if&lt;
    std::is_enum&lt;T&gt;::value &amp;&amp; convert_to_int&lt;T, typename C::char_type&gt;::value,
    init&lt;C, int, int_type&gt;&gt;::type
  make_value(const T &amp;val) { return static_cast&lt;int&gt;(val); }

template &lt;typename C, typename T, typename Char = typename C::char_type&gt;
inline typename std::enable_if&lt;
    std::is_constructible&lt;basic_string_view&lt;Char&gt;, T&gt;::value,
    init&lt;C, basic_string_view&lt;Char&gt;, string_type&gt;&gt;::type
  make_value(const T &amp;val) { return basic_string_view&lt;Char&gt;(val); }

template &lt;typename C, typename T, typename Char = typename C::char_type&gt;
inline typename std::enable_if&lt;
    !convert_to_int&lt;T, Char&gt;::value &amp;&amp;
    !std::is_convertible&lt;T, basic_string_view&lt;Char&gt;&gt;::value &amp;&amp;
    !std::is_constructible&lt;basic_string_view&lt;Char&gt;, T&gt;::value,
    // Implicit conversion to std::string is not handled here because it's
    // unsafe: https://github.com/fmtlib/fmt/issues/729
    init&lt;C, const T &amp;, custom_type&gt;&gt;::type
  make_value(const T &amp;val) { return val; }

template &lt;typename C, typename T&gt;
init&lt;C, const void*, named_arg_type&gt;
    make_value(const named_arg&lt;T, typename C::char_type&gt; &amp;val) {
  basic_format_arg&lt;C&gt; arg = make_arg&lt;C&gt;(val.value);
  std::memcpy(val.data, &amp;arg, sizeof(arg));
  return static_cast&lt;const void*&gt;(&amp;val);
}

// Maximum number of arguments with packed types.
enum { max_packed_args = 15 };

template &lt;typename Context&gt;
class arg_map;
}  // namespace internal

// A formatting argument. It is a trivially copyable/constructible type to
// allow storage in basic_memory_buffer.
template &lt;typename Context&gt;
struct monostate {};

/**
  \rst
  Visits an argument dispatching to the appropriate visit method based on
  the argument type. For example, if the argument type is ``double`` then
  ``vis(value)`` will be called with the value of type ``double``.
  \endrst
 */
template &lt;typename Visitor, typename Context&gt;
FMT_CONSTEXPR typename internal::result_of&lt;Visitor(int)&gt;::type
    visit(Visitor &amp;&amp;vis, const basic_format_arg&lt;Context&gt; &amp;arg) {
  typedef typename Context::char_type char_type;
  switch (arg.type_) {
  case internal::none_type:
    break;
  case internal::named_arg_type:
    FMT_ASSERT(false, "invalid argument type");
    break;
  case internal::int_type:
    return vis(arg.value_.int_value);
  case internal::uint_type:
    return vis(arg.value_.uint_value);
  case internal::long_long_type:
    return vis(arg.value_.long_long_value);
  case internal::ulong_long_type:
    return vis(arg.value_.ulong_long_value);
  case internal::bool_type:
    return vis(arg.value_.int_value != 0);
  case internal::char_type:
    return vis(static_cast&lt;char_type&gt;(arg.value_.int_value));
  case internal::double_type:
    return vis(arg.value_.double_value);
  case internal::long_double_type:
    return vis(arg.value_.long_double_value);
  case internal::cstring_type:
    return vis(arg.value_.string.value);
  case internal::string_type:
    return vis(basic_string_view&lt;char_type&gt;(
                 arg.value_.string.value, arg.value_.string.size));
  case internal::pointer_type:
    return vis(arg.value_.pointer);
  case internal::custom_type:
    return vis(typename basic_format_arg&lt;Context&gt;::handle(arg.value_.custom));
  }
  return vis(monostate());
}

// Parsing context consisting of a format string range being parsed and an
// argument counter for automatic indexing.
template &lt;typename Char, typename ErrorHandler = internal::error_handler&gt;
typedef basic_parse_context&lt;char&gt; parse_context;
typedef basic_parse_context&lt;wchar_t&gt; wparse_context;

namespace internal {
// A map from argument names to their values for named arguments.
template &lt;typename Context&gt;
template &lt;typename OutputIt, typename Context, typename Char&gt;
template &lt;typename Container&gt;
inline Container &amp;get_container(std::back_insert_iterator&lt;Container&gt; it) {
  typedef std::back_insert_iterator&lt;Container&gt; bi_iterator;
  struct accessor: bi_iterator {
    accessor(bi_iterator iter) : bi_iterator(iter) {}
    using bi_iterator::container;
  };
  return *accessor(it).container;
}
}  // namespace internal

// Formatting context.
template &lt;typename OutputIt, typename Char&gt;
template &lt;typename Char&gt;
struct buffer_context {
}

template &lt;typename Context, typename T&gt;
FMT_CONSTEXPR basic_format_arg&lt;Context&gt; make_arg(const T &amp;value) {
  basic_format_arg&lt;Context&gt; arg;
  arg.type_ = get_type&lt;Context, T&gt;::value;
  arg.value_ = make_value&lt;Context&gt;(value);
  return arg;
}

template &lt;bool IS_PACKED, typename Context, typename T&gt;
inline typename std::enable_if&lt;IS_PACKED, value&lt;Context&gt;&gt;::type
    make_arg(const T &amp;value) {
  return make_value&lt;Context&gt;(value);
}

template &lt;bool IS_PACKED, typename Context, typename T&gt;
inline typename std::enable_if&lt;!IS_PACKED, basic_format_arg&lt;Context&gt;&gt;::type
    make_arg(const T &amp;value) {
  return make_arg&lt;Context&gt;(value);
}
}  // namespace internal

/**
  \rst
  An array of references to arguments. It can be implicitly converted into
  `~fmt::basic_format_args` for passing into type-erased formatting functions
  such as `~fmt::vformat`.
  \endrst
 */
template &lt;typename Context, typename ...Args&gt;
#if !FMT_USE_CONSTEXPR11
template &lt;typename Context, typename ...Args&gt;
const long long format_arg_store&lt;Context, Args...&gt;::TYPES = get_types();
#endif

/**
  \rst
  Constructs an `~fmt::format_arg_store` object that contains references to
  arguments and can be implicitly converted to `~fmt::format_args`. `Context`
  can be omitted in which case it defaults to `~fmt::context`.
  \endrst
 */
template &lt;typename Context, typename ...Args&gt;
inline format_arg_store&lt;Context, Args...&gt;
    make_format_args(const Args &amp; ... args) {
  return format_arg_store&lt;Context, Args...&gt;(args...);
}

template &lt;typename ...Args&gt;
inline format_arg_store&lt;format_context, Args...&gt;
    make_format_args(const Args &amp; ... args) {
  return format_arg_store&lt;format_context, Args...&gt;(args...);
}

/** Formatting arguments. */
template &lt;typename Context&gt;
struct wformat_args : basic_format_args&lt;wformat_context&gt; {
  template &lt;typename ...Args&gt;
  wformat_args(Args &amp;&amp; ... arg)
  : basic_format_args&lt;wformat_context&gt;(std::forward&lt;Args&gt;(arg)...) {}
};

namespace internal {
template &lt;typename Char&gt;
struct named_arg_base {
  basic_string_view&lt;Char&gt; name;

  // Serialized value&lt;context&gt;.
  mutable char data[sizeof(basic_format_arg&lt;format_context&gt;)];

  named_arg_base(basic_string_view&lt;Char&gt; nm) : name(nm) {}

  template &lt;typename Context&gt;
  basic_format_arg&lt;Context&gt; deserialize() const {
    basic_format_arg&lt;Context&gt; arg;
    std::memcpy(&amp;arg, data, sizeof(basic_format_arg&lt;Context&gt;));
    return arg;
  }
};

template &lt;typename T, typename Char&gt;
struct named_arg : named_arg_base&lt;Char&gt; {
  const T &amp;value;

  named_arg(basic_string_view&lt;Char&gt; name, const T &amp;val)
    : named_arg_base&lt;Char&gt;(name), value(val) {}
};
}

/**
  \rst
  Returns a named argument to be used in a formatting function.

  **Example**::

    fmt::print("Elapsed time: {s:.2f} seconds", fmt::arg("s", 1.23));
  \endrst
 */
template &lt;typename T&gt;
inline internal::named_arg&lt;T, char&gt; arg(string_view name, const T &amp;arg) {
  return internal::named_arg&lt;T, char&gt;(name, arg);
}

template &lt;typename T&gt;
inline internal::named_arg&lt;T, wchar_t&gt; arg(wstring_view name, const T &amp;arg) {
  return internal::named_arg&lt;T, wchar_t&gt;(name, arg);
}

// This function template is deleted intentionally to disable nested named
// arguments as in ``format("{}", arg("a", arg("b", 42)))``.
template &lt;typename S, typename T, typename Char&gt;
void arg(S, internal::named_arg&lt;T, Char&gt;) = delete;

// A base class for compile-time strings. It is defined in the fmt namespace to
// make formatting functions visible via ADL, e.g. format(fmt("{}"), 42).
struct compile_string {};

namespace internal {
// If S is a format string type, format_string_traints&lt;S&gt;::char_type gives its
// character type.
template &lt;typename S, typename Enable = void&gt;
struct format_string_traits {
 private:
  // Use constructability as a way to detect if format_string_traits is
  // specialized because other methods are broken on MSVC2013.
  format_string_traits();
};

template &lt;typename Char&gt;
struct format_string_traits_base { typedef Char char_type; };

template &lt;typename Char&gt;
struct format_string_traits&lt;Char *&gt; : format_string_traits_base&lt;Char&gt; {};

template &lt;typename Char&gt;
struct format_string_traits&lt;const Char *&gt; : format_string_traits_base&lt;Char&gt; {};

template &lt;typename Char, std::size_t N&gt;
struct format_string_traits&lt;Char[N]&gt; : format_string_traits_base&lt;Char&gt; {};

template &lt;typename Char, std::size_t N&gt;
struct format_string_traits&lt;const Char[N]&gt; : format_string_traits_base&lt;Char&gt; {};

template &lt;typename Char&gt;
struct format_string_traits&lt;std::basic_string&lt;Char&gt;&gt; :
    format_string_traits_base&lt;Char&gt; {};

template &lt;typename S&gt;
struct format_string_traits&lt;
    S, typename std::enable_if&lt;std::is_base_of&lt;
         basic_string_view&lt;typename S::char_type&gt;, S&gt;::value&gt;::type&gt; :
    format_string_traits_base&lt;typename S::char_type&gt; {};

template &lt;typename S&gt;
struct is_format_string :
    std::integral_constant&lt;
      bool, std::is_constructible&lt;format_string_traits&lt;S&gt;&gt;::value&gt; {};

template &lt;typename S&gt;
struct is_compile_string :
    std::integral_constant&lt;bool, std::is_base_of&lt;compile_string, S&gt;::value&gt; {};

template &lt;typename... Args, typename S&gt;
inline typename std::enable_if&lt;!is_compile_string&lt;S&gt;::value&gt;::type
    check_format_string(const S &amp;) {}
template &lt;typename... Args, typename S&gt;
typename std::enable_if&lt;is_compile_string&lt;S&gt;::value&gt;::type
    check_format_string(S);

template &lt;typename Char&gt;
std::basic_string&lt;Char&gt; vformat(
    basic_string_view&lt;Char&gt; format_str,
    basic_format_args&lt;typename buffer_context&lt;Char&gt;::type&gt; args);
}  // namespace internal

format_context::iterator vformat_to(
    internal::buffer &amp;buf, string_view format_str, format_args args);
wformat_context::iterator vformat_to(
    internal::wbuffer &amp;buf, wstring_view format_str, wformat_args args);

template &lt;typename Container&gt;
struct is_contiguous : std::false_type {};

template &lt;typename Char&gt;
struct is_contiguous&lt;std::basic_string&lt;Char&gt;&gt; : std::true_type {};

template &lt;typename Char&gt;
struct is_contiguous&lt;internal::basic_buffer&lt;Char&gt;&gt; : std::true_type {};

/** Formats a string and writes the output to ``out``. */
template &lt;typename Container&gt;
typename std::enable_if&lt;
  is_contiguous&lt;Container&gt;::value, std::back_insert_iterator&lt;Container&gt;&gt;::type
    vformat_to(std::back_insert_iterator&lt;Container&gt; out,
               string_view format_str, format_args args) {
  internal::container_buffer&lt;Container&gt; buf(internal::get_container(out));
  vformat_to(buf, format_str, args);
  return out;
}

template &lt;typename Container&gt;
typename std::enable_if&lt;
  is_contiguous&lt;Container&gt;::value, std::back_insert_iterator&lt;Container&gt;&gt;::type
  vformat_to(std::back_insert_iterator&lt;Container&gt; out,
             wstring_view format_str, wformat_args args) {
  internal::container_buffer&lt;Container&gt; buf(internal::get_container(out));
  vformat_to(buf, format_str, args);
  return out;
}

template &lt;typename Container, typename... Args&gt;
inline typename std::enable_if&lt;
  is_contiguous&lt;Container&gt;::value, std::back_insert_iterator&lt;Container&gt;&gt;::type
    format_to(std::back_insert_iterator&lt;Container&gt; out,
              string_view format_str, const Args &amp; ... args) {
  format_arg_store&lt;format_context, Args...&gt; as{args...};
  return vformat_to(out, format_str, as);
}

template &lt;typename Container, typename... Args&gt;
inline typename std::enable_if&lt;
  is_contiguous&lt;Container&gt;::value, std::back_insert_iterator&lt;Container&gt;&gt;::type
    format_to(std::back_insert_iterator&lt;Container&gt; out,
              wstring_view format_str, const Args &amp; ... args) {
  return vformat_to(out, format_str,
                    make_format_args&lt;wformat_context&gt;(args...));
}

template &lt;
    typename String,
    typename Char = typename internal::format_string_traits&lt;String&gt;::char_type&gt;
inline std::basic_string&lt;Char&gt; vformat(
/**
  \rst
  Formats arguments and returns the result as a string.

  **Example**::

    #include &lt;fmt/core.h&gt;
    std::string message = fmt::format("The answer is {}", 42);
  \endrst
*/
template &lt;typename String, typename... Args&gt;
inline std::basic_string&lt;
  typename internal::format_string_traits&lt;String&gt;::char_type&gt;
    format(const String &amp;format_str, const Args &amp; ... args) {
  internal::check_format_string&lt;Args...&gt;(format_str);
  // This should be just
  //   return vformat(format_str, make_format_args(args...));
  // but gcc has trouble optimizing the latter, so break it down.
  typedef typename internal::format_string_traits&lt;String&gt;::char_type char_t;
  typedef typename buffer_context&lt;char_t&gt;::type context_t;
  format_arg_store&lt;context_t, Args...&gt; as{args...};
  return internal::vformat(
      basic_string_view&lt;char_t&gt;(format_str), basic_format_args&lt;context_t&gt;(as));
}

FMT_API void vprint(std::FILE *f, string_view format_str, format_args args);
FMT_API void vprint(std::FILE *f, wstring_view format_str, wformat_args args);

/**
  \rst
  Prints formatted data to the file *f*.

  **Example**::

    fmt::print(stderr, "Don't {}!", "panic");
  \endrst
 */
template &lt;typename... Args&gt;
inline void print(std::FILE *f, string_view format_str, const Args &amp; ... args) {
  format_arg_store&lt;format_context, Args...&gt; as(args...);
  vprint(f, format_str, as);
}
/**
  Prints formatted data to the file *f* which should be in wide-oriented mode
  set via ``fwide(f, 1)`` or ``_setmode(_fileno(f), _O_U8TEXT)`` on Windows.
 */
template &lt;typename... Args&gt;
inline void print(std::FILE *f, wstring_view format_str,
FMT_API void vprint(string_view format_str, format_args args);
FMT_API void vprint(wstring_view format_str, wformat_args args);

/**
  \rst
  Prints formatted data to ``stdout``.

  **Example**::

    fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
  \endrst
 */
template &lt;typename... Args&gt;
inline void print(string_view format_str, const Args &amp; ... args) {
  format_arg_store&lt;format_context, Args...&gt; as{args...};
  vprint(format_str, as);
}

template &lt;typename... Args&gt;
inline void print(wstring_view format_str, const Args &amp; ... args) {
  format_arg_store&lt;wformat_context, Args...&gt; as(args...);
  vprint(format_str, as);
}
FMT_END_NAMESPACE

#endif  // FMT_CORE_H_
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.174">  typedef typename std::result_of&lt;
    typename std::remove_reference&lt;F&gt;::type(Args...)&gt;::type type;
};

// Casts nonnegative integer to unsigned.
template &lt;typename Int&gt;
FMT_CONSTEXPR typename std::make_unsigned&lt;Int&gt;::type to_unsigned(Int value) {
  FMT_ASSERT(value &gt;= 0, "negative value");
  return static_cast&lt;typename std::make_unsigned&lt;Int&gt;::type&gt;(value);
</t>
<t tx="leo.20220407205633.175">class basic_string_view {
 private:
  const Char *data_;
  size_t size_;

 public:
  typedef Char char_type;
  typedef const Char *iterator;

  // Standard basic_string_view type.
#if defined(FMT_USE_STD_STRING_VIEW)
  typedef std::basic_string_view&lt;Char&gt; type;
#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
  typedef std::experimental::basic_string_view&lt;Char&gt; type;
#else
  struct type {
    const char *data() const { return FMT_NULL; }
    size_t size() const { return 0; }
  };
#endif

  FMT_CONSTEXPR basic_string_view() FMT_NOEXCEPT : data_(FMT_NULL), size_(0) {}

  /** Constructs a string reference object from a C string and a size. */
  FMT_CONSTEXPR basic_string_view(const Char *s, size_t count) FMT_NOEXCEPT
    : data_(s), size_(count) {}

  /**
    \rst
    Constructs a string reference object from a C string computing
    the size with ``std::char_traits&lt;Char&gt;::length``.
    \endrst
   */
  FMT_CONSTEXPR basic_string_view(const Char *s)
    : data_(s), size_(internal::length(s)) {}

  /** Constructs a string reference from a ``std::basic_string`` object. */
  template &lt;typename Alloc&gt;
  FMT_CONSTEXPR basic_string_view(
      const std::basic_string&lt;Char, Alloc&gt; &amp;s) FMT_NOEXCEPT

  FMT_CONSTEXPR iterator begin() const { return data_; }
  FMT_CONSTEXPR iterator end() const { return data_ + size_; }

  FMT_CONSTEXPR void remove_prefix(size_t n) {
    data_ += n;
    size_ -= n;
  }

  // Lexicographically compare this string reference to other.
  @others
};

</t>
<t tx="leo.20220407205633.176">int compare(basic_string_view other) const {
  size_t str_size = size_ &lt; other.size_ ? size_ : other.size_;
  int result = std::char_traits&lt;Char&gt;::compare(data_, other.data_, str_size);
  if (result == 0)
    result = size_ == other.size_ ? 0 : (size_ &lt; other.size_ ? -1 : 1);
  return result;
}

friend bool operator==(basic_string_view lhs, basic_string_view rhs) {
  return lhs.compare(rhs) == 0;
}
friend bool operator!=(basic_string_view lhs, basic_string_view rhs) {
  return lhs.compare(rhs) != 0;
}
friend bool operator&lt;(basic_string_view lhs, basic_string_view rhs) {
  return lhs.compare(rhs) &lt; 0;
}
friend bool operator&lt;=(basic_string_view lhs, basic_string_view rhs) {
  return lhs.compare(rhs) &lt;= 0;
}
friend bool operator&gt;(basic_string_view lhs, basic_string_view rhs) {
  return lhs.compare(rhs) &gt; 0;
}
friend bool operator&gt;=(basic_string_view lhs, basic_string_view rhs) {
  return lhs.compare(rhs) &gt;= 0;
}
</t>
<t tx="leo.20220407205633.177">class basic_buffer {
 private:
  basic_buffer(const basic_buffer &amp;) = delete;
  void operator=(const basic_buffer &amp;) = delete;

  T *ptr_;
  std::size_t size_;
  std::size_t capacity_;

 protected:
  // Don't initialize ptr_ since it is not accessed to save a few cycles.
  basic_buffer(std::size_t sz) FMT_NOEXCEPT: size_(sz), capacity_(sz) {}

  basic_buffer(T *p = FMT_NULL, std::size_t sz = 0, std::size_t cap = 0)
    FMT_NOEXCEPT: ptr_(p), size_(sz), capacity_(cap) {}

  /** Sets the buffer data and capacity. */
  @others
};

</t>
<t tx="leo.20220407205633.178"> void set(T *buf_data, std::size_t buf_capacity) FMT_NOEXCEPT {
   ptr_ = buf_data;
   capacity_ = buf_capacity;
 }

 /** Increases the buffer capacity to hold at least *capacity* elements. */
 virtual void grow(std::size_t capacity) = 0;

public:
 typedef T value_type;
 typedef const T &amp;const_reference;

 virtual ~basic_buffer() {}

 T *begin() FMT_NOEXCEPT { return ptr_; }
 T *end() FMT_NOEXCEPT { return ptr_ + size_; }

 /** Returns the size of this buffer. */
 std::size_t size() const FMT_NOEXCEPT { return size_; }

 /** Returns the capacity of this buffer. */
 std::size_t capacity() const FMT_NOEXCEPT { return capacity_; }

 /** Returns a pointer to the buffer data. */
 T *data() FMT_NOEXCEPT { return ptr_; }

 /** Returns a pointer to the buffer data. */
 const T *data() const FMT_NOEXCEPT { return ptr_; }

 /**
   Resizes the buffer. If T is a POD type new elements may not be initialized.
  */
</t>
<t tx="leo.20220407205633.179">void resize(std::size_t new_size) {
  reserve(new_size);
  size_ = new_size;
}

/** Clears this buffer. */
void clear() { size_ = 0; }

/** Reserves space to store at least *capacity* elements. */
</t>
<t tx="leo.20220407205633.18">void open(const filename_t &amp;fname, bool truncate = false)
{
    close();
    auto *mode = truncate ? SPDLOG_FILENAME_T("wb") : SPDLOG_FILENAME_T("ab");
    _filename = fname;
    for (int tries = 0; tries &lt; open_tries; ++tries)
    {
        if (!os::fopen_s(&amp;fd_, fname, mode))
        {
            return;
        }

        details::os::sleep_for_millis(open_interval);
    }

    throw spdlog_ex("Failed opening file " + os::filename_to_str(_filename) + " for writing", errno);
}

</t>
<t tx="leo.20220407205633.180">void reserve(std::size_t new_capacity) {
  if (new_capacity &gt; capacity_)
    grow(new_capacity);
}

</t>
<t tx="leo.20220407205633.181">void push_back(const T &amp;value) {
  reserve(size_ + 1);
  ptr_[size_++] = value;
}

/** Appends data to the end of the buffer. */
template &lt;typename U&gt;
void append(const U *begin, const U *end);

T &amp;operator[](std::size_t index) { return ptr_[index]; }
const T &amp;operator[](std::size_t index) const { return ptr_[index]; }
</t>
<t tx="leo.20220407205633.182">class container_buffer : public basic_buffer&lt;typename Container::value_type&gt; {
 private:
  Container &amp;container_;

 protected:
  @others
};

struct error_handler {
  FMT_CONSTEXPR error_handler() {}
  FMT_CONSTEXPR error_handler(const error_handler &amp;) {}

  // This function is intentionally not constexpr to give a compile-time error.
  FMT_API void on_error(const char *message);
</t>
<t tx="leo.20220407205633.183"> void grow(std::size_t capacity) FMT_OVERRIDE {
   container_.resize(capacity);
   this-&gt;set(&amp;container_[0], capacity);
 }

public:
 explicit container_buffer(Container &amp;c)
   : basic_buffer&lt;typename Container::value_type&gt;(c.size()), container_(c) {}
</t>
<t tx="leo.20220407205633.184">  int_type, uint_type, long_long_type, ulong_long_type, bool_type, char_type,
  last_integer_type = char_type,
  // followed by floating-point types.
  double_type, long_double_type, last_numeric_type = long_double_type,
  cstring_type, string_type, pointer_type, custom_type
};

FMT_CONSTEXPR bool is_integral(type t) {
  FMT_ASSERT(t != internal::named_arg_type, "invalid argument type");
  return t &gt; internal::none_type &amp;&amp; t &lt;= internal::last_integer_type;
</t>
<t tx="leo.20220407205633.185">class value {
 public:
  typedef typename Context::char_type char_type;

  union {
    int int_value;
    unsigned uint_value;
    long long long_long_value;
    unsigned long long ulong_long_value;
    double double_value;
    long double long_double_value;
    const void *pointer;
    string_value&lt;char_type&gt; string;
    string_value&lt;signed char&gt; sstring;
    string_value&lt;unsigned char&gt; ustring;
    custom_value&lt;Context&gt; custom;
  };

  FMT_CONSTEXPR value(int val = 0) : int_value(val) {}
  value(unsigned val) { uint_value = val; }
  value(long long val) { long_long_value = val; }
  value(unsigned long long val) { ulong_long_value = val; }
  value(double val) { double_value = val; }
  value(long double val) { long_double_value = val; }
  value(const char_type *val) { string.value = val; }
  value(const signed char *val) {
    @others
};

// Value initializer used to delay conversion to value and reduce memory churn.
</t>
<t tx="leo.20220407205633.186">  static_assert(std::is_same&lt;char, char_type&gt;::value,
                "incompatible string types");
  sstring.value = val;
}
value(const unsigned char *val) {
  @others
</t>
<t tx="leo.20220407205633.187">  static_assert(std::is_same&lt;char, char_type&gt;::value,
                "incompatible string types");
  ustring.value = val;
}
value(basic_string_view&lt;char_type&gt; val) {
  string.value = val.data();
  string.size = val.size();
}
value(const void *val) { pointer = val; }

template &lt;typename T&gt;
explicit value(const T &amp;val) {
  custom.value = &amp;val;
  custom.format = &amp;format_custom_arg&lt;T&gt;;
}

</t>
<t tx="leo.20220407205633.188"> const named_arg_base&lt;char_type&gt; &amp;as_named_arg() {
   return *static_cast&lt;const named_arg_base&lt;char_type&gt;*&gt;(pointer);
 }

private:
 // Formats an argument of a custom type, such as a user-defined class.
 template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.189">static void format_custom_arg(const void *arg, Context &amp;ctx) {
  // Get the formatter type through the context to allow different contexts
  // have different extension points, e.g. `formatter&lt;T&gt;` for `format` and
  // `printf_formatter&lt;T&gt;` for `printf`.
  typename Context::template formatter_type&lt;T&gt;::type f;
  auto &amp;&amp;parse_ctx = ctx.parse_context();
  parse_ctx.advance_to(f.parse(parse_ctx));
  ctx.advance_to(f.format(*static_cast&lt;const T*&gt;(arg), ctx));
}
</t>
<t tx="leo.20220407205633.19">void reopen(bool truncate)
{
    if (_filename.empty())
    {
        throw spdlog_ex("Failed re opening file - was not opened before");
    }
    open(_filename, truncate);
}

</t>
<t tx="leo.20220407205633.190">class basic_format_arg {
 private:
  internal::value&lt;Context&gt; value_;
  internal::type type_;

  template &lt;typename ContextType, typename T&gt;
  friend FMT_CONSTEXPR basic_format_arg&lt;ContextType&gt;
    internal::make_arg(const T &amp;value);

  template &lt;typename Visitor, typename Ctx&gt;
  friend FMT_CONSTEXPR typename internal::result_of&lt;Visitor(int)&gt;::type
    visit(Visitor &amp;&amp;vis, const basic_format_arg&lt;Ctx&gt; &amp;arg);

  friend class basic_format_args&lt;Context&gt;;
  friend class internal::arg_map&lt;Context&gt;;

  typedef typename Context::char_type char_type;

 public:
  @others
};

</t>
<t tx="leo.20220407205633.191">class handle {
 public:
  explicit handle(internal::custom_value&lt;Context&gt; custom): custom_(custom) {}

  void format(Context &amp;ctx) const { custom_.format(custom_.value, ctx); }

 private:
  internal::custom_value&lt;Context&gt; custom_;
};

FMT_CONSTEXPR basic_format_arg() : type_(internal::none_type) {}

FMT_EXPLICIT operator bool() const FMT_NOEXCEPT {
  return type_ != internal::none_type;
}

internal::type type() const { return type_; }

bool is_integral() const { return internal::is_integral(type_); }
bool is_arithmetic() const { return internal::is_arithmetic(type_); }
</t>
<t tx="leo.20220407205633.192">class basic_parse_context : private ErrorHandler {
 private:
  basic_string_view&lt;Char&gt; format_str_;
  int next_arg_id_;

 public:
  typedef Char char_type;
  typedef typename basic_string_view&lt;Char&gt;::iterator iterator;

  explicit FMT_CONSTEXPR basic_parse_context(
      basic_string_view&lt;Char&gt; format_str, ErrorHandler eh = ErrorHandler())
    : ErrorHandler(eh), format_str_(format_str), next_arg_id_(0) {}

  // Returns an iterator to the beginning of the format string range being
  // parsed.
  FMT_CONSTEXPR iterator begin() const FMT_NOEXCEPT {
    return format_str_.begin();
  }

  // Returns an iterator past the end of the format string range being parsed.
  FMT_CONSTEXPR iterator end() const FMT_NOEXCEPT { return format_str_.end(); }

  // Advances the begin iterator to ``it``.
  FMT_CONSTEXPR void advance_to(iterator it) {
    format_str_.remove_prefix(internal::to_unsigned(it - begin()));
  }

  // Returns the next argument index.
  FMT_CONSTEXPR unsigned next_arg_id();

  FMT_CONSTEXPR bool check_arg_id(unsigned) {
    if (next_arg_id_ &gt; 0) {
      on_error("cannot switch from automatic to manual argument indexing");
      return false;
    }
    next_arg_id_ = -1;
    return true;
  }
  @others
};

</t>
<t tx="leo.20220407205633.193">void check_arg_id(basic_string_view&lt;Char&gt;) {}

FMT_CONSTEXPR void on_error(const char *message) {
  ErrorHandler::on_error(message);
}

FMT_CONSTEXPR ErrorHandler error_handler() const { return *this; }
</t>
<t tx="leo.20220407205633.194">class arg_map {
 private:
  arg_map(const arg_map &amp;) = delete;
  void operator=(const arg_map &amp;) = delete;

  typedef typename Context::char_type char_type;

  struct entry {
    basic_string_view&lt;char_type&gt; name;
    basic_format_arg&lt;Context&gt; arg;
  };

  entry *map_;
  unsigned size_;

  @others
};

</t>
<t tx="leo.20220407205633.195"> void push_back(value&lt;Context&gt; val) {
   const internal::named_arg_base&lt;char_type&gt; &amp;named = val.as_named_arg();
   map_[size_] = entry{named.name, named.template deserialize&lt;Context&gt;()};
   ++size_;
 }

public:
 arg_map() : map_(FMT_NULL), size_(0) {}
 void init(const basic_format_args&lt;Context&gt; &amp;args);
 ~arg_map() { delete [] map_; }

 basic_format_arg&lt;Context&gt; find(basic_string_view&lt;char_type&gt; name) const {
   // The list is unsorted, so just return the first matching name.
   for (entry *it = map_, *end = map_ + size_; it != end; ++it) {
     if (it-&gt;name == name)
       return it-&gt;arg;
   }
   return basic_format_arg&lt;Context&gt;();
 }
</t>
<t tx="leo.20220407205633.196">class context_base {
 public:
  typedef OutputIt iterator;

 private:
  basic_parse_context&lt;Char&gt; parse_context_;
  iterator out_;
  basic_format_args&lt;Context&gt; args_;

 protected:
  typedef Char char_type;
  typedef basic_format_arg&lt;Context&gt; format_arg;

  context_base(OutputIt out, basic_string_view&lt;char_type&gt; format_str,
               basic_format_args&lt;Context&gt; ctx_args)
  : parse_context_(format_str), out_(out), args_(ctx_args) {}

  // Returns the argument with specified index.
  format_arg do_get_arg(unsigned arg_id) {
    format_arg arg = args_.get(arg_id);
    if (!arg)
      parse_context_.on_error("argument index out of range");
    return arg;
  }

  // Checks if manual indexing is used and returns the argument with
  // specified index.
  format_arg get_arg(unsigned arg_id) {
    return this-&gt;parse_context().check_arg_id(arg_id) ?
      this-&gt;do_get_arg(arg_id) : format_arg();
  }

 public:
  basic_parse_context&lt;char_type&gt; &amp;parse_context() {
    return parse_context_;
  }

  @others
};

// Extracts a reference to the container from back_insert_iterator.
</t>
<t tx="leo.20220407205633.197">internal::error_handler error_handler() {
  return parse_context_.error_handler();
}

void on_error(const char *message) { parse_context_.on_error(message); }

// Returns an iterator to the beginning of the output range.
iterator out() { return out_; }
iterator begin() { return out_; }  // deprecated

// Advances the begin iterator to ``it``.
void advance_to(iterator it) { out_ = it; }

basic_format_args&lt;Context&gt; args() const { return args_; }
</t>
<t tx="leo.20220407205633.198">class basic_format_context :
  public internal::context_base&lt;
    OutputIt, basic_format_context&lt;OutputIt, Char&gt;, Char&gt; {
 public:
  /** The character type for the output. */
  typedef Char char_type;

  // using formatter_type = formatter&lt;T, char_type&gt;;
  template &lt;typename T&gt;
  struct formatter_type { typedef formatter&lt;T, char_type&gt; type; };

 private:
  internal::arg_map&lt;basic_format_context&gt; map_;

  basic_format_context(const basic_format_context &amp;) = delete;
  void operator=(const basic_format_context &amp;) = delete;

  typedef internal::context_base&lt;OutputIt, basic_format_context, Char&gt; base;
  typedef typename base::format_arg format_arg;
  using base::get_arg;

 public:
  using typename base::iterator;

  /**
   Constructs a ``basic_format_context`` object. References to the arguments are
   stored in the object so make sure they have appropriate lifetimes.
   */
  basic_format_context(OutputIt out, basic_string_view&lt;char_type&gt; format_str,
                basic_format_args&lt;basic_format_context&gt; ctx_args)
    : base(out, format_str, ctx_args) {}

  format_arg next_arg() {
    return this-&gt;do_get_arg(this-&gt;parse_context().next_arg_id());
  }
  format_arg get_arg(unsigned arg_id) { return this-&gt;do_get_arg(arg_id); }

  // Checks if manual indexing is used and returns the argument with the
  // specified name.
  format_arg get_arg(basic_string_view&lt;char_type&gt; name);
};

</t>
<t tx="leo.20220407205633.199">  typedef basic_format_context&lt;
    std::back_insert_iterator&lt;internal::basic_buffer&lt;Char&gt;&gt;, Char&gt; type;
};
typedef buffer_context&lt;char&gt;::type format_context;
typedef buffer_context&lt;wchar_t&gt;::type wformat_context;

namespace internal {
template &lt;typename Context, typename T&gt;
struct get_type {
</t>
<t tx="leo.20220407205633.2">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

// async logger implementation
// uses a thread pool to perform the actual logging

#include "spdlog/details/thread_pool.h"

#include &lt;chrono&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

template&lt;typename It&gt;
inline spdlog::async_logger::async_logger(
    std::string logger_name, It begin, It end, std::weak_ptr&lt;details::thread_pool&gt; tp, async_overflow_policy overflow_policy)
    : logger(std::move(logger_name), begin, end)
    , thread_pool_(std::move(tp))
    , overflow_policy_(overflow_policy)
{
}

inline spdlog::async_logger::async_logger(
    std::string logger_name, sinks_init_list sinks_list, std::weak_ptr&lt;details::thread_pool&gt; tp, async_overflow_policy overflow_policy)
    : async_logger(std::move(logger_name), sinks_list.begin(), sinks_list.end(), std::move(tp), overflow_policy)
{
}

inline spdlog::async_logger::async_logger(
    std::string logger_name, sink_ptr single_sink, std::weak_ptr&lt;details::thread_pool&gt; tp, async_overflow_policy overflow_policy)
    : async_logger(std::move(logger_name), {std::move(single_sink)}, std::move(tp), overflow_policy)
{
}

// send the log message to the thread pool
inline void spdlog::async_logger::sink_it_(details::log_msg &amp;msg)
{
#if defined(SPDLOG_ENABLE_MESSAGE_COUNTER)
    incr_msg_counter_(msg);
#endif
    if (auto pool_ptr = thread_pool_.lock())
    {
        pool_ptr-&gt;post_log(shared_from_this(), msg, overflow_policy_);
    }
    else
    {
        throw spdlog_ex("async log: thread pool doesn't exist anymore");
    }
}

// send flush request to the thread pool
inline void spdlog::async_logger::flush_()
{
    if (auto pool_ptr = thread_pool_.lock())
    {
        pool_ptr-&gt;post_flush(shared_from_this(), overflow_policy_);
    }
    else
    {
        throw spdlog_ex("async flush: thread pool doesn't exist anymore");
    }
}

//
// backend functions - called from the thread pool to do the actual job
//
inline void spdlog::async_logger::backend_log_(const details::log_msg &amp;incoming_log_msg)
{
    try
    {
        for (auto &amp;s : sinks_)
        {
            if (s-&gt;should_log(incoming_log_msg.level))
            {
                s-&gt;log(incoming_log_msg);
            }
        }
    }
    SPDLOG_CATCH_AND_HANDLE

    if (should_flush_(incoming_log_msg))
    {
        backend_flush_();
    }
}

inline void spdlog::async_logger::backend_flush_()
{
    try
    {
        for (auto &amp;sink : sinks_)
        {
            sink-&gt;flush();
        }
    }
    SPDLOG_CATCH_AND_HANDLE
}

inline std::shared_ptr&lt;spdlog::logger&gt; spdlog::async_logger::clone(std::string new_name)
{
    auto cloned = std::make_shared&lt;spdlog::async_logger&gt;(std::move(new_name), sinks_.begin(), sinks_.end(), thread_pool_, overflow_policy_);

    cloned-&gt;set_level(this-&gt;level());
    cloned-&gt;flush_on(this-&gt;flush_level());
    cloned-&gt;set_error_handler(this-&gt;error_handler());
    return std::move(cloned);
}
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.20">void flush()
{
    std::fflush(fd_);
}

</t>
<t tx="leo.20220407205633.200">  typedef decltype(make_value&lt;Context&gt;(
        declval&lt;typename std::decay&lt;T&gt;::type&amp;&gt;())) value_type;
  static const type value = value_type::type_tag;
};

template &lt;typename Context&gt;
FMT_CONSTEXPR11 unsigned long long get_types() { return 0; }

template &lt;typename Context, typename Arg, typename... Args&gt;
FMT_CONSTEXPR11 unsigned long long get_types() {
  return get_type&lt;Context, Arg&gt;::value | (get_types&lt;Context, Args...&gt;() &lt;&lt; 4);
</t>
<t tx="leo.20220407205633.201">class format_arg_store {
 private:
  static const size_t NUM_ARGS = sizeof...(Args);

  // Packed is a macro on MinGW so use IS_PACKED instead.
  static const bool IS_PACKED = NUM_ARGS &lt; internal::max_packed_args;

  typedef typename std::conditional&lt;IS_PACKED,
    return IS_PACKED ?
      static_cast&lt;long long&gt;(internal::get_types&lt;Context, Args...&gt;()) :
#if (FMT_GCC_VERSION &amp;&amp; FMT_GCC_VERSION &lt;= 405) || \
    (FMT_MSC_VER &amp;&amp; FMT_MSC_VER &lt;= 1800)
  // Workaround array initialization issues in gcc &lt;= 4.5 and MSVC &lt;= 2013.
  format_arg_store(const Args &amp;... args) {
    value_type init[DATA_SIZE] =
      {internal::make_arg&lt;IS_PACKED, Context&gt;(args)...};
    std::memcpy(data_, init, sizeof(init));
  }
#else
  format_arg_store(const Args &amp;... args)
    : data_{internal::make_arg&lt;IS_PACKED, Context&gt;(args)...} {}
#endif
};

</t>
<t tx="leo.20220407205633.202">class basic_format_args {
 public:
  typedef unsigned size_type;
  typedef basic_format_arg&lt;Context&gt;  format_arg;

 private:
  // To reduce compiled code size per formatting function call, types of first
  // max_packed_args arguments are passed in the types_ field.
  unsigned long long types_;
  union {
    // If the number of arguments is less than max_packed_args, the argument
    // values are stored in values_, otherwise they are stored in args_.
    // This is done to reduce compiled code size as storing larger objects
    // may require more code (at least on x86-64) even if the same amount of
    // data is actually copied to stack. It saves ~10% on the bloat test.
    const internal::value&lt;Context&gt; *values_;
    const format_arg *args_;
  };

  typename internal::type type(unsigned index) const {
    unsigned shift = index * 4;
    unsigned long long mask = 0xf;
    return static_cast&lt;typename internal::type&gt;(
      (types_ &amp; (mask &lt;&lt; shift)) &gt;&gt; shift);
  }

  friend class internal::arg_map&lt;Context&gt;;

  void set_data(const internal::value&lt;Context&gt; *values) { values_ = values; }
  void set_data(const format_arg *args) { args_ = args; }

  format_arg do_get(size_type index) const {
    format_arg arg;
    long long signed_types = static_cast&lt;long long&gt;(types_);
    if (signed_types &lt; 0) {
      unsigned long long num_args =
    internal::value&lt;Context&gt; &amp;val = arg.value_;
    val = values_[index];
    return arg;
  }

 public:
  basic_format_args() : types_(0) {}

  /**
   \rst
   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.
   \endrst
   */
  template &lt;typename... Args&gt;
  basic_format_args(const format_arg_store&lt;Context, Args...&gt; &amp;store)
  : types_(static_cast&lt;unsigned long long&gt;(store.TYPES)) {
    set_data(store.data_);
  }

  /**
   \rst
   Constructs a `basic_format_args` object from a dynamic set of arguments.
   \endrst
   */
  basic_format_args(const format_arg *args, size_type count)
  : types_(-static_cast&lt;int64_t&gt;(count)) {
    set_data(args);
  }

  /** Returns the argument at specified index. */
  format_arg get(size_type index) const {
    format_arg arg = do_get(index);
    if (arg.type_ == internal::named_arg_type)
      arg = arg.value_.as_named_arg().template deserialize&lt;Context&gt;();
    return arg;
  }

  @others
};
</t>
<t tx="leo.20220407205633.203">unsigned max_size() const {
  long long signed_types = static_cast&lt;long long&gt;(types_);
  return static_cast&lt;unsigned&gt;(
      @others
</t>
<t tx="leo.20220407205633.204">        signed_types &lt; 0 ?
        -signed_types : static_cast&lt;long long&gt;(internal::max_packed_args));
  }
};

/** An alias to ``basic_format_args&lt;context&gt;``. */
// It is a separate type rather than a typedef to make symbols readable.
struct format_args: basic_format_args&lt;format_context&gt; {
  template &lt;typename ...Args&gt;
  format_args(Args &amp;&amp; ... arg)
  : basic_format_args&lt;format_context&gt;(std::forward&lt;Args&gt;(arg)...) {}
</t>
<t tx="leo.20220407205633.205">    const String &amp;format_str,
    basic_format_args&lt;typename buffer_context&lt;Char&gt;::type&gt; args) {
  // Convert format string to string_view to reduce the number of overloads.
  return internal::vformat(basic_string_view&lt;Char&gt;(format_str), args);
}

</t>
<t tx="leo.20220407205633.206">                  const Args &amp; ... args) {
  format_arg_store&lt;wformat_context, Args...&gt; as(args...);
  vprint(f, format_str, as);
}

</t>
<t tx="leo.20220407205633.207">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_FORMAT_INL_H_
#define FMT_FORMAT_INL_H_

#include "format.h"

#include &lt;string.h&gt;

#include &lt;cctype&gt;
#include &lt;cerrno&gt;
#include &lt;climits&gt;
#include &lt;cmath&gt;
#include &lt;cstdarg&gt;
#include &lt;cstddef&gt;  // for std::ptrdiff_t
#include &lt;cstring&gt;  // for std::memmove
#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
# include &lt;locale&gt;
#endif

#if FMT_USE_WINDOWS_H
# if !defined(FMT_HEADER_ONLY) &amp;&amp; !defined(WIN32_LEAN_AND_MEAN)
#  define WIN32_LEAN_AND_MEAN
# endif
# if defined(NOMINMAX) || defined(FMT_WIN_MINMAX)
#  include &lt;windows.h&gt;
# else
#  define NOMINMAX
#  include &lt;windows.h&gt;
#  undef NOMINMAX
# endif
#endif

#if FMT_EXCEPTIONS
# define FMT_TRY try
# define FMT_CATCH(x) catch (x)
#else
# define FMT_TRY if (true)
# define FMT_CATCH(x) if (false)
#endif

#ifdef _MSC_VER
# pragma warning(push)
# pragma warning(disable: 4127)  // conditional expression is constant
# pragma warning(disable: 4702)  // unreachable code
// Disable deprecation warning for strerror. The latter is not called but
// MSVC fails to detect it.
# pragma warning(disable: 4996)
#endif

// Dummy implementations of strerror_r and strerror_s called if corresponding
// system functions are not available.
inline fmt::internal::null&lt;&gt; strerror_r(int, char *, ...) {
  return fmt::internal::null&lt;&gt;();
}
inline fmt::internal::null&lt;&gt; strerror_s(char *, std::size_t, ...) {
  return fmt::internal::null&lt;&gt;();
}

FMT_BEGIN_NAMESPACE

namespace {

#ifndef _MSC_VER
# define FMT_SNPRINTF snprintf
#else  // _MSC_VER
inline int fmt_snprintf(char *buffer, size_t size, const char *format, ...) {
  va_list args;
  va_start(args, format);
  int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);
  va_end(args);
  return result;
}
# define FMT_SNPRINTF fmt_snprintf
#endif  // _MSC_VER

#if defined(_WIN32) &amp;&amp; defined(__MINGW32__) &amp;&amp; !defined(__NO_ISOCEXT)
# define FMT_SWPRINTF snwprintf
#else
# define FMT_SWPRINTF swprintf
#endif // defined(_WIN32) &amp;&amp; defined(__MINGW32__) &amp;&amp; !defined(__NO_ISOCEXT)

typedef void (*FormatFunc)(internal::buffer &amp;, int, string_view);

// Portable thread-safe version of strerror.
// Sets buffer to point to a string describing the error code.
// This can be either a pointer to a string stored in buffer,
// or a pointer to some static immutable string.
// Returns one of the following values:
//   0      - success
//   ERANGE - buffer is not large enough to store the error message
//   other  - failure
// Buffer should be at least of size 1.
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.208">int safe_strerror(
    int error_code, char *&amp;buffer, std::size_t buffer_size) FMT_NOEXCEPT {
  FMT_ASSERT(buffer != FMT_NULL &amp;&amp; buffer_size != 0, "invalid buffer");

  @others
}

</t>
<t tx="leo.20220407205633.209">class dispatcher {
 private:
  int error_code_;
  char *&amp;buffer_;
  std::size_t buffer_size_;

  // A noop assignment operator to avoid bogus warnings.
  @others
};
return dispatcher(error_code, buffer, buffer_size).run();
</t>
<t tx="leo.20220407205633.21">void close()
{
    if (fd_ != nullptr)
    {
        std::fclose(fd_);
        fd_ = nullptr;
    }
}

</t>
<t tx="leo.20220407205633.210">void operator=(const dispatcher &amp;) {}

// Handle the result of XSI-compliant version of strerror_r.
int handle(int result) {
  // glibc versions before 2.13 return result in errno.
  return result == -1 ? errno : result;
}

// Handle the result of GNU-specific version of strerror_r.
</t>
<t tx="leo.20220407205633.211">int handle(char *message) {
  // If the buffer is full then the message is probably truncated.
  if (message == buffer_ &amp;&amp; strlen(buffer_) == buffer_size_ - 1)
    return ERANGE;
  buffer_ = message;
  return 0;
}

// Handle the case when strerror_r is not available.
</t>
<t tx="leo.20220407205633.212">int handle(internal::null&lt;&gt;) {
  return fallback(strerror_s(buffer_, buffer_size_, error_code_));
}

// Fallback to strerror_s when strerror_r is not available.
</t>
<t tx="leo.20220407205633.213">int fallback(int result) {
  // If the buffer is full then the message is probably truncated.
  return result == 0 &amp;&amp; strlen(buffer_) == buffer_size_ - 1 ?
        ERANGE : result;
}

// Fallback to strerror if strerror_r and strerror_s are not available.
</t>
<t tx="leo.20220407205633.214"> int fallback(internal::null&lt;&gt;) {
   errno = 0;
   buffer_ = strerror(error_code_);
   return errno;
 }

public:
 dispatcher(int err_code, char *&amp;buf, std::size_t buf_size)
   : error_code_(err_code), buffer_(buf), buffer_size_(buf_size) {}

</t>
<t tx="leo.20220407205633.215">int run() {
  return handle(strerror_r(error_code_, buffer_, buffer_size_));
}
</t>
<t tx="leo.20220407205633.216">void format_error_code(internal::buffer &amp;out, int error_code,
                       string_view message) FMT_NOEXCEPT {
  // Report error code making sure that the output fits into
  // inline_buffer_size to avoid dynamic memory allocation and potential
  // bad_alloc.
  out.resize(0);
  static const char SEP[] = ": ";
  static const char ERROR_STR[] = "error ";
  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.
  std::size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
  typedef internal::int_traits&lt;int&gt;::main_type main_type;
  main_type abs_value = static_cast&lt;main_type&gt;(error_code);
  if (internal::is_negative(error_code)) {
    abs_value = 0 - abs_value;
    ++error_code_size;
  }
  error_code_size += internal::count_digits(abs_value);
  writer w(out);
  if (message.size() &lt;= inline_buffer_size - error_code_size) {
    w.write(message);
    w.write(SEP);
  }
  w.write(ERROR_STR);
  w.write(error_code);
  assert(out.size() &lt;= inline_buffer_size);
}

</t>
<t tx="leo.20220407205633.217">void report_error(FormatFunc func, int error_code,
                  string_view message) FMT_NOEXCEPT {
  memory_buffer full_message;
  func(full_message, error_code, message);
  // Use Writer::data instead of Writer::c_str to avoid potential memory
  // allocation.
  std::fwrite(full_message.data(), full_message.size(), 1, stderr);
  std::fputc('\n', stderr);
}
}  // namespace

#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
</t>
<t tx="leo.20220407205633.218">class locale {
 private:
  std::locale locale_;

 public:
  explicit locale(std::locale loc = std::locale()) : locale_(loc) {}
  std::locale get() { return locale_; }
};

FMT_FUNC size_t internal::count_code_points(u8string_view s) {
  const char8_t *data = s.data();
  int num_code_points = 0;
  for (size_t i = 0, size = s.size(); i != size; ++i) {
    if ((data[i].value &amp; 0xc0) != 0x80)
      ++num_code_points;
  }
  return num_code_points;
}

template &lt;typename Char&gt;
FMT_FUNC Char internal::thousands_sep(locale_provider *lp) {
  std::locale loc = lp ? lp-&gt;locale().get() : std::locale();
  return std::use_facet&lt;std::numpunct&lt;Char&gt;&gt;(loc).thousands_sep();
}
#else
template &lt;typename Char&gt;
FMT_FUNC Char internal::thousands_sep(locale_provider *lp) {
  return FMT_STATIC_THOUSANDS_SEPARATOR;
}
#endif

FMT_FUNC void system_error::init(
</t>
<t tx="leo.20220407205633.219">    int err_code, string_view format_str, format_args args) {
  error_code_ = err_code;
  memory_buffer buffer;
  format_system_error(buffer, err_code, vformat(format_str, args));
  std::runtime_error &amp;base = *this;
  base = std::runtime_error(to_string(buffer));
}

namespace internal {
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.22">void write(const fmt::memory_buffer &amp;buf)
{
    size_t msg_size = buf.size();
    auto data = buf.data();
    if (std::fwrite(data, 1, msg_size, fd_) != msg_size)
    {
        throw spdlog_ex("Failed writing to file " + os::filename_to_str(_filename), errno);
    }
}

size_t size() const
{
    if (fd_ == nullptr)
    {
        throw spdlog_ex("Cannot use size() on closed file " + os::filename_to_str(_filename));
    }
    return os::filesize(fd_);
}

</t>
<t tx="leo.20220407205633.220">int char_traits&lt;char&gt;::format_float(
    char *buffer, std::size_t size, const char *format, int precision, T value) {
  return precision &lt; 0 ?
      FMT_SNPRINTF(buffer, size, format, value) :
      FMT_SNPRINTF(buffer, size, format, precision, value);
}

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.221">int char_traits&lt;wchar_t&gt;::format_float(
    wchar_t *buffer, std::size_t size, const wchar_t *format, int precision,
    T value) {
  return precision &lt; 0 ?
      FMT_SWPRINTF(buffer, size, format, value) :
      FMT_SWPRINTF(buffer, size, format, precision, value);
}

template &lt;typename T&gt;
const char basic_data&lt;T&gt;::DIGITS[] =
  factor * 10000, \
  factor * 100000, \
  factor * 1000000, \
  factor * 10000000, \
  factor * 100000000, \
  factor * 1000000000

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.222">const uint32_t basic_data&lt;T&gt;::POWERS_OF_10_32[] = {
  1, FMT_POWERS_OF_10(1)
};

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.223">const uint32_t basic_data&lt;T&gt;::ZERO_OR_POWERS_OF_10_32[] = {
  0, FMT_POWERS_OF_10(1)
};

template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.224">const uint64_t basic_data&lt;T&gt;::ZERO_OR_POWERS_OF_10_64[] = {
  0,
  FMT_POWERS_OF_10(1),
  FMT_POWERS_OF_10(1000000000ull),
  10000000000000000000ull
};

// Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
// These are generated by support/compute-powers.py.
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.225">const uint64_t basic_data&lt;T&gt;::POW10_SIGNIFICANDS[] = {
  0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
  0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
  0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
  0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
  0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
  0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
  0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
  0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
  0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
  0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
  0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
  0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
  0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
  0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
  0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
  0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
  0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
  0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
  0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
  0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
  0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
  0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
  0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
  0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
  0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
  0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
  0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
  0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
  0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
};

// Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
// to significands above.
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.226">const int16_t basic_data&lt;T&gt;::POW10_EXPONENTS[] = {
  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,  -954,
   -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688,  -661,
   -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396,  -369,
   -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103,   -77,
    -50,   -24,     3,    30,    56,    83,   109,   136,   162,   189,   216,
    242,   269,   295,   322,   348,   375,   402,   428,   455,   481,   508,
    534,   561,   588,   614,   641,   667,   694,   720,   747,   774,   800,
    827,   853,   880,   907,   933,   960,   986,  1013,  1039,  1066
};

template &lt;typename T&gt; const char basic_data&lt;T&gt;::RESET_COLOR[] = "\x1b[0m";
template &lt;typename T&gt; const wchar_t basic_data&lt;T&gt;::WRESET_COLOR[] = L"\x1b[0m";

// A handmade floating-point number f * pow(2, e).
</t>
<t tx="leo.20220407205633.227">class fp {
 private:
  typedef uint64_t significand_type;

  // All sizes are in bits.
  static FMT_CONSTEXPR_DECL const int char_size =
  int e;

  @others
};

// Returns an fp number representing x - y. Result may not be normalized.
inline fp operator-(fp x, fp y) {
  FMT_ASSERT(x.f &gt;= y.f &amp;&amp; x.e == y.e, "invalid operands");
  return fp(x.f - y.f, x.e);
}

// Computes an fp number r with r.f = x.f * y.f / pow(2, 64) rounded to nearest
// with half-up tie breaking, r.e = x.e + y.e + 64. Result may not be normalized.
FMT_API fp operator*(fp x, fp y);

// Returns cached power (of 10) c_k = c_k.f * pow(2, c_k.e) such that its
// (binary) exponent satisfies min_exponent &lt;= c_k.e &lt;= min_exponent + 3.
FMT_API fp get_cached_power(int min_exponent, int &amp;pow10_exponent);

FMT_FUNC fp operator*(fp x, fp y) {
  // Multiply 32-bit parts of significands.
  uint64_t mask = (1ULL &lt;&lt; 32) - 1;
  uint64_t a = x.f &gt;&gt; 32, b = x.f &amp; mask;
  uint64_t c = y.f &gt;&gt; 32, d = y.f &amp; mask;
  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
  // Compute mid 64-bit of result and round.
  uint64_t mid = (bd &gt;&gt; 32) + (ad &amp; mask) + (bc &amp; mask) + (1U &lt;&lt; 31);
  return fp(ac + (ad &gt;&gt; 32) + (bc &gt;&gt; 32) + (mid &gt;&gt; 32), x.e + y.e + 64);
}

FMT_FUNC fp get_cached_power(int min_exponent, int &amp;pow10_exponent) {
  const double one_over_log2_10 = 0.30102999566398114;  // 1 / log2(10)
  int index = static_cast&lt;int&gt;(std::ceil(
// Generates output using Grisu2 digit-gen algorithm.
FMT_FUNC void grisu2_gen_digits(
</t>
<t tx="leo.20220407205633.228">static FMT_CONSTEXPR_DECL const int significand_size =
  sizeof(significand_type) * char_size;

fp(): f(0), e(0) {}
fp(uint64_t f, int e): f(f), e(e) {}

// Constructs fp from an IEEE754 double. It is a template to prevent compile
// errors on platforms where double is not IEEE754.
template &lt;typename Double&gt;
explicit fp(Double d) {
  // Assume double is in the format [sign][exponent][significand].
  typedef std::numeric_limits&lt;Double&gt; limits;
  const int double_size = static_cast&lt;int&gt;(sizeof(Double) * char_size);
  const int exponent_size =
    biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
  e = static_cast&lt;int&gt;(biased_e - exponent_bias - double_significand_size);
}

// Normalizes the value converted from double and multiplied by (1 &lt;&lt; SHIFT).
template &lt;int SHIFT = 0&gt;
</t>
<t tx="leo.20220407205633.229">void normalize() {
  // Handle subnormals.
  auto shifted_implicit_bit = implicit_bit &lt;&lt; SHIFT;
  while ((f &amp; shifted_implicit_bit) == 0) {
    f &lt;&lt;= 1;
    --e;
  }
  // Subtract 1 to account for hidden bit.
  auto offset = significand_size - double_significand_size - SHIFT - 1;
  f &lt;&lt;= offset;
  e -= offset;
}

// Compute lower and upper boundaries (m^- and m^+ in the Grisu paper), where
// a boundary is a value half way between the number and its predecessor
// (lower) or successor (upper). The upper boundary is normalized and lower
// has the same exponent but may be not normalized.
</t>
<t tx="leo.20220407205633.23">const filename_t &amp;filename() const
{
    return _filename;
}

</t>
<t tx="leo.20220407205633.230">void compute_boundaries(fp &amp;lower, fp &amp;upper) const {
  lower = f == implicit_bit ?
        fp((f &lt;&lt; 2) - 1, e - 2) : fp((f &lt;&lt; 1) - 1, e - 1);
  upper = fp((f &lt;&lt; 1) + 1, e - 1);
  upper.normalize&lt;1&gt;();  // 1 is to account for the exponent shift above.
  lower.f &lt;&lt;= lower.e - upper.e;
  lower.e = upper.e;
}
</t>
<t tx="leo.20220407205633.231">    const fp &amp;scaled_value, const fp &amp;scaled_upper, uint64_t delta,
    char *buffer, size_t &amp;size, int &amp;dec_exp) {
  internal::fp one(1ull &lt;&lt; -scaled_upper.e, scaled_upper.e);
  // hi (p1 in Grisu) contains the most significant digits of scaled_upper.
  // hi = floor(scaled_upper / one).
  uint32_t hi = static_cast&lt;uint32_t&gt;(scaled_upper.f &gt;&gt; -one.e);
  // lo (p2 in Grisu) contains the least significants digits of scaled_upper.
  // lo = scaled_upper mod 1.
  uint64_t lo = scaled_upper.f &amp; (one.f - 1);
  size = 0;
  auto exp = count_digits(hi);  // kappa in Grisu.
  while (exp &gt; 0) {
    uint32_t digit = 0;
    // This optimization by miloyip reduces the number of integer divisions by
    // one per iteration.
    switch (exp) {
    case 10: digit = hi / 1000000000; hi %= 1000000000; break;
    case  9: digit = hi /  100000000; hi %=  100000000; break;
    case  8: digit = hi /   10000000; hi %=   10000000; break;
    case  7: digit = hi /    1000000; hi %=    1000000; break;
    case  6: digit = hi /     100000; hi %=     100000; break;
    case  5: digit = hi /      10000; hi %=      10000; break;
    case  4: digit = hi /       1000; hi %=       1000; break;
    case  3: digit = hi /        100; hi %=        100; break;
    case  2: digit = hi /         10; hi %=         10; break;
    case  1: digit = hi;              hi =           0; break;
    default:
      FMT_ASSERT(false, "invalid number of digits");
    }
    if (digit != 0 || size != 0)
      buffer[size++] = static_cast&lt;char&gt;('0' + digit);
    --exp;
    uint64_t remainder = (static_cast&lt;uint64_t&gt;(hi) &lt;&lt; -one.e) + lo;
    if (remainder &lt;= delta) {
      dec_exp += exp;
      // TODO: use scaled_value
      (void)scaled_value;
      return;
    }
  }
  for (;;) {
    lo *= 10;
    delta *= 10;
    char digit = static_cast&lt;char&gt;(lo &gt;&gt; -one.e);
    if (digit != 0 || size != 0)
      buffer[size++] = static_cast&lt;char&gt;('0' + digit);
    lo &amp;= one.f - 1;
    --exp;
    if (lo &lt; delta) {
      dec_exp += exp;
      return;
    }
  }
}

FMT_FUNC void grisu2_format_positive(double value, char *buffer, size_t &amp;size,
                                     int &amp;dec_exp) {
  FMT_ASSERT(value &gt; 0, "value is nonpositive");
  fp fp_value(value);
  fp lower, upper;  // w^- and w^+ in the Grisu paper.
  fp_value.compute_boundaries(lower, upper);
  // Find a cached power of 10 close to 1 / upper.
  const int min_exp = -60;  // alpha in Grisu.
  auto dec_pow = get_cached_power(  // \tilde{c}_{-k} in Grisu.
}

FMT_FUNC void round(char *buffer, size_t &amp;size, int &amp;exp,
</t>
<t tx="leo.20220407205633.232">                    int digits_to_remove) {
  size -= to_unsigned(digits_to_remove);
  exp += digits_to_remove;
  int digit = buffer[size] - '0';
  // TODO: proper rounding and carry
  if (digit &gt; 5 || (digit == 5 &amp;&amp; (digits_to_remove &gt; 1 ||
                                   (buffer[size - 1] - '0') % 2) != 0)) {
    ++buffer[size - 1];
  }
}

// Writes the exponent exp in the form "[+-]d{1,3}" to buffer.
FMT_FUNC char *write_exponent(char *buffer, int exp) {
  FMT_ASSERT(-1000 &lt; exp &amp;&amp; exp &lt; 1000, "exponent out of range");
  if (exp &lt; 0) {
    *buffer++ = '-';
    exp = -exp;
  } else {
    *buffer++ = '+';
  }
  if (exp &gt;= 100) {
    *buffer++ = static_cast&lt;char&gt;('0' + exp / 100);
    exp %= 100;
    const char *d = data::DIGITS + exp * 2;
    *buffer++ = d[0];
    *buffer++ = d[1];
  } else {
    const char *d = data::DIGITS + exp * 2;
    *buffer++ = d[0];
    *buffer++ = d[1];
  }
  return buffer;
}

FMT_FUNC void format_exp_notation(
    char *buffer, size_t &amp;size, int exp, int precision, bool upper) {
  // Insert a decimal point after the first digit and add an exponent.
  std::memmove(buffer + 2, buffer + 1, size - 1);
  buffer[1] = '.';
  exp += static_cast&lt;int&gt;(size) - 1;
  int num_digits = precision - static_cast&lt;int&gt;(size) + 1;
  if (num_digits &gt; 0) {
    std::uninitialized_fill_n(buffer + size + 1, num_digits, '0');
    size += to_unsigned(num_digits);
  } else if (num_digits &lt; 0) {
    round(buffer, size, exp, -num_digits);
  }
  char *p = buffer + size + 1;
  *p++ = upper ? 'E' : 'e';
  size = to_unsigned(write_exponent(p, exp) - buffer);
}

// Prettifies the output of the Grisu2 algorithm.
// The number is given as v = buffer * 10^exp.
FMT_FUNC void grisu2_prettify(char *buffer, size_t &amp;size, int exp,
</t>
<t tx="leo.20220407205633.233">                              int precision, bool upper) {
  // pow(10, full_exp - 1) &lt;= v &lt;= pow(10, full_exp).
  int int_size = static_cast&lt;int&gt;(size);
  int full_exp = int_size + exp;
  const int exp_threshold = 21;
  if (int_size &lt;= full_exp &amp;&amp; full_exp &lt;= exp_threshold) {
    // 1234e7 -&gt; 12340000000[.0+]
    std::uninitialized_fill_n(buffer + int_size, full_exp - int_size, '0');
    char *p = buffer + full_exp;
    if (precision &gt; 0) {
      *p++ = '.';
      std::uninitialized_fill_n(p, precision, '0');
      p += precision;
    }
    size = to_unsigned(p - buffer);
  } else if (0 &lt; full_exp &amp;&amp; full_exp &lt;= exp_threshold) {
    // 1234e-2 -&gt; 12.34[0+]
    int fractional_size = -exp;
    std::memmove(buffer + full_exp + 1, buffer + full_exp,
                 to_unsigned(fractional_size));
    buffer[full_exp] = '.';
    int num_zeros = precision - fractional_size;
    if (num_zeros &gt; 0) {
      std::uninitialized_fill_n(buffer + size + 1, num_zeros, '0');
      size += to_unsigned(num_zeros);
    }
    ++size;
  } else if (-6 &lt; full_exp &amp;&amp; full_exp &lt;= 0) {
    // 1234e-6 -&gt; 0.001234
    int offset = 2 - full_exp;
    std::memmove(buffer + offset, buffer, size);
    buffer[0] = '0';
    buffer[1] = '.';
    std::uninitialized_fill_n(buffer + 2, -full_exp, '0');
    size = to_unsigned(int_size + offset);
  } else {
    format_exp_notation(buffer, size, exp, precision, upper);
  }
}

#if FMT_CLANG_VERSION
# define FMT_FALLTHROUGH [[clang::fallthrough]];
#elif FMT_GCC_VERSION &gt;= 700
# define FMT_FALLTHROUGH [[gnu::fallthrough]];
#else
# define FMT_FALLTHROUGH
#endif

// Formats a nonnegative value using Grisu2 algorithm. Grisu2 doesn't give any
// guarantees on the shortness of the result.
FMT_FUNC void grisu2_format(double value, char *buffer, size_t &amp;size, char type,
</t>
<t tx="leo.20220407205633.234">                            int precision, bool write_decimal_point) {
  FMT_ASSERT(value &gt;= 0, "value is negative");
  int dec_exp = 0;  // K in Grisu.
  if (value &gt; 0) {
    grisu2_format_positive(value, buffer, size, dec_exp);
  } else {
    *buffer = '0';
    size = 1;
  }
  const int default_precision = 6;
  if (precision &lt; 0)
    precision = default_precision;
  bool upper = false;
  switch (type) {
  case 'G':
    upper = true;
    FMT_FALLTHROUGH
  case '\0': case 'g': {
    int digits_to_remove = static_cast&lt;int&gt;(size) - precision;
    if (digits_to_remove &gt; 0) {
      round(buffer, size, dec_exp, digits_to_remove);
      // Remove trailing zeros.
      while (size &gt; 0 &amp;&amp; buffer[size - 1] == '0') {
        --size;
        ++dec_exp;
      }
    }
    precision = 0;
    break;
  }
  case 'F':
    upper = true;
    FMT_FALLTHROUGH
  case 'f': {
    int digits_to_remove = -dec_exp - precision;
    if (digits_to_remove &gt; 0) {
      if (digits_to_remove &gt;= static_cast&lt;int&gt;(size))
        digits_to_remove = static_cast&lt;int&gt;(size) - 1;
      round(buffer, size, dec_exp, digits_to_remove);
    }
    break;
  }
  case 'e': case 'E':
    format_exp_notation(buffer, size, dec_exp, precision, type == 'E');
    return;
  }
  if (write_decimal_point &amp;&amp; precision &lt; 1)
    precision = 1;
  grisu2_prettify(buffer, size, dec_exp, precision, upper);
}
}  // namespace internal

#if FMT_USE_WINDOWS_H

FMT_FUNC internal::utf8_to_utf16::utf8_to_utf16(string_view s) {
  static const char ERROR_MSG[] = "cannot convert string from UTF-8 to UTF-16";
  if (s.size() &gt; INT_MAX)
    FMT_THROW(windows_error(ERROR_INVALID_PARAMETER, ERROR_MSG));
  int s_size = static_cast&lt;int&gt;(s.size());
  if (s_size == 0) {
    // MultiByteToWideChar does not support zero length, handle separately.
    buffer_.resize(1);
    buffer_[0] = 0;
    return;
  }

  int length = MultiByteToWideChar(

FMT_FUNC internal::utf16_to_utf8::utf16_to_utf8(wstring_view s) {
  if (int error_code = convert(s)) {
    FMT_THROW(windows_error(error_code,
        "cannot convert string from UTF-16 to UTF-8"));
  }
}

FMT_FUNC int internal::utf16_to_utf8::convert(wstring_view s) {
  if (s.size() &gt; INT_MAX)
    return ERROR_INVALID_PARAMETER;
  int s_size = static_cast&lt;int&gt;(s.size());
  if (s_size == 0) {
    // WideCharToMultiByte does not support zero length, handle separately.
    buffer_.resize(1);
    buffer_[0] = 0;
    return 0;
  }

  int length = WideCharToMultiByte(
}

FMT_FUNC void windows_error::init(
</t>
<t tx="leo.20220407205633.235">    int err_code, string_view format_str, format_args args) {
  error_code_ = err_code;
  memory_buffer buffer;
  internal::format_windows_error(buffer, err_code, vformat(format_str, args));
  std::runtime_error &amp;base = *this;
  base = std::runtime_error(to_string(buffer));
}

FMT_FUNC void internal::format_windows_error(
</t>
<t tx="leo.20220407205633.236">    internal::buffer &amp;out, int error_code, string_view message) FMT_NOEXCEPT {
  FMT_TRY {
    wmemory_buffer buf;
    buf.resize(inline_buffer_size);
    for (;;) {
      wchar_t *system_message = &amp;buf[0];
      @others
}

#endif  // FMT_USE_WINDOWS_H

FMT_FUNC void format_system_error(
</t>
<t tx="leo.20220407205633.237">    int result = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        FMT_NULL, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        system_message, static_cast&lt;uint32_t&gt;(buf.size()), FMT_NULL);
    if (result != 0) {
      utf16_to_utf8 utf8_message;
      if (utf8_message.convert(system_message) == ERROR_SUCCESS) {
        writer w(out);
        w.write(message);
        w.write(": ");
        w.write(utf8_message);
        return;
      }
      break;
    }
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
      break;  // Can't get error message, report error code instead.
    buf.resize(buf.size() * 2);
  }
} FMT_CATCH(...) {}
format_error_code(out, error_code, message);
</t>
<t tx="leo.20220407205633.238">    internal::buffer &amp;out, int error_code, string_view message) FMT_NOEXCEPT {
  FMT_TRY {
    memory_buffer buf;
    buf.resize(inline_buffer_size);
    for (;;) {
      char *system_message = &amp;buf[0];
      int result = safe_strerror(error_code, system_message, buf.size());
      if (result == 0) {
        writer w(out);
        w.write(message);
        w.write(": ");
        w.write(system_message);
        return;
      }
      if (result != ERANGE)
        break;  // Can't get error message, report error code instead.
      buf.resize(buf.size() * 2);
    }
  } FMT_CATCH(...) {}
  format_error_code(out, error_code, message);
}

template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.239">void basic_fixed_buffer&lt;Char&gt;::grow(std::size_t) {
  FMT_THROW(std::runtime_error("buffer overflow"));
}

FMT_FUNC void internal::error_handler::on_error(const char *message) {
  FMT_THROW(format_error(message));
}

FMT_FUNC void report_system_error(
</t>
<t tx="leo.20220407205633.24">static bool file_exists(const filename_t &amp;fname)
{
    return os::file_exists(fname);
}

//
// return file path and its extension:
//
// "mylog.txt" =&gt; ("mylog", ".txt")
// "mylog" =&gt; ("mylog", "")
// "mylog." =&gt; ("mylog.", "")
// "/dir1/dir2/mylog.txt" =&gt; ("/dir1/dir2/mylog", ".txt")
//
// the starting dot in filenames is ignored (hidden files):
//
// ".mylog" =&gt; (".mylog". "")
// "my_folder/.mylog" =&gt; ("my_folder/.mylog", "")
// "my_folder/.mylog.txt" =&gt; ("my_folder/.mylog", ".txt")
</t>
<t tx="leo.20220407205633.240">    int error_code, fmt::string_view message) FMT_NOEXCEPT {
  report_error(format_system_error, error_code, message);
}

#if FMT_USE_WINDOWS_H
FMT_FUNC void report_windows_error(
</t>
<t tx="leo.20220407205633.241">    int error_code, fmt::string_view message) FMT_NOEXCEPT {
  report_error(internal::format_windows_error, error_code, message);
}
#endif

FMT_FUNC void vprint(std::FILE *f, string_view format_str, format_args args) {
  memory_buffer buffer;
  vformat_to(buffer, format_str, args);
  std::fwrite(buffer.data(), 1, buffer.size(), f);
}

FMT_FUNC void vprint(std::FILE *f, wstring_view format_str, wformat_args args) {
  wmemory_buffer buffer;
  vformat_to(buffer, format_str, args);
  std::fwrite(buffer.data(), sizeof(wchar_t), buffer.size(), f);
}

FMT_FUNC void vprint(string_view format_str, format_args args) {
  vprint(stdout, format_str, args);
}

FMT_FUNC void vprint(wstring_view format_str, wformat_args args) {
  vprint(stdout, format_str, args);
}

#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
FMT_FUNC locale locale_provider::locale() { return fmt::locale(); }
#endif

FMT_END_NAMESPACE

#ifdef _MSC_VER
# pragma warning(pop)
#endif

#endif  // FMT_FORMAT_INL_H_
</t>
<t tx="leo.20220407205633.242">@path ./v-rep_plugin/spdlog/fmt/bundled/
/*
 Formatting library for C++

 Copyright (c) 2012 - present, Victor Zverovich
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 1. Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FMT_FORMAT_H_
#define FMT_FORMAT_H_

#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;limits&gt;
#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;stdint.h&gt;

#ifdef __clang__
# define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
#else
# define FMT_CLANG_VERSION 0
#endif

#ifdef __INTEL_COMPILER
# define FMT_ICC_VERSION __INTEL_COMPILER
#elif defined(__ICL)
# define FMT_ICC_VERSION __ICL
#else
# define FMT_ICC_VERSION 0
#endif

#ifdef __NVCC__
# define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
#else
# define FMT_CUDA_VERSION 0
#endif

#include "core.h"

#if FMT_GCC_VERSION &gt;= 406 || FMT_CLANG_VERSION
# pragma GCC diagnostic push

// Disable the warning about declaration shadowing because it affects too
// many valid cases.
# pragma GCC diagnostic ignored "-Wshadow"

// Disable the warning about implicit conversions that may change the sign of
// an integer; silencing it otherwise would require many explicit casts.
# pragma GCC diagnostic ignored "-Wsign-conversion"
#endif

# if FMT_CLANG_VERSION
#  pragma GCC diagnostic ignored "-Wgnu-string-literal-operator-template"
# endif

#ifdef _SECURE_SCL
# define FMT_SECURE_SCL _SECURE_SCL
#else
# define FMT_SECURE_SCL 0
#endif

#if FMT_SECURE_SCL
# include &lt;iterator&gt;
#endif

#ifdef __has_builtin
# define FMT_HAS_BUILTIN(x) __has_builtin(x)
#else
# define FMT_HAS_BUILTIN(x) 0
#endif

#ifdef __GNUC_LIBSTD__
# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)
#endif

#ifndef FMT_THROW
# if FMT_EXCEPTIONS
#  if FMT_MSC_VER
FMT_BEGIN_NAMESPACE
namespace internal {
template &lt;typename Exception&gt;
inline void do_throw(const Exception &amp;x) {
  // Silence unreachable code warnings in MSVC because these are nearly
  // impossible to fix in a generic code.
  volatile bool b = true;
  if (b)
    throw x;
}
}
FMT_END_NAMESPACE
#   define FMT_THROW(x) fmt::internal::do_throw(x)
#  else
#   define FMT_THROW(x) throw x
#  endif
# else
#  define FMT_THROW(x) do { static_cast&lt;void&gt;(sizeof(x)); assert(false); } while(false);
# endif
#endif

#ifndef FMT_USE_USER_DEFINED_LITERALS
// For Intel's compiler and NVIDIA's compiler both it and the system gcc/msc
// must support UDLs.
# if (FMT_HAS_FEATURE(cxx_user_literals) || \
      FMT_GCC_VERSION &gt;= 407 || FMT_MSC_VER &gt;= 1900) &amp;&amp; \
      (!(FMT_ICC_VERSION || FMT_CUDA_VERSION) || \
       FMT_ICC_VERSION &gt;= 1500 || FMT_CUDA_VERSION &gt;= 700)
#  define FMT_USE_USER_DEFINED_LITERALS 1
# else
#  define FMT_USE_USER_DEFINED_LITERALS 0
# endif
#endif

// EDG C++ Front End based compilers (icc, nvcc) do not currently support UDL
// templates.
#if FMT_USE_USER_DEFINED_LITERALS &amp;&amp; \
    FMT_ICC_VERSION == 0 &amp;&amp; \
    FMT_CUDA_VERSION == 0 &amp;&amp; \
    ((FMT_GCC_VERSION &gt;= 600 &amp;&amp; __cplusplus &gt;= 201402L) || \
    (defined(FMT_CLANG_VERSION) &amp;&amp; FMT_CLANG_VERSION &gt;= 304))
# define FMT_UDL_TEMPLATE 1
#else
# define FMT_UDL_TEMPLATE 0
#endif

#ifndef FMT_USE_EXTERN_TEMPLATES
# ifndef FMT_HEADER_ONLY
#  define FMT_USE_EXTERN_TEMPLATES \
     ((FMT_CLANG_VERSION &gt;= 209 &amp;&amp; __cplusplus &gt;= 201103L) || \
      (FMT_GCC_VERSION &gt;= 303 &amp;&amp; FMT_HAS_GXX_CXX11))
# else
#  define FMT_USE_EXTERN_TEMPLATES 0
# endif
#endif

#if FMT_HAS_GXX_CXX11 || FMT_HAS_FEATURE(cxx_trailing_return) || \
    FMT_MSC_VER &gt;= 1600
# define FMT_USE_TRAILING_RETURN 1
#else
# define FMT_USE_TRAILING_RETURN 0
#endif

#ifndef FMT_USE_GRISU
# define FMT_USE_GRISU 0
#endif

// __builtin_clz is broken in clang with Microsoft CodeGen:
// https://github.com/fmtlib/fmt/issues/519
#ifndef _MSC_VER
# if FMT_GCC_VERSION &gt;= 400 || FMT_HAS_BUILTIN(__builtin_clz)
#  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
# endif

# if FMT_GCC_VERSION &gt;= 400 || FMT_HAS_BUILTIN(__builtin_clzll)
#  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
# endif
#endif

// A workaround for gcc 4.4 that doesn't support union members with ctors.
#if (FMT_GCC_VERSION &amp;&amp; FMT_GCC_VERSION &lt;= 404) || \
    (FMT_MSC_VER &amp;&amp; FMT_MSC_VER &lt;= 1800)
# define FMT_UNION struct
#else
# define FMT_UNION union
#endif

// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
// MSVC intrinsics if the clz and clzll builtins are not available.
#if FMT_MSC_VER &amp;&amp; !defined(FMT_BUILTIN_CLZLL) &amp;&amp; !defined(_MANAGED)
# include &lt;intrin.h&gt;  // _BitScanReverse, _BitScanReverse64

FMT_BEGIN_NAMESPACE
namespace internal {
// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
# ifndef __clang__
#  pragma intrinsic(_BitScanReverse)
# endif
inline uint32_t clz(uint32_t x) {
  unsigned long r = 0;
  _BitScanReverse(&amp;r, x);

  assert(x != 0);
  // Static analysis complains about using uninitialized data
  // "r", but the only way that can happen is if "x" is 0,
  // which the callers guarantee to not happen.
# pragma warning(suppress: 6102)
  return 31 - r;
}
# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)

# if defined(_WIN64) &amp;&amp; !defined(__clang__)
#  pragma intrinsic(_BitScanReverse64)
# endif

inline uint32_t clzll(uint64_t x) {
  unsigned long r = 0;
# ifdef _WIN64
  _BitScanReverse64(&amp;r, x);
# else
  // Scan the high 32 bits.
  if (_BitScanReverse(&amp;r, static_cast&lt;uint32_t&gt;(x &gt;&gt; 32)))
    return 63 - (r + 32);

  // Scan the low 32 bits.
  _BitScanReverse(&amp;r, static_cast&lt;uint32_t&gt;(x));
# endif

  assert(x != 0);
  // Static analysis complains about using uninitialized data
  // "r", but the only way that can happen is if "x" is 0,
  // which the callers guarantee to not happen.
# pragma warning(suppress: 6102)
  return 63 - r;
}
# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)
}
FMT_END_NAMESPACE
#endif

FMT_BEGIN_NAMESPACE
namespace internal {

// An equivalent of `*reinterpret_cast&lt;Dest*&gt;(&amp;source)` that doesn't produce
// undefined behavior (e.g. due to type aliasing).
// Example: uint64_t d = bit_cast&lt;uint64_t&gt;(2.718);
template &lt;typename Dest, typename Source&gt;
inline Dest bit_cast(const Source&amp; source) {
  static_assert(sizeof(Dest) == sizeof(Source), "size mismatch");
  Dest dest;
  std::memcpy(&amp;dest, &amp;source, sizeof(dest));
  return dest;
}

// An implementation of begin and end for pre-C++11 compilers such as gcc 4.
template &lt;typename C&gt;
FMT_CONSTEXPR auto begin(const C &amp;c) -&gt; decltype(c.begin()) {
  return c.begin();
}
template &lt;typename T, std::size_t N&gt;
FMT_CONSTEXPR T *begin(T (&amp;array)[N]) FMT_NOEXCEPT { return array; }
template &lt;typename C&gt;
FMT_CONSTEXPR auto end(const C &amp;c) -&gt; decltype(c.end()) { return c.end(); }
template &lt;typename T, std::size_t N&gt;
FMT_CONSTEXPR T *end(T (&amp;array)[N]) FMT_NOEXCEPT { return array + N; }

// For std::result_of in gcc 4.4.
template &lt;typename Result&gt;
struct function {
  template &lt;typename T&gt;
  struct result { typedef Result type; };
};

struct dummy_int {
  int data[2];
  operator int() const { return 0; }
};
typedef std::numeric_limits&lt;internal::dummy_int&gt; fputil;

// Dummy implementations of system functions such as signbit and ecvt called
// if the latter are not available.
inline dummy_int signbit(...) { return dummy_int(); }
inline dummy_int _ecvt_s(...) { return dummy_int(); }
inline dummy_int isinf(...) { return dummy_int(); }
inline dummy_int _finite(...) { return dummy_int(); }
inline dummy_int isnan(...) { return dummy_int(); }
inline dummy_int _isnan(...) { return dummy_int(); }

inline bool use_grisu() {
  return FMT_USE_GRISU &amp;&amp; std::numeric_limits&lt;double&gt;::is_iec559;
}

// Formats value using Grisu2 algorithm:
// https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf
FMT_API void grisu2_format(double value, char *buffer, size_t &amp;size, char type,
                           int precision, bool write_decimal_point);

template &lt;typename Allocator&gt;
typename Allocator::value_type *allocate(Allocator&amp; alloc, std::size_t n) {
#if __cplusplus &gt;= 201103L || FMT_MSC_VER &gt;= 1700
  return std::allocator_traits&lt;Allocator&gt;::allocate(alloc, n);
#else
  return alloc.allocate(n);
#endif
}

// A helper function to suppress bogus "conditional expression is constant"
// warnings.
template &lt;typename T&gt;
inline T const_check(T value) { return value; }
}  // namespace internal
FMT_END_NAMESPACE

namespace std {
// Standard permits specialization of std::numeric_limits. This specialization
// is used to resolve ambiguity between isinf and std::isinf in glibc:
// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48891
// and the same for isnan and signbit.
template &lt;&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.243">class numeric_limits&lt;fmt::internal::dummy_int&gt; :
    public std::numeric_limits&lt;int&gt; {
 public:
  // Portable version of isinf.
  template &lt;typename T&gt;
  @others
};
}  // namespace std

FMT_BEGIN_NAMESPACE
template &lt;typename Range&gt;
class basic_writer;

template &lt;typename OutputIt, typename T = typename OutputIt::value_type&gt;
</t>
<t tx="leo.20220407205633.244">static bool isinfinity(T x) {
  using namespace fmt::internal;
  // The resolution "priority" is:
  // isinf macro &gt; std::isinf &gt; ::isinf &gt; fmt::internal::isinf
  if (const_check(sizeof(isinf(x)) != sizeof(dummy_int)))
    return isinf(x) != 0;
  return !_finite(static_cast&lt;double&gt;(x));
}

// Portable version of isnan.
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.245">static bool isnotanumber(T x) {
  using namespace fmt::internal;
  if (const_check(sizeof(isnan(x)) != sizeof(fmt::internal::dummy_int)))
    return isnan(x) != 0;
  return _isnan(static_cast&lt;double&gt;(x)) != 0;
}

// Portable version of signbit.
</t>
<t tx="leo.20220407205633.246">static bool isnegative(double x) {
  using namespace fmt::internal;
  if (const_check(sizeof(signbit(x)) != sizeof(fmt::internal::dummy_int)))
    return signbit(x) != 0;
  if (x &lt; 0) return true;
  if (!isnotanumber(x)) return false;
  int dec = 0, sign = 0;
  char buffer[2];  // The buffer size must be &gt;= 2 or _ecvt_s will fail.
  _ecvt_s(buffer, sizeof(buffer), x, 0, &amp;dec, &amp;sign);
  return sign != 0;
}
</t>
<t tx="leo.20220407205633.247">class output_range {
 private:
  OutputIt it_;

  // Unused yet.
  typedef void sentinel;
  sentinel end() const;

 public:
  typedef OutputIt iterator;
  typedef T value_type;

  explicit output_range(OutputIt it): it_(it) {}
  OutputIt begin() const { return it_; }
};

// A range where begin() returns back_insert_iterator.
template &lt;typename Container&gt;
</t>
<t tx="leo.20220407205633.248">class back_insert_range:
    public output_range&lt;std::back_insert_iterator&lt;Container&gt;&gt; {
  typedef output_range&lt;std::back_insert_iterator&lt;Container&gt;&gt; base;
 public:
  typedef typename Container::value_type value_type;

  back_insert_range(Container &amp;c): base(std::back_inserter(c)) {}
  back_insert_range(typename base::iterator it): base(it) {}
};

typedef basic_writer&lt;back_insert_range&lt;internal::buffer&gt;&gt; writer;
typedef basic_writer&lt;back_insert_range&lt;internal::wbuffer&gt;&gt; wwriter;

/** A formatting error such as invalid format string. */
</t>
<t tx="leo.20220407205633.249">class format_error : public std::runtime_error {
 public:
  explicit format_error(const char *message)
  : std::runtime_error(message) {}

  explicit format_error(const std::string &amp;message)
  : std::runtime_error(message) {}
};

namespace internal {

#if FMT_SECURE_SCL
template &lt;typename T&gt;
struct checked { typedef stdext::checked_array_iterator&lt;T*&gt; type; };

// Make a checked iterator to avoid warnings on MSVC.
template &lt;typename T&gt;
inline stdext::checked_array_iterator&lt;T*&gt; make_checked(T *p, std::size_t size) {
  return {p, size};
}
#else
template &lt;typename T&gt;
struct checked { typedef T *type; };
template &lt;typename T&gt;
inline T *make_checked(T *p, std::size_t) { return p; }
#endif

template &lt;typename T&gt;
template &lt;typename U&gt;
</t>
<t tx="leo.20220407205633.25">    static std::tuple&lt;filename_t, filename_t&gt; split_by_extenstion(const spdlog::filename_t &amp;fname)
    {
        auto ext_index = fname.rfind('.');

        // no valid extension found - return whole path and empty string as
        // extension
        if (ext_index == filename_t::npos || ext_index == 0 || ext_index == fname.size() - 1)
        {
            return std::make_tuple(fname, spdlog::filename_t());
        }

        // treat casese like "/etc/rc.d/somelogfile or "/abc/.hiddenfile"
        auto folder_index = fname.rfind(details::os::folder_sep);
        if (folder_index != filename_t::npos &amp;&amp; folder_index &gt;= ext_index - 1)
        {
            return std::make_tuple(fname, spdlog::filename_t());
        }

        // finally - return a valid base and extension tuple
        return std::make_tuple(fname.substr(0, ext_index), fname.substr(ext_index));
    }

private:
    std::FILE *fd_{nullptr};
    filename_t _filename;
</t>
<t tx="leo.20220407205633.250">void basic_buffer&lt;T&gt;::append(const U *begin, const U *end) {
  std::size_t new_size = size_ + internal::to_unsigned(end - begin);
  reserve(new_size);
  std::uninitialized_copy(begin, end,
                          internal::make_checked(ptr_, capacity_) + size_);
  size_ = new_size;
}
}  // namespace internal

// A UTF-8 code unit type.
struct char8_t {
  char value;
  FMT_CONSTEXPR explicit operator bool() const FMT_NOEXCEPT {
    return value != 0;
  }
};

// A UTF-8 string view.
</t>
<t tx="leo.20220407205633.251">class u8string_view : public basic_string_view&lt;char8_t&gt; {
 private:
  typedef basic_string_view&lt;char8_t&gt; base;

 public:
  using basic_string_view::basic_string_view;
  using basic_string_view::char_type;

  u8string_view(const char *s)
    : base(reinterpret_cast&lt;const char8_t*&gt;(s)) {}

  u8string_view(const char *s, size_t count) FMT_NOEXCEPT
    : base(reinterpret_cast&lt;const char8_t*&gt;(s), count) {}
};

#if FMT_USE_USER_DEFINED_LITERALS
inline namespace literals {
inline u8string_view operator"" _u(const char *s, std::size_t n) {
  return u8string_view(s, n);
}
}
#endif

// A wrapper around std::locale used to reduce compile times since &lt;locale&gt;
// is very heavy.
class locale;

</t>
<t tx="leo.20220407205633.252">class locale_provider {
 public:
  virtual ~locale_provider() {}
  virtual fmt::locale locale();
};

// The number of characters to store in the basic_memory_buffer object itself
// to avoid dynamic memory allocation.
enum { inline_buffer_size = 500 };

/**
  \rst
  A dynamically growing memory buffer for trivially copyable/constructible types
  with the first ``SIZE`` elements stored in the object itself.

  You can use one of the following typedefs for common character types:

  +----------------+------------------------------+
  | Type           | Definition                   |
  +================+==============================+
  | memory_buffer  | basic_memory_buffer&lt;char&gt;    |
  +----------------+------------------------------+
  | wmemory_buffer | basic_memory_buffer&lt;wchar_t&gt; |
  +----------------+------------------------------+

  **Example**::

     fmt::memory_buffer out;
     format_to(out, "The answer is {}.", 42);

  This will write the following output to the ``out`` object:

  .. code-block:: none

     The answer is 42.

  The output can be converted to an ``std::string`` with ``to_string(out)``.
  \endrst
 */
template &lt;typename T, std::size_t SIZE = inline_buffer_size,
          typename Allocator = std::allocator&lt;T&gt; &gt;
</t>
<t tx="leo.20220407205633.253">class basic_memory_buffer: private Allocator, public internal::basic_buffer&lt;T&gt; {
 private:
  T store_[SIZE];

  // Deallocate memory allocated by the buffer.
  @others
};

template &lt;typename T, std::size_t SIZE, typename Allocator&gt;
</t>
<t tx="leo.20220407205633.254"> void deallocate() {
   T* data = this-&gt;data();
   if (data != store_) Allocator::deallocate(data, this-&gt;capacity());
 }

protected:
 void grow(std::size_t size) FMT_OVERRIDE;

public:
 explicit basic_memory_buffer(const Allocator &amp;alloc = Allocator())
     : Allocator(alloc) {
   this-&gt;set(store_, SIZE);
 }
 ~basic_memory_buffer() { deallocate(); }

private:
 // Move data from other to this buffer.
</t>
<t tx="leo.20220407205633.255"> void move(basic_memory_buffer &amp;other) {
   Allocator &amp;this_alloc = *this, &amp;other_alloc = other;
   this_alloc = std::move(other_alloc);
   T* data = other.data();
   std::size_t size = other.size(), capacity = other.capacity();
   if (data == other.store_) {
     this-&gt;set(store_, capacity);
     std::uninitialized_copy(other.store_, other.store_ + size,
                             internal::make_checked(store_, capacity));
   } else {
     this-&gt;set(data, capacity);
     // Set pointer to the inline array so that delete is not called
     // when deallocating.
     other.set(other.store_, 0);
   }
   this-&gt;resize(size);
 }

public:
 /**
   \rst
   Constructs a :class:`fmt::basic_memory_buffer` object moving the content
   of the other object to it.
   \endrst
  */
 basic_memory_buffer(basic_memory_buffer &amp;&amp;other) {
   move(other);
 }

 /**
   \rst
   Moves the content of the other ``basic_memory_buffer`` object to this one.
   \endrst
  */
 basic_memory_buffer &amp;operator=(basic_memory_buffer &amp;&amp;other) {
   assert(this != &amp;other);
   deallocate();
   move(other);
   return *this;
 }

 // Returns a copy of the allocator associated with this buffer.
 Allocator get_allocator() const { return *this; }
</t>
<t tx="leo.20220407205633.256">void basic_memory_buffer&lt;T, SIZE, Allocator&gt;::grow(std::size_t size) {
  std::size_t old_capacity = this-&gt;capacity();
  std::size_t new_capacity = old_capacity + old_capacity / 2;
  if (size &gt; new_capacity)
      new_capacity = size;
  T *old_data = this-&gt;data();
  T *new_data = internal::allocate&lt;Allocator&gt;(*this, new_capacity);
  // The following code doesn't throw, so the raw pointer above doesn't leak.
  std::uninitialized_copy(old_data, old_data + this-&gt;size(),
                          internal::make_checked(new_data, new_capacity));
  this-&gt;set(new_data, new_capacity);
  // deallocate must not throw according to the standard, but even if it does,
  // the buffer already uses the new storage and will deallocate it in
  // destructor.
  if (old_data != store_)
    Allocator::deallocate(old_data, old_capacity);
}

typedef basic_memory_buffer&lt;char&gt; memory_buffer;
typedef basic_memory_buffer&lt;wchar_t&gt; wmemory_buffer;

/**
  \rst
  A fixed-size memory buffer. For a dynamically growing buffer use
  :class:`fmt::basic_memory_buffer`.

  Trying to increase the buffer size past the initial capacity will throw
  ``std::runtime_error``.
  \endrst
 */
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.257">class basic_fixed_buffer : public internal::basic_buffer&lt;Char&gt; {
 public:
  /**
   \rst
   Constructs a :class:`fmt::basic_fixed_buffer` object for *array* of the
   given size.
   \endrst
   */
  basic_fixed_buffer(Char *array, std::size_t size) {
    this-&gt;set(array, size);
  }

  /**
   \rst
   Constructs a :class:`fmt::basic_fixed_buffer` object for *array* of the
   size known at compile time.
   \endrst
   */
  template &lt;std::size_t SIZE&gt;
  explicit basic_fixed_buffer(Char (&amp;array)[SIZE]) {
    this-&gt;set(array, SIZE);
  }

 protected:
  FMT_API void grow(std::size_t size) FMT_OVERRIDE;
};

namespace internal {

template &lt;typename Char&gt;
struct char_traits;

template &lt;&gt;
struct char_traits&lt;char&gt; {
  // Formats a floating-point number.
  template &lt;typename T&gt;
  FMT_API static int format_float(char *buffer, std::size_t size,
      const char *format, int precision, T value);
};

template &lt;&gt;
struct char_traits&lt;wchar_t&gt; {
  template &lt;typename T&gt;
  FMT_API static int format_float(wchar_t *buffer, std::size_t size,
      const wchar_t *format, int precision, T value);
};

#if FMT_USE_EXTERN_TEMPLATES
extern template int char_traits&lt;char&gt;::format_float&lt;double&gt;(
    wchar_t *buffer, std::size_t size, const wchar_t* format, int precision,
    long double value);
#endif

template &lt;typename Container&gt;
inline typename std::enable_if&lt;
  is_contiguous&lt;Container&gt;::value,
  typename checked&lt;typename Container::value_type&gt;::type&gt;::type
    reserve(std::back_insert_iterator&lt;Container&gt; &amp;it, std::size_t n) {
  Container &amp;c = internal::get_container(it);
  std::size_t size = c.size();
  c.resize(size + n);
  return make_checked(&amp;c[size], n);
}

template &lt;typename Iterator&gt;
inline Iterator &amp;reserve(Iterator &amp;it, std::size_t) { return it; }

template &lt;typename Char&gt;
class null_terminating_iterator;

template &lt;typename Char&gt;
FMT_CONSTEXPR_DECL const Char *pointer_from(null_terminating_iterator&lt;Char&gt; it);

// An iterator that produces a null terminator on *end. This simplifies parsing
// and allows comparing the performance of processing a null-terminated string
// vs string_view.
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.258">class null_terminating_iterator {
 public:
  typedef std::ptrdiff_t difference_type;
  typedef Char value_type;
  typedef const Char* pointer;
  typedef const Char&amp; reference;
  typedef std::random_access_iterator_tag iterator_category;

  null_terminating_iterator() : ptr_(0), end_(0) {}

  FMT_CONSTEXPR null_terminating_iterator(const Char *ptr, const Char *end)
    : ptr_(ptr), end_(end) {}

  template &lt;typename Range&gt;
  FMT_CONSTEXPR explicit null_terminating_iterator(const Range &amp;r)
    : ptr_(r.begin()), end_(r.end()) {}

  FMT_CONSTEXPR null_terminating_iterator &amp;operator=(const Char *ptr) {
    assert(ptr &lt;= end_);
    ptr_ = ptr;
    return *this;
  }

  FMT_CONSTEXPR Char operator*() const {
    return ptr_ != end_ ? *ptr_ : 0;
  }

  FMT_CONSTEXPR null_terminating_iterator operator++() {
    ++ptr_;
    return *this;
  }

  FMT_CONSTEXPR null_terminating_iterator operator++(int) {
    null_terminating_iterator result(*this);
    ++ptr_;
    return result;
  }

  FMT_CONSTEXPR null_terminating_iterator operator--() {
    --ptr_;
    return *this;
  }

  FMT_CONSTEXPR null_terminating_iterator operator+(difference_type n) {
    return null_terminating_iterator(ptr_ + n, end_);
  }

  FMT_CONSTEXPR null_terminating_iterator operator-(difference_type n) {
    return null_terminating_iterator(ptr_ - n, end_);
  }

  FMT_CONSTEXPR null_terminating_iterator operator+=(difference_type n) {
    ptr_ += n;
    return *this;
  }

  FMT_CONSTEXPR difference_type operator-(
      null_terminating_iterator other) const {
    return ptr_ - other.ptr_;
  }

  FMT_CONSTEXPR bool operator!=(null_terminating_iterator other) const {
    return ptr_ != other.ptr_;
  }

  @others
};

template &lt;typename T&gt;
FMT_CONSTEXPR const T *pointer_from(const T *p) { return p; }

template &lt;typename Char&gt;
FMT_CONSTEXPR const Char *pointer_from(null_terminating_iterator&lt;Char&gt; it) {
  return it.ptr_;
}

// An output iterator that counts the number of objects written to it and
// discards them.
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.259"> bool operator&gt;=(null_terminating_iterator other) const {
   return ptr_ &gt;= other.ptr_;
 }

 // This should be a friend specialization pointer_from&lt;Char&gt; but the latter
 // doesn't compile by gcc 5.1 due to a compiler bug.
 template &lt;typename CharT&gt;
 friend FMT_CONSTEXPR_DECL const CharT *pointer_from(
     null_terminating_iterator&lt;CharT&gt; it);

private:
 const Char *ptr_;
 const Char *end_;
</t>
<t tx="leo.20220407205633.26">@path ./v-rep_plugin/spdlog/details/
//
// Created by gabi on 6/15/18.
//

#pragma once

#include &lt;chrono&gt;
#include &lt;type_traits&gt;
#include "spdlog/fmt/fmt.h"

// Some fmt helpers to efficiently format and pad ints and strings
namespace spdlog {
namespace details {
namespace fmt_helper {

template&lt;size_t Buffer_Size&gt;
inline spdlog::string_view_t to_string_view(const fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;buf) SPDLOG_NOEXCEPT
{
    return spdlog::string_view_t(buf.data(), buf.size());
}

template&lt;size_t Buffer_Size1, size_t Buffer_Size2&gt;
inline void append_buf(const fmt::basic_memory_buffer&lt;char, Buffer_Size1&gt; &amp;buf, fmt::basic_memory_buffer&lt;char, Buffer_Size2&gt; &amp;dest)
{
    auto *buf_ptr = buf.data();
    dest.append(buf_ptr, buf_ptr + buf.size());
}

template&lt;size_t Buffer_Size&gt;
inline void append_string_view(spdlog::string_view_t view, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    auto *buf_ptr = view.data();
    if (buf_ptr != nullptr)
    {
        dest.append(buf_ptr, buf_ptr + view.size());
    }
}

template&lt;typename T, size_t Buffer_Size&gt;
inline void append_int(T n, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    fmt::format_int i(n);
    dest.append(i.data(), i.data() + i.size());
}

template&lt;typename T&gt;
inline unsigned count_digits(T n)
{
    using count_type = typename std::conditional&lt;(sizeof(T) &gt; sizeof(uint32_t)), uint64_t, uint32_t&gt;::type;
    return fmt::internal::count_digits(static_cast&lt;count_type&gt;(n));
}

template&lt;size_t Buffer_Size&gt;
inline void pad2(int n, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    if (n &gt; 99)
    {
        append_int(n, dest);
    }
    else if (n &gt; 9) // 10-99
    {
        dest.push_back(static_cast&lt;char&gt;('0' + n / 10));
        dest.push_back(static_cast&lt;char&gt;('0' + n % 10));
    }
    else if (n &gt;= 0) // 0-9
    {
        dest.push_back('0');
        dest.push_back(static_cast&lt;char&gt;('0' + n));
    }
    else // negatives (unlikely, but just in case, let fmt deal with it)
    {
        fmt::format_to(dest, "{:02}", n);
    }
}

template&lt;typename T, size_t Buffer_Size&gt;
inline void pad_uint(T n, unsigned int width, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    static_assert(std::is_unsigned&lt;T&gt;::value, "pad_uint must get unsigned T");
    auto digits = count_digits(n);
    if (width &gt; digits)
    {
        const char *zeroes = "0000000000000000000";
        dest.append(zeroes, zeroes + width - digits);
    }
    append_int(n, dest);
}

template&lt;typename T, size_t Buffer_Size&gt;
inline void pad3(T n, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    pad_uint(n, 3, dest);
}

template&lt;typename T, size_t Buffer_Size&gt;
inline void pad6(T n, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    pad_uint(n, 6, dest);
}

template&lt;typename T, size_t Buffer_Size&gt;
inline void pad9(T n, fmt::basic_memory_buffer&lt;char, Buffer_Size&gt; &amp;dest)
{
    pad_uint(n, 9, dest);
}

// return fraction of a second of the given time_point.
// e.g.
// fraction&lt;std::milliseconds&gt;(tp) -&gt; will return the millis part of the second
template&lt;typename ToDuration&gt;
inline ToDuration time_fraction(const log_clock::time_point &amp;tp)
{
    using std::chrono::duration_cast;
    using std::chrono::seconds;
    auto duration = tp.time_since_epoch();
    auto secs = duration_cast&lt;seconds&gt;(duration);
    return duration_cast&lt;ToDuration&gt;(duration) - duration_cast&lt;ToDuration&gt;(secs);
}

} // namespace fmt_helper
} // namespace details
} // namespace spdlog
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.260">class counting_iterator {
 private:
  std::size_t count_;
  mutable T blackhole_;

 public:
  typedef std::output_iterator_tag iterator_category;
  typedef T value_type;
  typedef std::ptrdiff_t difference_type;
  typedef T* pointer;
  typedef T&amp; reference;
  typedef counting_iterator _Unchecked_type;  // Mark iterator as checked.

  counting_iterator(): count_(0) {}

  std::size_t count() const { return count_; }

  counting_iterator&amp; operator++() {
    ++count_;
    return *this;
  }

  counting_iterator operator++(int) {
    auto it = *this;
    ++*this;
    return it;
  }

  T &amp;operator*() const { return blackhole_; }
};

// An output iterator that truncates the output and counts the number of objects
// written to it.
template &lt;typename OutputIt&gt;
</t>
<t tx="leo.20220407205633.261">class truncating_iterator {
 private:
  typedef std::iterator_traits&lt;OutputIt&gt; traits;

  OutputIt out_;
  std::size_t limit_;
  std::size_t count_;
  mutable typename traits::value_type blackhole_;

 public:
  typedef std::output_iterator_tag iterator_category;
  typedef typename traits::value_type value_type;
  typedef typename traits::difference_type difference_type;
  typedef typename traits::pointer pointer;
  typedef typename traits::reference reference;
  typedef truncating_iterator _Unchecked_type;  // Mark iterator as checked.

  truncating_iterator(OutputIt out, std::size_t limit)
    : out_(out), limit_(limit), count_(0) {}

  OutputIt base() const { return out_; }
  std::size_t count() const { return count_; }

  truncating_iterator&amp; operator++() {
    if (count_++ &lt; limit_)
      ++out_;
    return *this;
  }

  truncating_iterator operator++(int) {
    auto it = *this;
    ++*this;
    return it;
  }

  reference operator*() const { return count_ &lt; limit_ ? *out_ : blackhole_; }
};

// Returns true if value is negative, false otherwise.
// Same as (value &lt; 0) but doesn't produce warnings if T is an unsigned type.
template &lt;typename T&gt;
FMT_CONSTEXPR typename std::enable_if&lt;
    std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type is_negative(T value) {
  return value &lt; 0;
}
template &lt;typename T&gt;
FMT_CONSTEXPR typename std::enable_if&lt;
    !std::numeric_limits&lt;T&gt;::is_signed, bool&gt;::type is_negative(T) {
  return false;
}

template &lt;typename T&gt;
struct int_traits {
  // Smallest of uint32_t and uint64_t that is large enough to represent
  // all values of T.
</t>
<t tx="leo.20220407205633.262">  typedef typename std::conditional&lt;
    std::numeric_limits&lt;T&gt;::digits &lt;= 32, uint32_t, uint64_t&gt;::type main_type;
};

// Static data is placed in this class template to allow header-only
// configuration.
template &lt;typename T = void&gt;
struct FMT_API basic_data {
  static const uint32_t POWERS_OF_10_32[];
  static const uint32_t ZERO_OR_POWERS_OF_10_32[];
  static const uint64_t ZERO_OR_POWERS_OF_10_64[];
  static const uint64_t POW10_SIGNIFICANDS[];
  static const int16_t POW10_EXPONENTS[];
  static const char DIGITS[];
  static const char RESET_COLOR[];
  static const wchar_t WRESET_COLOR[];
};

#if FMT_USE_EXTERN_TEMPLATES
extern template struct basic_data&lt;void&gt;;
#endif

typedef basic_data&lt;&gt; data;

#ifdef FMT_BUILTIN_CLZLL
// Returns the number of decimal digits in n. Leading zeros are not counted
// except for n == 0 in which case count_digits returns 1.
inline unsigned count_digits(uint64_t n) {
  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.
  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 &gt;&gt; 12;
  return to_unsigned(t) - (n &lt; data::ZERO_OR_POWERS_OF_10_64[t]) + 1;
}
#else
// Fallback version of count_digits used when __builtin_clz is not available.
inline unsigned count_digits(uint64_t n) {
  unsigned count = 1;
  for (;;) {
    // Integer division is slow so do it for a group of four digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    if (n &lt; 10) return count;
    if (n &lt; 100) return count + 1;
    if (n &lt; 1000) return count + 2;
    if (n &lt; 10000) return count + 3;
    n /= 10000u;
    count += 4;
  }
}
#endif

// Counts the number of code points in a UTF-8 string.
FMT_API size_t count_code_points(u8string_view s);

#if FMT_HAS_CPP_ATTRIBUTE(always_inline)
# define FMT_ALWAYS_INLINE __attribute__((always_inline))
#else
# define FMT_ALWAYS_INLINE
#endif

template &lt;typename Handler&gt;
inline char *lg(uint32_t n, Handler h) FMT_ALWAYS_INLINE;

// Computes g = floor(log10(n)) and calls h.on&lt;g&gt;(n);
template &lt;typename Handler&gt;
inline char *lg(uint32_t n, Handler h) {
  return n &lt; 100 ? n &lt; 10 ? h.template on&lt;0&gt;(n) : h.template on&lt;1&gt;(n)
                 : n &lt; 1000000
                       ? n &lt; 10000 ? n &lt; 1000 ? h.template on&lt;2&gt;(n)
                                              : h.template on&lt;3&gt;(n)
                                   : n &lt; 100000 ? h.template on&lt;4&gt;(n)
                                                : h.template on&lt;5&gt;(n)
                       : n &lt; 100000000 ? n &lt; 10000000 ? h.template on&lt;6&gt;(n)
                                                      : h.template on&lt;7&gt;(n)
                                       : n &lt; 1000000000 ? h.template on&lt;8&gt;(n)
                                                        : h.template on&lt;9&gt;(n);
}

// An lg handler that formats a decimal number.
// Usage: lg(n, decimal_formatter(buffer));
</t>
<t tx="leo.20220407205633.263">class decimal_formatter {
 private:
  char *buffer_;

  @others
};

// An lg handler that formats a decimal number with a terminating null.
</t>
<t tx="leo.20220407205633.264"> void write_pair(unsigned N, uint32_t index) {
   std::memcpy(buffer_ + N, data::DIGITS + index * 2, 2);
 }

public:
 explicit decimal_formatter(char *buf) : buffer_(buf) {}

 template &lt;unsigned N&gt; char *on(uint32_t u) {
   if (N == 0) {
     *buffer_ = static_cast&lt;char&gt;(u) + '0';
   } else if (N == 1) {
     write_pair(0, u);
   } else {
     // The idea of using 4.32 fixed-point numbers is based on
     // https://github.com/jeaiii/itoa
     unsigned n = N - 1;
     unsigned a = n / 5 * n * 53 / 16;
     uint64_t t = ((1ULL &lt;&lt; (32 + a)) /
                  data::ZERO_OR_POWERS_OF_10_32[n] + 1 - n / 9);
     t = ((t * u) &gt;&gt; a) + n / 5 * 4;
     write_pair(0, t &gt;&gt; 32);
     for (unsigned i = 2; i &lt; N; i += 2) {
       t = 100ULL * static_cast&lt;uint32_t&gt;(t);
       write_pair(i, t &gt;&gt; 32);
     }
     if (N % 2 == 0) {
       buffer_[N] = static_cast&lt;char&gt;(
         (10ULL * static_cast&lt;uint32_t&gt;(t)) &gt;&gt; 32) + '0';
     }
   }
   return buffer_ += N + 1;
 }
</t>
<t tx="leo.20220407205633.265">class decimal_formatter_null : public decimal_formatter {
 public:
  explicit decimal_formatter_null(char *buf) : decimal_formatter(buf) {}

  template &lt;unsigned N&gt; char *on(uint32_t u) {
    char *buf = decimal_formatter::on&lt;N&gt;(u);
    *buf = '\0';
    return buf;
  }
};

#ifdef FMT_BUILTIN_CLZ
// Optional version of count_digits for better performance on 32-bit platforms.
inline unsigned count_digits(uint32_t n) {
  int t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 &gt;&gt; 12;
  return to_unsigned(t) - (n &lt; data::ZERO_OR_POWERS_OF_10_32[t]) + 1;
}
#endif

// A functor that doesn't add a thousands separator.
struct no_thousands_sep {
  typedef char char_type;

  template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.266">  void operator()(Char *) {}
};

// A functor that adds a thousands separator.
template &lt;typename Char&gt;
class add_thousands_sep {
 private:
  basic_string_view&lt;Char&gt; sep_;

  // Index of a decimal digit with the least significant digit having index 0.
  unsigned digit_index_;

 public:
  typedef Char char_type;

  explicit add_thousands_sep(basic_string_view&lt;Char&gt; sep)
    : sep_(sep), digit_index_(0) {}

</t>
<t tx="leo.20220407205633.267">  void operator()(Char *&amp;buffer) {
    if (++digit_index_ % 3 != 0)
      return;
    buffer -= sep_.size();
    std::uninitialized_copy(sep_.data(), sep_.data() + sep_.size(),
                            internal::make_checked(buffer, sep_.size()));
  }
};

template &lt;typename Char&gt;
FMT_API Char thousands_sep(locale_provider *lp);

// Formats a decimal unsigned integer value writing into buffer.
// thousands_sep is a functor that is called after writing each char to
// add a thousands separator if necessary.
template &lt;typename UInt, typename Char, typename ThousandsSep&gt;
inline Char *format_decimal(Char *buffer, UInt value, unsigned num_digits,
                            ThousandsSep thousands_sep) {
  buffer += num_digits;
  Char *end = buffer;
  while (value &gt;= 100) {
    // Integer division is slow so do it for a group of two digits instead
    // of for every digit. The idea comes from the talk by Alexandrescu
    // "Three Optimization Tips for C++". See speed-test for a comparison.
    unsigned index = static_cast&lt;unsigned&gt;((value % 100) * 2);
    value /= 100;
    *--buffer = data::DIGITS[index + 1];
    thousands_sep(buffer);
    *--buffer = data::DIGITS[index];
    thousands_sep(buffer);
  }
  if (value &lt; 10) {
    *--buffer = static_cast&lt;char&gt;('0' + value);
    return end;
  }
  unsigned index = static_cast&lt;unsigned&gt;(value * 2);
  *--buffer = data::DIGITS[index + 1];
  thousands_sep(buffer);
  *--buffer = data::DIGITS[index];
  return end;
}

template &lt;typename UInt, typename Iterator, typename ThousandsSep&gt;
inline Iterator format_decimal(
    Iterator out, UInt value, unsigned num_digits, ThousandsSep sep) {
  typedef typename ThousandsSep::char_type char_type;
  // Buffer should be large enough to hold all digits (digits10 + 1) and null.
  char_type buffer[std::numeric_limits&lt;UInt&gt;::digits10 + 2];
  format_decimal(buffer, value, num_digits, sep);
  return std::copy_n(buffer, num_digits, out);
}

template &lt;typename It, typename UInt&gt;
inline It format_decimal(It out, UInt value, unsigned num_digits) {
  return format_decimal(out, value, num_digits, no_thousands_sep());
}

template &lt;unsigned BASE_BITS, typename Char, typename UInt&gt;
inline Char *format_uint(Char *buffer, UInt value, unsigned num_digits,
</t>
<t tx="leo.20220407205633.268">                         bool upper = false) {
  buffer += num_digits;
  Char *end = buffer;
  do {
    const char *digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
    unsigned digit = (value &amp; ((1 &lt;&lt; BASE_BITS) - 1));
    *--buffer = BASE_BITS &lt; 4 ? static_cast&lt;char&gt;('0' + digit) : digits[digit];
  } while ((value &gt;&gt;= BASE_BITS) != 0);
  return end;
}

template &lt;unsigned BASE_BITS, typename It, typename UInt&gt;
inline It format_uint(It out, UInt value, unsigned num_digits,
</t>
<t tx="leo.20220407205633.269">                      bool upper = false) {
  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1)
  // and null.
  char buffer[std::numeric_limits&lt;UInt&gt;::digits / BASE_BITS + 2];
  format_uint&lt;BASE_BITS&gt;(buffer, value, num_digits, upper);
  return std::copy_n(buffer, num_digits, out);
}

#ifndef _WIN32
# define FMT_USE_WINDOWS_H 0
#elif !defined(FMT_USE_WINDOWS_H)
# define FMT_USE_WINDOWS_H 1
#endif

// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.
// All the functionality that relies on it will be disabled too.
#if FMT_USE_WINDOWS_H
// A converter from UTF-8 to UTF-16.
// It is only provided for Windows since other systems support UTF-8 natively.
</t>
<t tx="leo.20220407205633.27">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include "spdlog/common.h"
#include "spdlog/details/os.h"

#include &lt;string&gt;
#include &lt;utility&gt;

namespace spdlog {
namespace details {
struct log_msg
{

    log_msg(source_loc loc, const std::string *loggers_name, level::level_enum lvl, string_view_t view)
        : logger_name(loggers_name)
        , level(lvl)
#ifndef SPDLOG_NO_DATETIME
        , time(os::now())
#endif

#ifndef SPDLOG_NO_THREAD_ID
        , thread_id(os::thread_id())
        , source(loc)
        , payload(view)
#endif
    {
    }

    log_msg(const std::string *loggers_name, level::level_enum lvl, string_view_t view)
        : log_msg(source_loc{}, loggers_name, lvl, view)
    {
    }

    log_msg(const log_msg &amp;other) = default;

    const std::string *logger_name{nullptr};
    level::level_enum level{level::off};
    log_clock::time_point time;
    size_t thread_id{0};
    size_t msg_id{0};

    // wrapping the formatted text with color (updated by pattern_formatter).
    mutable size_t color_range_start{0};
    mutable size_t color_range_end{0};

    source_loc source;
    const string_view_t payload;
};
} // namespace details
} // namespace spdlog
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.270">class utf8_to_utf16 {
 private:
  wmemory_buffer buffer_;

 public:
  FMT_API explicit utf8_to_utf16(string_view s);
  operator wstring_view() const { return wstring_view(&amp;buffer_[0], size()); }
  size_t size() const { return buffer_.size() - 1; }
  const wchar_t *c_str() const { return &amp;buffer_[0]; }
  std::wstring str() const { return std::wstring(&amp;buffer_[0], size()); }
};

// A converter from UTF-16 to UTF-8.
// It is only provided for Windows since other systems support UTF-8 natively.
</t>
<t tx="leo.20220407205633.271">class utf16_to_utf8 {
 private:
  memory_buffer buffer_;

 public:
  utf16_to_utf8() {}
  FMT_API explicit utf16_to_utf8(wstring_view s);
  operator string_view() const { return string_view(&amp;buffer_[0], size()); }
  size_t size() const { return buffer_.size() - 1; }
  const char *c_str() const { return &amp;buffer_[0]; }
  std::string str() const { return std::string(&amp;buffer_[0], size()); }

  // Performs conversion returning a system error code instead of
  // throwing exception on conversion error. This method may still throw
  // in case of memory allocation error.
  FMT_API int convert(wstring_view s);
};

FMT_API void format_windows_error(fmt::internal::buffer &amp;out, int error_code,
                                  fmt::string_view message) FMT_NOEXCEPT;
#endif

template &lt;typename T = void&gt;
struct null {};
}  // namespace internal

enum alignment {
  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC
};

// Flags.
enum {SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8};

enum format_spec_tag {fill_tag, align_tag, width_tag, type_tag};

// Format specifier.
template &lt;typename T, format_spec_tag&gt;
</t>
<t tx="leo.20220407205633.272">class format_spec {
 private:
  T value_;

 public:
  typedef T value_type;

  explicit format_spec(T value) : value_(value) {}

  T value() const { return value_; }
};

// template &lt;typename Char&gt;
// typedef format_spec&lt;Char, fill_tag&gt; fill_spec;
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.273">class fill_spec : public format_spec&lt;Char, fill_tag&gt; {
 public:
  explicit fill_spec(Char value) : format_spec&lt;Char, fill_tag&gt;(value) {}
};

typedef format_spec&lt;unsigned, width_tag&gt; width_spec;
typedef format_spec&lt;char, type_tag&gt; type_spec;

// An empty format specifier.
struct empty_spec {};

// An alignment specifier.
struct align_spec : empty_spec {
  unsigned width_;
  // Fill is always wchar_t and cast to char if necessary to avoid having
  // two specialization of AlignSpec and its subclasses.
  wchar_t fill_;
  alignment align_;

  FMT_CONSTEXPR align_spec(
      unsigned width, wchar_t fill, alignment align = ALIGN_DEFAULT)
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.274">class basic_format_specs : public align_spec {
 public:
  unsigned flags_;
  int precision_;
  Char type_;

  FMT_CONSTEXPR basic_format_specs(
      unsigned width = 0, char type = 0, wchar_t fill = ' ')
FMT_CONSTEXPR unsigned basic_parse_context&lt;Char, ErrorHandler&gt;::next_arg_id() {
  if (next_arg_id_ &gt;= 0)
    return internal::to_unsigned(next_arg_id_++);
  on_error("cannot switch from manual to automatic argument indexing");
  return 0;
}

namespace internal {

template &lt;typename S&gt;
struct format_string_traits&lt;
  S, typename std::enable_if&lt;std::is_base_of&lt;compile_string, S&gt;::value&gt;::type&gt;:
    format_string_traits_base&lt;char&gt; {};

template &lt;typename Char, typename Handler&gt;
FMT_CONSTEXPR void handle_int_type_spec(Char spec, Handler &amp;&amp;handler) {
  switch (spec) {
  case 0: case 'd':
    handler.on_dec();
    break;
  case 'x': case 'X':
    handler.on_hex();
    break;
  case 'b': case 'B':
    handler.on_bin();
    break;
  case 'o':
    handler.on_oct();
    break;
  case 'n':
    handler.on_num();
    break;
  default:
    handler.on_error();
  }
}

template &lt;typename Char, typename Handler&gt;
FMT_CONSTEXPR void handle_float_type_spec(Char spec, Handler &amp;&amp;handler) {
  switch (spec) {
  case 0: case 'g': case 'G':
    handler.on_general();
    break;
  case 'e': case 'E':
    handler.on_exp();
    break;
  case 'f': case 'F':
    handler.on_fixed();
    break;
   case 'a': case 'A':
    handler.on_hex();
    break;
  default:
    handler.on_error();
    break;
  }
}

template &lt;typename Char, typename Handler&gt;
FMT_CONSTEXPR void handle_char_specs(
</t>
<t tx="leo.20220407205633.275">    const basic_format_specs&lt;Char&gt; *specs, Handler &amp;&amp;handler) {
  if (!specs) return handler.on_char();
  if (specs-&gt;type() &amp;&amp; specs-&gt;type() != 'c') return handler.on_int();
  if (specs-&gt;align() == ALIGN_NUMERIC || specs-&gt;flag(~0u) != 0)
    handler.on_error("invalid format specifier for char");
  handler.on_char();
}

template &lt;typename Char, typename Handler&gt;
FMT_CONSTEXPR void handle_cstring_type_spec(Char spec, Handler &amp;&amp;handler) {
  if (spec == 0 || spec == 's')
    handler.on_string();
  else if (spec == 'p')
    handler.on_pointer();
  else
    handler.on_error("invalid type specifier");
}

template &lt;typename Char, typename ErrorHandler&gt;
FMT_CONSTEXPR void check_string_type_spec(Char spec, ErrorHandler &amp;&amp;eh) {
  if (spec != 0 &amp;&amp; spec != 's')
    eh.on_error("invalid type specifier");
}

template &lt;typename Char, typename ErrorHandler&gt;
FMT_CONSTEXPR void check_pointer_type_spec(Char spec, ErrorHandler &amp;&amp;eh) {
  if (spec != 0 &amp;&amp; spec != 'p')
    eh.on_error("invalid type specifier");
}

template &lt;typename ErrorHandler&gt;
</t>
<t tx="leo.20220407205633.276">class int_type_checker : private ErrorHandler {
 public:
  FMT_CONSTEXPR explicit int_type_checker(ErrorHandler eh) : ErrorHandler(eh) {}

  FMT_CONSTEXPR void on_dec() {}
  FMT_CONSTEXPR void on_hex() {}
  FMT_CONSTEXPR void on_bin() {}
  FMT_CONSTEXPR void on_oct() {}
  FMT_CONSTEXPR void on_num() {}

  FMT_CONSTEXPR void on_error() {
    ErrorHandler::on_error("invalid type specifier");
  }
};

template &lt;typename ErrorHandler&gt;
</t>
<t tx="leo.20220407205633.277">class float_type_checker : private ErrorHandler {
 public:
  FMT_CONSTEXPR explicit float_type_checker(ErrorHandler eh)
    : ErrorHandler(eh) {}

  FMT_CONSTEXPR void on_general() {}
  FMT_CONSTEXPR void on_exp() {}
  FMT_CONSTEXPR void on_fixed() {}
  FMT_CONSTEXPR void on_hex() {}

  FMT_CONSTEXPR void on_error() {
    ErrorHandler::on_error("invalid type specifier");
  }
};

template &lt;typename ErrorHandler, typename CharType&gt;
</t>
<t tx="leo.20220407205633.278">class char_specs_checker : public ErrorHandler {
 private:
  CharType type_;

 public:
  FMT_CONSTEXPR char_specs_checker(CharType type, ErrorHandler eh)
    : ErrorHandler(eh), type_(type) {}

  FMT_CONSTEXPR void on_int() {
    handle_int_type_spec(type_, int_type_checker&lt;ErrorHandler&gt;(*this));
  }
  FMT_CONSTEXPR void on_char() {}
};

template &lt;typename ErrorHandler&gt;
</t>
<t tx="leo.20220407205633.279">class cstring_type_checker : public ErrorHandler {
 public:
  FMT_CONSTEXPR explicit cstring_type_checker(ErrorHandler eh)
    : ErrorHandler(eh) {}

  FMT_CONSTEXPR void on_string() {}
  FMT_CONSTEXPR void on_pointer() {}
};

template &lt;typename Context&gt;
</t>
<t tx="leo.20220407205633.28">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include "spdlog/details/fmt_helper.h"

#include &lt;memory&gt;
#include &lt;string&gt;

#define SPDLOG_CATCH_AND_HANDLE                                                                                                            \
    catch (const std::exception &amp;ex)                                                                                                       \
    {                                                                                                                                      \
        err_handler_(ex.what());                                                                                                           \
    }                                                                                                                                      \
    catch (...)                                                                                                                            \
    {                                                                                                                                      \
        err_handler_("Unknown exception in logger");                                                                                       \
    }

// create logger with given name, sinks and the default pattern formatter
// all other ctors will call this one
template&lt;typename It&gt;
inline spdlog::logger::logger(std::string logger_name, It begin, It end)
    : name_(std::move(logger_name))
    , sinks_(begin, end)
{
}

// ctor with sinks as init list
inline spdlog::logger::logger(std::string logger_name, sinks_init_list sinks_list)
    : logger(std::move(logger_name), sinks_list.begin(), sinks_list.end())
{
}

// ctor with single sink
inline spdlog::logger::logger(std::string logger_name, spdlog::sink_ptr single_sink)
    : logger(std::move(logger_name), {std::move(single_sink)})
{
}

inline spdlog::logger::~logger() = default;

inline void spdlog::logger::set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; f)
{
    for (auto &amp;sink : sinks_)
    {
        sink-&gt;set_formatter(f-&gt;clone());
    }
}

inline void spdlog::logger::set_pattern(std::string pattern, pattern_time_type time_type)
{
    auto new_formatter = details::make_unique&lt;spdlog::pattern_formatter&gt;(std::move(pattern), time_type);
    set_formatter(std::move(new_formatter));
}

template&lt;typename... Args&gt;
inline void spdlog::logger::log(source_loc source, level::level_enum lvl, const char *fmt, const Args &amp;... args)
{
    if (!should_log(lvl))
    {
        return;
    }

    try
    {
        using details::fmt_helper::to_string_view;
        fmt::memory_buffer buf;
        fmt::format_to(buf, fmt, args...);
        details::log_msg log_msg(source, &amp;name_, lvl, to_string_view(buf));
        sink_it_(log_msg);
    }
    SPDLOG_CATCH_AND_HANDLE
}

template&lt;typename... Args&gt;
inline void spdlog::logger::log(level::level_enum lvl, const char *fmt, const Args &amp;... args)
{
    log(source_loc{}, lvl, fmt, args...);
}

inline void spdlog::logger::log(source_loc source, level::level_enum lvl, const char *msg)
{
    if (!should_log(lvl))
    {
        return;
    }

    try
    {
        details::log_msg log_msg(source, &amp;name_, lvl, spdlog::string_view_t(msg));
        sink_it_(log_msg);
    }
    SPDLOG_CATCH_AND_HANDLE
}

inline void spdlog::logger::log(level::level_enum lvl, const char *msg)
{
    log(source_loc{}, lvl, msg);
}

template&lt;class T, typename std::enable_if&lt;std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type *&gt;
inline void spdlog::logger::log(source_loc source, level::level_enum lvl, const T &amp;msg)
{
    if (!should_log(lvl))
    {
        return;
    }
    try
    {
        details::log_msg log_msg(source, &amp;name_, lvl, msg);
        sink_it_(log_msg);
    }
    SPDLOG_CATCH_AND_HANDLE
}

template&lt;class T, typename std::enable_if&lt;std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type *&gt;
inline void spdlog::logger::log(level::level_enum lvl, const T &amp;msg)
{
    log(source_loc{}, lvl, msg);
}

template&lt;class T, typename std::enable_if&lt;!std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type *&gt;
inline void spdlog::logger::log(source_loc source, level::level_enum lvl, const T &amp;msg)
{
    if (!should_log(lvl))
    {
        return;
    }
    try
    {
        using details::fmt_helper::to_string_view;
        fmt::memory_buffer buf;
        fmt::format_to(buf, "{}", msg);
        details::log_msg log_msg(source, &amp;name_, lvl, to_string_view(buf));
        sink_it_(log_msg);
    }
    SPDLOG_CATCH_AND_HANDLE
}

template&lt;class T, typename std::enable_if&lt;!std::is_convertible&lt;T, spdlog::string_view_t&gt;::value, T&gt;::type *&gt;
inline void spdlog::logger::log(level::level_enum lvl, const T &amp;msg)
{
    log(source_loc{}, lvl, msg);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::trace(const char *fmt, const Args &amp;... args)
{
    log(level::trace, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::debug(const char *fmt, const Args &amp;... args)
{
    log(level::debug, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::info(const char *fmt, const Args &amp;... args)
{
    log(level::info, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::warn(const char *fmt, const Args &amp;... args)
{
    log(level::warn, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::error(const char *fmt, const Args &amp;... args)
{
    log(level::err, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::critical(const char *fmt, const Args &amp;... args)
{
    log(level::critical, fmt, args...);
}

template&lt;typename T&gt;
inline void spdlog::logger::trace(const T &amp;msg)
{
    log(level::trace, msg);
}

template&lt;typename T&gt;
inline void spdlog::logger::debug(const T &amp;msg)
{
    log(level::debug, msg);
}

template&lt;typename T&gt;
inline void spdlog::logger::info(const T &amp;msg)
{
    log(level::info, msg);
}

template&lt;typename T&gt;
inline void spdlog::logger::warn(const T &amp;msg)
{
    log(level::warn, msg);
}

template&lt;typename T&gt;
inline void spdlog::logger::error(const T &amp;msg)
{
    log(level::err, msg);
}

template&lt;typename T&gt;
inline void spdlog::logger::critical(const T &amp;msg)
{
    log(level::critical, msg);
}

#ifdef SPDLOG_WCHAR_TO_UTF8_SUPPORT

inline void wbuf_to_utf8buf(const fmt::wmemory_buffer &amp;wbuf, fmt::memory_buffer &amp;target)
{
    int wbuf_size = static_cast&lt;int&gt;(wbuf.size());
    if (wbuf_size == 0)
    {
        return;
    }

    auto result_size = ::WideCharToMultiByte(CP_UTF8, 0, wbuf.data(), wbuf_size, NULL, 0, NULL, NULL);

    if (result_size &gt; 0)
    {
        target.resize(result_size);
        ::WideCharToMultiByte(CP_UTF8, 0, wbuf.data(), wbuf_size, &amp;target.data()[0], result_size, NULL, NULL);
    }
    else
    {
        throw spdlog::spdlog_ex(fmt::format("WideCharToMultiByte failed. Last error: {}", ::GetLastError()));
    }
}

template&lt;typename... Args&gt;
inline void spdlog::logger::log(source_loc source, level::level_enum lvl, const wchar_t *fmt, const Args &amp;... args)
{
    if (!should_log(lvl))
    {
        return;
    }

    try
    {
        // format to wmemory_buffer and convert to utf8
        using details::fmt_helper::to_string_view;
        fmt::wmemory_buffer wbuf;
        fmt::format_to(wbuf, fmt, args...);
        fmt::memory_buffer buf;
        wbuf_to_utf8buf(wbuf, buf);
        details::log_msg log_msg(source, &amp;name_, lvl, to_string_view(buf));
        sink_it_(log_msg);
    }
    SPDLOG_CATCH_AND_HANDLE
}

template&lt;typename... Args&gt;
inline void spdlog::logger::log(level::level_enum lvl, const wchar_t *fmt, const Args &amp;... args)
{
    log(source_loc{}, lvl, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::trace(const wchar_t *fmt, const Args &amp;... args)
{
    log(level::trace, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::debug(const wchar_t *fmt, const Args &amp;... args)
{
    log(level::debug, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::info(const wchar_t *fmt, const Args &amp;... args)
{
    log(level::info, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::warn(const wchar_t *fmt, const Args &amp;... args)
{
    log(level::warn, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::error(const wchar_t *fmt, const Args &amp;... args)
{
    log(level::err, fmt, args...);
}

template&lt;typename... Args&gt;
inline void spdlog::logger::critical(const wchar_t *fmt, const Args &amp;... args)
{
    log(level::critical, fmt, args...);
}

#endif // SPDLOG_WCHAR_TO_UTF8_SUPPORT

//
// name and level
//
inline const std::string &amp;spdlog::logger::name() const
{
    return name_;
}

inline void spdlog::logger::set_level(spdlog::level::level_enum log_level)
{
    level_.store(log_level);
}

inline void spdlog::logger::set_error_handler(spdlog::log_err_handler err_handler)
{
    err_handler_ = std::move(err_handler);
}

inline spdlog::log_err_handler spdlog::logger::error_handler() const
{
    return err_handler_;
}

inline void spdlog::logger::flush()
{
    try
    {
        flush_();
    }
    SPDLOG_CATCH_AND_HANDLE
}

inline void spdlog::logger::flush_on(level::level_enum log_level)
{
    flush_level_.store(log_level);
}

inline spdlog::level::level_enum spdlog::logger::flush_level() const
{
    return static_cast&lt;spdlog::level::level_enum&gt;(flush_level_.load(std::memory_order_relaxed));
}

inline bool spdlog::logger::should_flush_(const details::log_msg &amp;msg)
{
    auto flush_level = flush_level_.load(std::memory_order_relaxed);
    return (msg.level &gt;= flush_level) &amp;&amp; (msg.level != level::off);
}

inline spdlog::level::level_enum spdlog::logger::default_level()
{
    return static_cast&lt;spdlog::level::level_enum&gt;(SPDLOG_ACTIVE_LEVEL);
}

inline spdlog::level::level_enum spdlog::logger::level() const
{
    return static_cast&lt;spdlog::level::level_enum&gt;(level_.load(std::memory_order_relaxed));
}

inline bool spdlog::logger::should_log(spdlog::level::level_enum msg_level) const
{
    return msg_level &gt;= level_.load(std::memory_order_relaxed);
}

//
// protected virtual called at end of each user log call (if enabled) by the
// line_logger
//
inline void spdlog::logger::sink_it_(details::log_msg &amp;msg)
{
#if defined(SPDLOG_ENABLE_MESSAGE_COUNTER)
    incr_msg_counter_(msg);
#endif
    for (auto &amp;sink : sinks_)
    {
        if (sink-&gt;should_log(msg.level))
        {
            sink-&gt;log(msg);
        }
    }

    if (should_flush_(msg))
    {
        flush_();
    }
}

inline void spdlog::logger::flush_()
{
    for (auto &amp;sink : sinks_)
    {
        sink-&gt;flush();
    }
}

inline void spdlog::logger::default_err_handler_(const std::string &amp;msg)
{
    auto now = time(nullptr);
    if (now - last_err_time_ &lt; 60)
    {
        return;
    }
    last_err_time_ = now;
    auto tm_time = details::os::localtime(now);
    char date_buf[100];
    std::strftime(date_buf, sizeof(date_buf), "%Y-%m-%d %H:%M:%S", &amp;tm_time);
    fmt::print(stderr, "[*** LOG ERROR ***] [{}] [{}] {}\n", date_buf, name(), msg);
}

inline void spdlog::logger::incr_msg_counter_(details::log_msg &amp;msg)
{
    msg.msg_id = msg_counter_.fetch_add(1, std::memory_order_relaxed);
}

inline const std::vector&lt;spdlog::sink_ptr&gt; &amp;spdlog::logger::sinks() const
{
    return sinks_;
}

inline std::vector&lt;spdlog::sink_ptr&gt; &amp;spdlog::logger::sinks()
{
    return sinks_;
}

inline std::shared_ptr&lt;spdlog::logger&gt; spdlog::logger::clone(std::string logger_name)
{
    auto cloned = std::make_shared&lt;spdlog::logger&gt;(std::move(logger_name), sinks_.begin(), sinks_.end());
    cloned-&gt;set_level(this-&gt;level());
    cloned-&gt;flush_on(this-&gt;flush_level());
    cloned-&gt;set_error_handler(this-&gt;error_handler());
    return cloned;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.280">void arg_map&lt;Context&gt;::init(const basic_format_args&lt;Context&gt; &amp;args) {
  if (map_)
    return;
  map_ = new entry[args.max_size()];
  bool use_values = args.type(max_packed_args - 1) == internal::none_type;
  if (use_values) {
    for (unsigned i = 0;/*nothing*/; ++i) {
      internal::type arg_type = args.type(i);
      switch (arg_type) {
        case internal::none_type:
          return;
        case internal::named_arg_type:
          push_back(args.values_[i]);
          break;
        default:
          break; // Do nothing.
      }
    }
  }
  for (unsigned i = 0; ; ++i) {
    switch (args.args_[i].type_) {
      case internal::none_type:
        return;
      case internal::named_arg_type:
        push_back(args.args_[i].value_);
        break;
      default:
        break; // Do nothing.
    }
  }
}

template &lt;typename Range&gt;
</t>
<t tx="leo.20220407205633.281">class arg_formatter_base {
 public:
  typedef typename Range::value_type char_type;
  typedef decltype(internal::declval&lt;Range&gt;().begin()) iterator;
  typedef basic_format_specs&lt;char_type&gt; format_specs;

 private:
  typedef basic_writer&lt;Range&gt; writer_type;
  writer_type writer_;
  format_specs *specs_;

  struct char_writer {
    char_type value;
    template &lt;typename It&gt;
    void operator()(It &amp;&amp;it) const { *it++ = value; }
  };

  @others
};

template &lt;typename Char&gt;
FMT_CONSTEXPR bool is_name_start(Char c) {
  return ('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || '_' == c;
}

// DEPRECATED: Parses the input as an unsigned integer. This function assumes
// that the first character is a digit and presence of a non-digit character at
// the end.
// it: an iterator pointing to the beginning of the input range.
template &lt;typename Iterator, typename ErrorHandler&gt;
FMT_CONSTEXPR unsigned parse_nonnegative_int(Iterator &amp;it, ErrorHandler &amp;&amp;eh) {
  assert('0' &lt;= *it &amp;&amp; *it &lt;= '9');
  unsigned value = 0;
  // Convert to unsigned to prevent a warning.
  unsigned max_int = (std::numeric_limits&lt;int&gt;::max)();
  unsigned big = max_int / 10;
  do {
    // Check for overflow.
    if (value &gt; big) {
      value = max_int + 1;
      break;
    }
    value = value * 10 + unsigned(*it - '0');
    // Workaround for MSVC "setup_exception stack overflow" error:
    auto next = it;
    ++next;
    it = next;
  } while ('0' &lt;= *it &amp;&amp; *it &lt;= '9');
  if (value &gt; max_int)
    eh.on_error("number is too big");
  return value;
}

// Parses the range [begin, end) as an unsigned integer. This function assumes
// that the range is non-empty and the first character is a digit.
template &lt;typename Char, typename ErrorHandler&gt;
FMT_CONSTEXPR unsigned parse_nonnegative_int(
</t>
<t tx="leo.20220407205633.282">void write_char(char_type value) {
  if (specs_)
    writer_.write_padded(1, *specs_, char_writer{value});
  else
    writer_.write(value);
}

</t>
<t tx="leo.20220407205633.283"> void write_pointer(const void *p) {
   format_specs specs = specs_ ? *specs_ : format_specs();
   specs.flags_ = HASH_FLAG;
   specs.type_ = 'x';
   writer_.write_int(reinterpret_cast&lt;uintptr_t&gt;(p), specs);
 }

protected:
 writer_type &amp;writer() { return writer_; }
 format_specs *spec() { return specs_; }
 iterator out() { return writer_.out(); }

</t>
<t tx="leo.20220407205633.284">void write(bool value) {
  string_view sv(value ? "true" : "false");
  specs_ ? writer_.write_str(sv, *specs_) : writer_.write(sv);
}

</t>
<t tx="leo.20220407205633.285"> void write(const char_type *value) {
   if (!value)
     FMT_THROW(format_error("string pointer is null"));
   auto length = std::char_traits&lt;char_type&gt;::length(value);
   basic_string_view&lt;char_type&gt; sv(value, length);
   specs_ ? writer_.write_str(sv, *specs_) : writer_.write(sv);
 }

public:
 arg_formatter_base(Range r, format_specs *s): writer_(r), specs_(s) {}

 iterator operator()(monostate) {
   FMT_ASSERT(false, "invalid argument type");
   return out();
 }

 template &lt;typename T&gt;
 typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, iterator&gt;::type
     operator()(T value) {
   // MSVC2013 fails to compile separate overloads for bool and char_type so
   // use std::is_same instead.
   if (std::is_same&lt;T, bool&gt;::value) {
     if (specs_ &amp;&amp; specs_-&gt;type_)
       return (*this)(value ? 1 : 0);
     write(value != 0);
   } else if (std::is_same&lt;T, char_type&gt;::value) {
     internal::handle_char_specs(
   writer_.write_double(value, specs_ ? *specs_ : format_specs());
   return out();
 }

 struct char_spec_handler : internal::error_handler {
   arg_formatter_base &amp;formatter;
   char_type value;

</t>
<t tx="leo.20220407205633.286">  char_spec_handler(arg_formatter_base&amp; f, char_type val)
    : formatter(f), value(val) {}

  void on_int() {
    if (formatter.specs_)
      formatter.writer_.write_int(value, *formatter.specs_);
    else
      formatter.writer_.write(value);
  }
  void on_char() { formatter.write_char(value); }
};

struct cstring_spec_handler : internal::error_handler {
  arg_formatter_base &amp;formatter;
  const char_type *value;

  cstring_spec_handler(arg_formatter_base &amp;f, const char_type *val)
    : formatter(f), value(val) {}

  void on_string() { formatter.write(value); }
  void on_pointer() { formatter.write_pointer(value); }
};

iterator operator()(const char_type *value) {
  if (!specs_) return write(value), out();
</t>
<t tx="leo.20220407205633.287">  internal::handle_cstring_type_spec(
        specs_-&gt;type_, cstring_spec_handler(*this, value));
  return out();
}

iterator operator()(basic_string_view&lt;char_type&gt; value) {
  if (specs_) {
    @others
</t>
<t tx="leo.20220407205633.288">    internal::check_string_type_spec(
          specs_-&gt;type_, internal::error_handler());
    writer_.write_str(value, *specs_);
  } else {
    writer_.write(value);
  }
  return out();
}

iterator operator()(const void *value) {
  if (specs_)
    check_pointer_type_spec(specs_-&gt;type_, internal::error_handler());
  write_pointer(value);
  return out();
}
</t>
<t tx="leo.20220407205633.289">    const Char *&amp;begin, const Char *end, ErrorHandler &amp;&amp;eh) {
  assert(begin != end &amp;&amp; '0' &lt;= *begin &amp;&amp; *begin &lt;= '9');
  unsigned value = 0;
  // Convert to unsigned to prevent a warning.
  unsigned max_int = (std::numeric_limits&lt;int&gt;::max)();
  unsigned big = max_int / 10;
  do {
    // Check for overflow.
    if (value &gt; big) {
      value = max_int + 1;
      break;
    }
    value = value * 10 + unsigned(*begin++ - '0');
  } while (begin != end &amp;&amp; '0' &lt;= *begin &amp;&amp; *begin &lt;= '9');
  if (value &gt; max_int)
    eh.on_error("number is too big");
  return value;
}

template &lt;typename Char, typename Context&gt;
</t>
<t tx="leo.20220407205633.29">@path ./v-rep_plugin/spdlog/details/
#pragma once

//
// Copyright(c) 2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

// multi producer-multi consumer blocking queue.
// enqueue(..) - will block until room found to put the new message.
// enqueue_nowait(..) - will return immediately with false if no room left in
// the queue.
// dequeue_for(..) - will block until the queue is not empty or timeout have
// passed.

#include "spdlog/details/circular_q.h"

#include &lt;condition_variable&gt;
#include &lt;mutex&gt;

namespace spdlog {
namespace details {

template&lt;typename T&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.290">class custom_formatter: public function&lt;bool&gt; {
 private:
  Context &amp;ctx_;

 public:
  explicit custom_formatter(Context &amp;ctx): ctx_(ctx) {}

  @others
};

template &lt;typename T&gt;
struct is_integer {
  enum {
    value = std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value &amp;&amp;
            !std::is_same&lt;T, char&gt;::value &amp;&amp; !std::is_same&lt;T, wchar_t&gt;::value
  };
};

template &lt;typename ErrorHandler&gt;
</t>
<t tx="leo.20220407205633.291">bool operator()(typename basic_format_arg&lt;Context&gt;::handle h) const {
  h.format(ctx_);
  return true;
}

template &lt;typename T&gt;
bool operator()(T) const { return false; }
</t>
<t tx="leo.20220407205633.292">class width_checker: public function&lt;unsigned long long&gt; {
 public:
  explicit FMT_CONSTEXPR width_checker(ErrorHandler &amp;eh) : handler_(eh) {}

  template &lt;typename T&gt;
  FMT_CONSTEXPR
  typename std::enable_if&lt;
      is_integer&lt;T&gt;::value, unsigned long long&gt;::type operator()(T value) {
    if (is_negative(value))
      handler_.on_error("negative width");
    return static_cast&lt;unsigned long long&gt;(value);
  }

  template &lt;typename T&gt;
  FMT_CONSTEXPR typename std::enable_if&lt;
      !is_integer&lt;T&gt;::value, unsigned long long&gt;::type operator()(T) {
    handler_.on_error("width is not integer");
    return 0;
  }

 private:
  ErrorHandler &amp;handler_;
};

template &lt;typename ErrorHandler&gt;
</t>
<t tx="leo.20220407205633.293">class precision_checker: public function&lt;unsigned long long&gt; {
 public:
  explicit FMT_CONSTEXPR precision_checker(ErrorHandler &amp;eh) : handler_(eh) {}

  template &lt;typename T&gt;
  FMT_CONSTEXPR typename std::enable_if&lt;
      is_integer&lt;T&gt;::value, unsigned long long&gt;::type operator()(T value) {
    if (is_negative(value))
      handler_.on_error("negative precision");
    return static_cast&lt;unsigned long long&gt;(value);
  }

  template &lt;typename T&gt;
  FMT_CONSTEXPR typename std::enable_if&lt;
      !is_integer&lt;T&gt;::value, unsigned long long&gt;::type operator()(T) {
    handler_.on_error("precision is not integer");
    return 0;
  }

 private:
  ErrorHandler &amp;handler_;
};

// A format specifier handler that sets fields in basic_format_specs.
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.294">class specs_setter {
 public:
  explicit FMT_CONSTEXPR specs_setter(basic_format_specs&lt;Char&gt; &amp;specs):
    specs_(specs) {}

  FMT_CONSTEXPR specs_setter(const specs_setter &amp;other) : specs_(other.specs_) {}

  FMT_CONSTEXPR void on_align(alignment align) { specs_.align_ = align; }
  FMT_CONSTEXPR void on_fill(Char fill) { specs_.fill_ = fill; }
  FMT_CONSTEXPR void on_plus() { specs_.flags_ |= SIGN_FLAG | PLUS_FLAG; }
  FMT_CONSTEXPR void on_minus() { specs_.flags_ |= MINUS_FLAG; }
  FMT_CONSTEXPR void on_space() { specs_.flags_ |= SIGN_FLAG; }
  FMT_CONSTEXPR void on_hash() { specs_.flags_ |= HASH_FLAG; }

  FMT_CONSTEXPR void on_zero() {
    specs_.align_ = ALIGN_NUMERIC;
    specs_.fill_ = '0';
  }

  FMT_CONSTEXPR void on_width(unsigned width) { specs_.width_ = width; }
  FMT_CONSTEXPR void on_precision(unsigned precision) {
    specs_.precision_ = static_cast&lt;int&gt;(precision);
  }
  FMT_CONSTEXPR void end_precision() {}

  FMT_CONSTEXPR void on_type(Char type) { specs_.type_ = type; }

 protected:
  basic_format_specs&lt;Char&gt; &amp;specs_;
};

// A format specifier handler that checks if specifiers are consistent with the
// argument type.
template &lt;typename Handler&gt;
</t>
<t tx="leo.20220407205633.295">class specs_checker : public Handler {
 public:
  FMT_CONSTEXPR specs_checker(const Handler&amp; handler, internal::type arg_type)
    : Handler(handler), arg_type_(arg_type) {}

  FMT_CONSTEXPR specs_checker(const specs_checker &amp;other)
    : Handler(other), arg_type_(other.arg_type_) {}

  FMT_CONSTEXPR void on_align(alignment align) {
    if (align == ALIGN_NUMERIC)
      require_numeric_argument();
    Handler::on_align(align);
  }

  FMT_CONSTEXPR void on_plus() {
    check_sign();
    Handler::on_plus();
  }

  FMT_CONSTEXPR void on_minus() {
    check_sign();
    Handler::on_minus();
  }

  FMT_CONSTEXPR void on_space() {
    check_sign();
    Handler::on_space();
  }

  FMT_CONSTEXPR void on_hash() {
    require_numeric_argument();
    Handler::on_hash();
  }

  FMT_CONSTEXPR void on_zero() {
    require_numeric_argument();
    Handler::on_zero();
  }

  FMT_CONSTEXPR void end_precision() {
    if (is_integral(arg_type_) || arg_type_ == pointer_type)
      this-&gt;on_error("precision not allowed for this argument type");
  }

 private:
  FMT_CONSTEXPR void require_numeric_argument() {
    if (!is_arithmetic(arg_type_))
      this-&gt;on_error("format specifier requires numeric argument");
  }

  FMT_CONSTEXPR void check_sign() {
    require_numeric_argument();
    if (is_integral(arg_type_) &amp;&amp; arg_type_ != int_type &amp;&amp;
        arg_type_ != long_long_type &amp;&amp; arg_type_ != internal::char_type) {
      this-&gt;on_error("format specifier requires signed argument");
    }
  }

  internal::type arg_type_;
};

template &lt;template &lt;typename&gt; class Handler, typename T,
          typename Context, typename ErrorHandler&gt;
FMT_CONSTEXPR void set_dynamic_spec(
    T &amp;value, basic_format_arg&lt;Context&gt; arg, ErrorHandler eh) {
  unsigned long long big_value = fmt::visit(Handler&lt;ErrorHandler&gt;(eh), arg);
  if (big_value &gt; (std::numeric_limits&lt;int&gt;::max)())
    eh.on_error("number is too big");
  value = static_cast&lt;T&gt;(big_value);
}

struct auto_id {};

// The standard format specifier handler with checking.
template &lt;typename Context&gt;
</t>
<t tx="leo.20220407205633.296">class specs_handler: public specs_setter&lt;typename Context::char_type&gt; {
 public:
  typedef typename Context::char_type char_type;

  FMT_CONSTEXPR specs_handler(
      basic_format_specs&lt;char_type&gt; &amp;specs, Context &amp;ctx)
    : specs_setter&lt;char_type&gt;(specs), context_(ctx) {}

  template &lt;typename Id&gt;
  FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
    set_dynamic_spec&lt;width_checker&gt;(
          this-&gt;specs_.width_, get_arg(arg_id), context_.error_handler());
  }

  template &lt;typename Id&gt;
  FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
    set_dynamic_spec&lt;precision_checker&gt;(
          this-&gt;specs_.precision_, get_arg(arg_id), context_.error_handler());
  }

  @others
};

// An argument reference.
template &lt;typename Char&gt;
struct arg_ref {
  enum Kind { NONE, INDEX, NAME };

  FMT_CONSTEXPR arg_ref() : kind(NONE), index(0) {}
  FMT_CONSTEXPR explicit arg_ref(unsigned index) : kind(INDEX), index(index) {}
  explicit arg_ref(basic_string_view&lt;Char&gt; name) : kind(NAME), name(name) {}

  FMT_CONSTEXPR arg_ref &amp;operator=(unsigned idx) {
    kind = INDEX;
    index = idx;
    return *this;
  }

  Kind kind;
  FMT_UNION {
    unsigned index;
    basic_string_view&lt;Char&gt; name;
  };
};

// Format specifiers with width and precision resolved at formatting rather
// than parsing time to allow re-using the same parsed specifiers with
// differents sets of arguments (precompilation of format strings).
template &lt;typename Char&gt;
struct dynamic_format_specs : basic_format_specs&lt;Char&gt; {
  arg_ref&lt;Char&gt; width_ref;
  arg_ref&lt;Char&gt; precision_ref;
};

// Format spec handler that saves references to arguments representing dynamic
// width and precision to be resolved at formatting time.
template &lt;typename ParseContext&gt;
</t>
<t tx="leo.20220407205633.297"> void on_error(const char *message) {
   context_.on_error(message);
 }

private:
 FMT_CONSTEXPR basic_format_arg&lt;Context&gt; get_arg(auto_id) {
   return context_.next_arg();
 }

 template &lt;typename Id&gt;
 FMT_CONSTEXPR basic_format_arg&lt;Context&gt; get_arg(Id arg_id) {
   context_.parse_context().check_arg_id(arg_id);
   return context_.get_arg(arg_id);
 }

 Context &amp;context_;
</t>
<t tx="leo.20220407205633.298">class dynamic_specs_handler :
    public specs_setter&lt;typename ParseContext::char_type&gt; {
 public:
  typedef typename ParseContext::char_type char_type;

  FMT_CONSTEXPR dynamic_specs_handler(
      dynamic_format_specs&lt;char_type&gt; &amp;specs, ParseContext &amp;ctx)
    : specs_setter&lt;char_type&gt;(specs), specs_(specs), context_(ctx) {}

  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler &amp;other)
    : specs_setter&lt;char_type&gt;(other),
      specs_(other.specs_), context_(other.context_) {}

  template &lt;typename Id&gt;
  FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
    specs_.width_ref = make_arg_ref(arg_id);
  }

  template &lt;typename Id&gt;
  FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
    specs_.precision_ref = make_arg_ref(arg_id);
  }

  FMT_CONSTEXPR void on_error(const char *message) {
    context_.on_error(message);
  }

 private:
  typedef arg_ref&lt;char_type&gt; arg_ref_type;

  template &lt;typename Id&gt;
  FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
    context_.check_arg_id(arg_id);
    return arg_ref_type(arg_id);
  }

  FMT_CONSTEXPR arg_ref_type make_arg_ref(auto_id) {
    return arg_ref_type(context_.next_arg_id());
  }

  dynamic_format_specs&lt;char_type&gt; &amp;specs_;
  ParseContext &amp;context_;
};

template &lt;typename Iterator, typename IDHandler&gt;
FMT_CONSTEXPR Iterator parse_arg_id(Iterator it, IDHandler &amp;&amp;handler) {
  typedef typename std::iterator_traits&lt;Iterator&gt;::value_type char_type;
  char_type c = *it;
  if (c == '}' || c == ':') {
    handler();
    return it;
  }
  if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
    unsigned index = parse_nonnegative_int(it, handler);
    if (*it != '}' &amp;&amp; *it != ':') {
      handler.on_error("invalid format string");
      return it;
    }
    handler(index);
    return it;
  }
  if (!is_name_start(c)) {
    handler.on_error("invalid format string");
    return it;
  }
  auto start = it;
  do {
    c = *++it;
  } while (is_name_start(c) || ('0' &lt;= c &amp;&amp; c &lt;= '9'));
  handler(basic_string_view&lt;char_type&gt;(
            pointer_from(start), to_unsigned(it - start)));
  return it;
}

template &lt;typename Char, typename IDHandler&gt;
FMT_CONSTEXPR const Char *parse_arg_id(
</t>
<t tx="leo.20220407205633.299">    const Char *begin, const Char *end, IDHandler &amp;&amp;handler) {
  assert(begin != end);
  Char c = *begin;
  if (c == '}' || c == ':')
    return handler(), begin;
  if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
    unsigned index = parse_nonnegative_int(begin, end, handler);
    if (begin == end || (*begin != '}' &amp;&amp; *begin != ':'))
      return handler.on_error("invalid format string"), begin;
    handler(index);
    return begin;
  }
  if (!is_name_start(c))
    return handler.on_error("invalid format string"), begin;
  auto it = begin;
  do {
    c = *++it;
  } while (it != end &amp;&amp; (is_name_start(c) || ('0' &lt;= c &amp;&amp; c &lt;= '9')));
  handler(basic_string_view&lt;Char&gt;(begin, to_unsigned(it - begin)));
  return it;
}

// Adapts SpecHandler to IDHandler API for dynamic width.
template &lt;typename SpecHandler, typename Char&gt;
struct width_adapter {
  explicit FMT_CONSTEXPR width_adapter(SpecHandler &amp;h) : handler(h) {}

  FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
  FMT_CONSTEXPR void operator()(unsigned id) { handler.on_dynamic_width(id); }
  FMT_CONSTEXPR void operator()(basic_string_view&lt;Char&gt; id) {
    handler.on_dynamic_width(id);
  }

  FMT_CONSTEXPR void on_error(const char *message) {
    handler.on_error(message);
  }

  SpecHandler &amp;handler;
};

// Adapts SpecHandler to IDHandler API for dynamic precision.
template &lt;typename SpecHandler, typename Char&gt;
struct precision_adapter {
  explicit FMT_CONSTEXPR precision_adapter(SpecHandler &amp;h) : handler(h) {}

  FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
  FMT_CONSTEXPR void operator()(unsigned id) {
    handler.on_dynamic_precision(id);
  }
  FMT_CONSTEXPR void operator()(basic_string_view&lt;Char&gt; id) {
    handler.on_dynamic_precision(id);
  }

  FMT_CONSTEXPR void on_error(const char *message) { handler.on_error(message); }

  SpecHandler &amp;handler;
};

// Parses standard format specifiers and sends notifications about parsed
// components to handler.
// it: an iterator pointing to the beginning of a null-terminated range of
//     characters, possibly emulated via null_terminating_iterator, representing
//     format specifiers.
template &lt;typename Iterator, typename SpecHandler&gt;
FMT_CONSTEXPR Iterator parse_format_specs(Iterator it, SpecHandler &amp;&amp;handler) {
  typedef typename std::iterator_traits&lt;Iterator&gt;::value_type char_type;
  char_type c = *it;
  if (c == '}' || !c)
    return it;

  // Parse fill and alignment.
  alignment align = ALIGN_DEFAULT;
  int i = 1;
  do {
    auto p = it + i;
    switch (*p) {
      case '&lt;':
        align = ALIGN_LEFT;
        break;
      case '&gt;':
        align = ALIGN_RIGHT;
        break;
      case '=':
        align = ALIGN_NUMERIC;
        break;
      case '^':
        align = ALIGN_CENTER;
        break;
    }
    if (align != ALIGN_DEFAULT) {
      if (p != it) {
        if (c == '{') {
          handler.on_error("invalid fill character '{'");
          return it;
        }
        it += 2;
        handler.on_fill(c);
      } else ++it;
      handler.on_align(align);
      break;
    }
  } while (--i &gt;= 0);

  // Parse sign.
  switch (*it) {
    case '+':
      handler.on_plus();
      ++it;
      break;
    case '-':
      handler.on_minus();
      ++it;
      break;
    case ' ':
      handler.on_space();
      ++it;
      break;
  }

  if (*it == '#') {
    handler.on_hash();
    ++it;
  }

  // Parse zero flag.
  if (*it == '0') {
    handler.on_zero();
    ++it;
  }

  // Parse width.
  if ('0' &lt;= *it &amp;&amp; *it &lt;= '9') {
    handler.on_width(parse_nonnegative_int(it, handler));
  } else if (*it == '{') {
    it = parse_arg_id(it + 1, width_adapter&lt;SpecHandler, char_type&gt;(handler));
    if (*it++ != '}') {
      handler.on_error("invalid format string");
      return it;
    }
  }

  // Parse precision.
  if (*it == '.') {
    ++it;
    if ('0' &lt;= *it &amp;&amp; *it &lt;= '9') {
      handler.on_precision(parse_nonnegative_int(it, handler));
    } else if (*it == '{') {
      it = parse_arg_id(
            it + 1, precision_adapter&lt;SpecHandler, char_type&gt;(handler));
      if (*it++ != '}') {
        handler.on_error("invalid format string");
        return it;
      }
    } else {
      handler.on_error("missing precision specifier");
      return it;
    }
    handler.end_precision();
  }

  // Parse type.
  if (*it != '}' &amp;&amp; *it)
    handler.on_type(*it++);
  return it;
}

// Return the result via the out param to workaround gcc bug 77539.
template &lt;bool IS_CONSTEXPR, typename T, typename Ptr = const T*&gt;
FMT_CONSTEXPR bool find(Ptr first, Ptr last, T value, Ptr &amp;out) {
  for (out = first; out != last; ++out) {
    if (*out == value)
      return true;
  }
  return false;
}

template &lt;&gt;
inline bool find&lt;false, char&gt;(
</t>
<t tx="leo.20220407205633.3">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

// cirucal q view of std::vector.
#pragma once

#include &lt;vector&gt;

namespace spdlog {
namespace details {
template&lt;typename T&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.30">class mpmc_blocking_queue
{
public:
    using item_type = T;
    explicit mpmc_blocking_queue(size_t max_items)
        : q_(max_items)
    {
    }

#ifndef __MINGW32__
    // try to enqueue and block if no room left
    @others
};
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.300">    const char *first, const char *last, char value, const char *&amp;out) {
  out = static_cast&lt;const char*&gt;(std::memchr(first, value, last - first));
  return out != FMT_NULL;
}

template &lt;typename Handler, typename Char&gt;
struct id_adapter {
  FMT_CONSTEXPR void operator()() { handler.on_arg_id(); }
  FMT_CONSTEXPR void operator()(unsigned id) { handler.on_arg_id(id); }
  FMT_CONSTEXPR void operator()(basic_string_view&lt;Char&gt; id) {
    handler.on_arg_id(id);
  }
  FMT_CONSTEXPR void on_error(const char *message) {
    handler.on_error(message);
  }
  Handler &amp;handler;
};

template &lt;bool IS_CONSTEXPR, typename Char, typename Handler&gt;
FMT_CONSTEXPR void parse_format_string(
        basic_string_view&lt;Char&gt; format_str, Handler &amp;&amp;handler) {
  struct writer {
    FMT_CONSTEXPR void operator()(const Char *begin, const Char *end) {
      if (begin == end) return;
      for (;;) {
        const Char *p = FMT_NULL;
        if (!find&lt;IS_CONSTEXPR&gt;(begin, end, '}', p))
          return handler_.on_text(begin, end);
        ++p;
        if (p == end || *p != '}')
          return handler_.on_error("unmatched '}' in format string");
        handler_.on_text(begin, p);
        begin = p + 1;
      }
    }
    Handler &amp;handler_;
  } write{handler};
  auto begin = format_str.data(), end = begin + format_str.size();
  while (begin != end) {
    // Doing two passes with memchr (one for '{' and another for '}') is up to
    // 2.5x faster than the naive one-pass implementation on big format strings.
    const Char *p = begin;
    if (*begin != '{' &amp;&amp; !find&lt;IS_CONSTEXPR&gt;(begin, end, '{', p))
      return write(begin, end);
    write(begin, p);
    ++p;
    if (p == end)
      return handler.on_error("invalid format string");
    if (*p == '}') {
      handler.on_arg_id();
      handler.on_replacement_field(p);
    } else if (*p == '{') {
      handler.on_text(p, p + 1);
    } else {
      p = parse_arg_id(p, end, id_adapter&lt;Handler, Char&gt;{handler});
      Char c = p != end ? *p : 0;
      if (c == '}') {
        handler.on_replacement_field(p);
      } else if (c == ':') {
        internal::null_terminating_iterator&lt;Char&gt; it(p + 1, end);
        it = handler.on_format_specs(it);
        if (*it != '}')
          return handler.on_error("unknown format specifier");
        p = pointer_from(it);
      } else {
        return handler.on_error("missing '}' in format string");
      }
    }
    begin = p + 1;
  }
}

template &lt;typename T, typename ParseContext&gt;
FMT_CONSTEXPR const typename ParseContext::char_type *
    parse_format_specs(ParseContext &amp;ctx) {
  // GCC 7.2 requires initializer.
  formatter&lt;T, typename ParseContext::char_type&gt; f{};
  return f.parse(ctx);
}

template &lt;typename Char, typename ErrorHandler, typename... Args&gt;
</t>
<t tx="leo.20220407205633.301">class format_string_checker {
 public:
  explicit FMT_CONSTEXPR format_string_checker(
      basic_string_view&lt;Char&gt; format_str, ErrorHandler eh)
    : arg_id_(-1), context_(format_str, eh),
      parse_funcs_{&amp;parse_format_specs&lt;Args, parse_context_type&gt;...} {}

  typedef internal::null_terminating_iterator&lt;Char&gt; iterator;

  FMT_CONSTEXPR void on_text(const Char *, const Char *) {}

  FMT_CONSTEXPR void on_arg_id() {
    arg_id_ = context_.next_arg_id();
    check_arg_id();
  }
  FMT_CONSTEXPR void on_arg_id(unsigned id) {
    arg_id_ = id;
    context_.check_arg_id(id);
    check_arg_id();
  }
  FMT_CONSTEXPR void on_arg_id(basic_string_view&lt;Char&gt;) {}

  FMT_CONSTEXPR void on_replacement_field(const Char *) {}

  FMT_CONSTEXPR const Char *on_format_specs(iterator it) {
    auto p = pointer_from(it);
    context_.advance_to(p);
    return to_unsigned(arg_id_) &lt; NUM_ARGS ?
          parse_funcs_[arg_id_](context_) : p;
  }

  FMT_CONSTEXPR void on_error(const char *message) {
    context_.on_error(message);
  }

 private:
  typedef basic_parse_context&lt;Char, ErrorHandler&gt; parse_context_type;
  enum { NUM_ARGS = sizeof...(Args) };

  FMT_CONSTEXPR void check_arg_id() {
    if (internal::to_unsigned(arg_id_) &gt;= NUM_ARGS)
      context_.on_error("argument index out of range");
  }

  // Format specifier parsing function.
  typedef const Char *(*parse_func)(parse_context_type &amp;);

  int arg_id_;
  parse_context_type context_;
  parse_func parse_funcs_[NUM_ARGS &gt; 0 ? NUM_ARGS : 1];
};

template &lt;typename Char, typename ErrorHandler, typename... Args&gt;
FMT_CONSTEXPR bool check_format_string(
    basic_string_view&lt;Char&gt; s, ErrorHandler eh = ErrorHandler()) {
  format_string_checker&lt;Char, ErrorHandler, Args...&gt; checker(s, eh);
  parse_format_string&lt;true&gt;(s, checker);
  return true;
}

template &lt;typename... Args, typename String&gt;
typename std::enable_if&lt;is_compile_string&lt;String&gt;::value&gt;::type
    check_format_string(String format_str) {
  FMT_CONSTEXPR_DECL bool invalid_format =
      internal::check_format_string&lt;char, internal::error_handler, Args...&gt;(

template &lt;template &lt;typename&gt; class Handler, typename Spec, typename Context&gt;
</t>
<t tx="leo.20220407205633.302">void handle_dynamic_spec(
    Spec &amp;value, arg_ref&lt;typename Context::char_type&gt; ref, Context &amp;ctx) {
  typedef typename Context::char_type char_type;
  switch (ref.kind) {
  case arg_ref&lt;char_type&gt;::NONE:
    break;
  case arg_ref&lt;char_type&gt;::INDEX:
    internal::set_dynamic_spec&lt;Handler&gt;(
/** The default argument formatter. */
template &lt;typename Range&gt;
</t>
<t tx="leo.20220407205633.303">class arg_formatter:
  public internal::function&lt;
    typename internal::arg_formatter_base&lt;Range&gt;::iterator&gt;,
  public internal::arg_formatter_base&lt;Range&gt; {
 private:
  typedef typename Range::value_type char_type;
  typedef internal::arg_formatter_base&lt;Range&gt; base;
  typedef basic_format_context&lt;typename base::iterator, char_type&gt; context_type;

  context_type &amp;ctx_;

 public:
  typedef Range range;
  typedef typename base::iterator iterator;
  typedef typename base::format_specs format_specs;

  /**
    \rst
    Constructs an argument formatter object.
    *ctx* is a reference to the formatting context,
    *spec* contains format specifier information for standard argument types.
    \endrst
   */
  explicit arg_formatter(context_type &amp;ctx, format_specs *spec = {})
  : base(Range(ctx.out()), spec), ctx_(ctx) {}

  // Deprecated.
  arg_formatter(context_type &amp;ctx, format_specs &amp;spec)
  : base(Range(ctx.out()), &amp;spec), ctx_(ctx) {}

  using base::operator();

  /** Formats an argument of a user-defined type. */
  iterator operator()(typename basic_format_arg&lt;context_type&gt;::handle handle) {
    handle.format(ctx_);
    return this-&gt;out();
  }
};

/**
 An error returned by an operating system or a language runtime,
 for example a file opening error.
*/
</t>
<t tx="leo.20220407205633.304">class system_error : public std::runtime_error {
 private:
  FMT_API void init(int err_code, string_view format_str, format_args args);

 protected:
  int error_code_;

  system_error() : std::runtime_error("") {}

 public:
  /**
   \rst
   Constructs a :class:`fmt::system_error` object with a description
   formatted with `fmt::format_system_error`. *message* and additional
   arguments passed into the constructor are formatted similarly to
   `fmt::format`.

   **Example**::

     // This throws a system_error with the description
     //   cannot open file 'madeup': No such file or directory
     // or similar (system message may vary).
     const char *filename = "madeup";
     std::FILE *file = std::fopen(filename, "r");
     if (!file)
       throw fmt::system_error(errno, "cannot open file '{}'", filename);
   \endrst
  */
  template &lt;typename... Args&gt;
  system_error(int error_code, string_view message, const Args &amp; ... args)
    : std::runtime_error("") {
    init(error_code, message, make_format_args(args...));
  }

  int error_code() const { return error_code_; }
};

/**
  \rst
  Formats an error returned by an operating system or a language runtime,
  for example a file opening error, and writes it to *out* in the following
  form:

  .. parsed-literal::
     *&lt;message&gt;*: *&lt;system-message&gt;*

  where *&lt;message&gt;* is the passed message and *&lt;system-message&gt;* is
  the system message corresponding to the error code.
  *error_code* is a system error code as given by ``errno``.
  If *error_code* is not a valid error code such as -1, the system message
  may look like "Unknown error -1" and is platform-dependent.
  \endrst
 */
FMT_API void format_system_error(internal::buffer &amp;out, int error_code,
                                 fmt::string_view message) FMT_NOEXCEPT;

/**
  This template provides operations for formatting and writing data into a
  character range.
 */
template &lt;typename Range&gt;
</t>
<t tx="leo.20220407205633.305">class basic_writer {
 public:
  typedef typename Range::value_type char_type;
  typedef decltype(internal::declval&lt;Range&gt;().begin()) iterator;
  typedef basic_format_specs&lt;char_type&gt; format_specs;

 private:
  iterator out_;  // Output iterator.
  std::unique_ptr&lt;locale_provider&gt; locale_;

  iterator out() const { return out_; }

  // Attempts to reserve space for n extra characters in the output range.
  // Returns a pointer to the reserved range or a reference to out_.
  @others
};

template &lt;typename Range&gt;
template &lt;typename F&gt;
</t>
<t tx="leo.20220407205633.306">auto reserve(std::size_t n) -&gt; decltype(internal::reserve(out_, n)) {
  return internal::reserve(out_, n);
}

// Writes a value in the format
//   &lt;left-padding&gt;&lt;value&gt;&lt;right-padding&gt;
// where &lt;value&gt; is written by f(it).
template &lt;typename F&gt;
void write_padded(std::size_t size, const align_spec &amp;spec, F &amp;&amp;f);

template &lt;typename F&gt;
struct padded_int_writer {
  string_view prefix;
  char_type fill;
  std::size_t padding;
  F f;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.307">  void operator()(It &amp;&amp;it) const {
    if (prefix.size() != 0)
      it = std::copy_n(prefix.data(), prefix.size(), it);
    it = std::fill_n(it, padding, fill);
    f(it);
  }
};

// Writes an integer in the format
//   &lt;left-padding&gt;&lt;prefix&gt;&lt;numeric-padding&gt;&lt;digits&gt;&lt;right-padding&gt;
// where &lt;digits&gt; are written by f(it).
template &lt;typename Spec, typename F&gt;
</t>
<t tx="leo.20220407205633.308">void write_int(unsigned num_digits, string_view prefix,
               const Spec &amp;spec, F f) {
  std::size_t size = prefix.size() + num_digits;
  char_type fill = static_cast&lt;char_type&gt;(spec.fill());
  std::size_t padding = 0;
  if (spec.align() == ALIGN_NUMERIC) {
    if (spec.width() &gt; size) {
      padding = spec.width() - size;
      size = spec.width();
    }
  } else if (spec.precision() &gt; static_cast&lt;int&gt;(num_digits)) {
    size = prefix.size() + static_cast&lt;std::size_t&gt;(spec.precision());
    padding = static_cast&lt;std::size_t&gt;(spec.precision()) - num_digits;
    fill = '0';
  }
  align_spec as = spec;
  if (spec.align() == ALIGN_DEFAULT)
    as.align_ = ALIGN_RIGHT;
  write_padded(size, as, padded_int_writer&lt;F&gt;{prefix, fill, padding, f});
}

// Writes a decimal integer.
template &lt;typename Int&gt;
</t>
<t tx="leo.20220407205633.309">void write_decimal(Int value) {
  typedef typename internal::int_traits&lt;Int&gt;::main_type main_type;
  main_type abs_value = static_cast&lt;main_type&gt;(value);
  bool is_negative = internal::is_negative(value);
  if (is_negative)
    abs_value = 0 - abs_value;
  unsigned num_digits = internal::count_digits(abs_value);
  auto &amp;&amp;it = reserve((is_negative ? 1 : 0) + num_digits);
  if (is_negative)
    *it++ = '-';
  it = internal::format_decimal(it, abs_value, num_digits);
}

// The handle_int_type_spec handler that writes an integer.
template &lt;typename Int, typename Spec&gt;
struct int_writer {
  typedef typename internal::int_traits&lt;Int&gt;::main_type unsigned_type;

  basic_writer&lt;Range&gt; &amp;writer;
  const Spec &amp;spec;
  unsigned_type abs_value;
  char prefix[4];
  unsigned prefix_size;

  string_view get_prefix() const { return string_view(prefix, prefix_size); }

  // Counts the number of digits in abs_value. BITS = log2(radix).
  template &lt;unsigned BITS&gt;
</t>
<t tx="leo.20220407205633.31">void enqueue(T &amp;&amp;item)
{
    {
        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
        pop_cv_.wait(lock, [this] { return !this-&gt;q_.full(); });
        q_.push_back(std::move(item));
    }
    push_cv_.notify_one();
}

// enqueue immediately. overrun oldest message in the queue if no room left.
</t>
<t tx="leo.20220407205633.310">unsigned count_digits() const {
  unsigned_type n = abs_value;
  unsigned num_digits = 0;
  do {
    ++num_digits;
  } while ((n &gt;&gt;= BITS) != 0);
  return num_digits;
}

</t>
<t tx="leo.20220407205633.311">int_writer(basic_writer&lt;Range&gt; &amp;w, Int value, const Spec &amp;s)
  : writer(w), spec(s), abs_value(static_cast&lt;unsigned_type&gt;(value)),
    prefix_size(0) {
  if (internal::is_negative(value)) {
    prefix[0] = '-';
    ++prefix_size;
    abs_value = 0 - abs_value;
  } else if (spec.flag(SIGN_FLAG)) {
    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';
    ++prefix_size;
  }
}

struct dec_writer {
  unsigned_type abs_value;
  unsigned num_digits;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.312">  void operator()(It &amp;&amp;it) const {
    it = internal::format_decimal(it, abs_value, num_digits);
  }
};

</t>
<t tx="leo.20220407205633.313">void on_dec() {
  unsigned num_digits = internal::count_digits(abs_value);
  writer.write_int(num_digits, get_prefix(), spec,
                   dec_writer{abs_value, num_digits});
}

struct hex_writer {
  int_writer &amp;self;
  unsigned num_digits;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.314">  void operator()(It &amp;&amp;it) const {
    it = internal::format_uint&lt;4&gt;(it, self.abs_value, num_digits,
                                  self.spec.type() != 'x');
  }
};

</t>
<t tx="leo.20220407205633.315">void on_hex() {
  if (spec.flag(HASH_FLAG)) {
    prefix[prefix_size++] = '0';
    prefix[prefix_size++] = static_cast&lt;char&gt;(spec.type());
  }
  unsigned num_digits = count_digits&lt;4&gt;();
  writer.write_int(num_digits, get_prefix(), spec,
                   hex_writer{*this, num_digits});
}

template &lt;int BITS&gt;
struct bin_writer {
  unsigned_type abs_value;
  unsigned num_digits;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.316">  void operator()(It &amp;&amp;it) const {
    it = internal::format_uint&lt;BITS&gt;(it, abs_value, num_digits);
  }
};

</t>
<t tx="leo.20220407205633.317">void on_bin() {
  if (spec.flag(HASH_FLAG)) {
    prefix[prefix_size++] = '0';
    prefix[prefix_size++] = static_cast&lt;char&gt;(spec.type());
  }
  unsigned num_digits = count_digits&lt;1&gt;();
  writer.write_int(num_digits, get_prefix(), spec,
                   bin_writer&lt;1&gt;{abs_value, num_digits});
}

</t>
<t tx="leo.20220407205633.318">void on_oct() {
  unsigned num_digits = count_digits&lt;3&gt;();
  if (spec.flag(HASH_FLAG) &amp;&amp;
      spec.precision() &lt;= static_cast&lt;int&gt;(num_digits)) {
    // Octal prefix '0' is counted as a digit, so only add it if precision
    // is not greater than the number of digits.
    prefix[prefix_size++] = '0';
  }
  writer.write_int(num_digits, get_prefix(), spec,
                   bin_writer&lt;3&gt;{abs_value, num_digits});
}

enum { SEP_SIZE = 1 };

struct num_writer {
  unsigned_type abs_value;
  unsigned size;
  char_type sep;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.319">  void operator()(It &amp;&amp;it) const {
    basic_string_view&lt;char_type&gt; s(&amp;sep, SEP_SIZE);
    it = format_decimal(it, abs_value, size,
                        internal::add_thousands_sep&lt;char_type&gt;(s));
  }
};

</t>
<t tx="leo.20220407205633.32">void enqueue_nowait(T &amp;&amp;item)
{
    {
        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
        q_.push_back(std::move(item));
    }
    push_cv_.notify_one();
}

// try to dequeue item. if no item found. wait upto timeout and try again
// Return true, if succeeded dequeue item, false otherwise
</t>
<t tx="leo.20220407205633.320">void on_num() {
  unsigned num_digits = internal::count_digits(abs_value);
  char_type sep = internal::thousands_sep&lt;char_type&gt;(writer.locale_.get());
  unsigned size = num_digits + SEP_SIZE * ((num_digits - 1) / 3);
  writer.write_int(size, get_prefix(), spec,
                   num_writer{abs_value, size, sep});
}

</t>
<t tx="leo.20220407205633.321">  void on_error() {
    FMT_THROW(format_error("invalid type specifier"));
  }
};

// Writes a formatted integer.
template &lt;typename T, typename Spec&gt;
</t>
<t tx="leo.20220407205633.322">void write_int(T value, const Spec &amp;spec) {
  @others
};

struct double_writer {
  size_t n;
  char sign;
  basic_memory_buffer&lt;char_type&gt; &amp;buffer;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.323">  internal::handle_int_type_spec(spec.type(),
                                 int_writer&lt;T, Spec&gt;(*this, value, spec));
}

enum {INF_SIZE = 3}; // This is an enum to workaround a bug in MSVC.

struct inf_or_nan_writer {
  char sign;
  const char *str;

  template &lt;typename It&gt;
</t>
<t tx="leo.20220407205633.324">void operator()(It &amp;&amp;it) const {
  if (sign)
    *it++ = sign;
  it = std::copy_n(str, static_cast&lt;std::size_t&gt;(INF_SIZE), it);
}
</t>
<t tx="leo.20220407205633.325">  void operator()(It &amp;&amp;it) {
    if (sign) {
      *it++ = sign;
      --n;
    }
    it = std::copy_n(buffer.begin(), n, it);
  }
};

// Formats a floating-point number (double or long double).
template &lt;typename T&gt;
void write_double(T value, const format_specs &amp;spec);
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.326">void write_double_sprintf(T value, const format_specs &amp;spec,
                          internal::basic_buffer&lt;char_type&gt;&amp; buffer);

template &lt;typename Char&gt;
struct str_writer {
  const Char *s;
  std::size_t size;

  template &lt;typename It&gt;
  @others
};

// Writes a formatted string.
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.327">void operator()(It &amp;&amp;it) const {
  it = std::copy_n(s, size, it);
}
</t>
<t tx="leo.20220407205633.328">void write_str(const Char *s, std::size_t size, const align_spec &amp;spec) {
  write_padded(size, spec, str_writer&lt;Char&gt;{s, size});
}

template &lt;typename Char&gt;
void write_str(basic_string_view&lt;Char&gt; str, const format_specs &amp;spec);

// Appends floating-point length specifier to the format string.
// The second argument is only used for overload resolution.
</t>
<t tx="leo.20220407205633.329">void append_float_length(char_type *&amp;format_ptr, long double) {
  *format_ptr++ = 'L';
}

template&lt;typename T&gt;
void append_float_length(char_type *&amp;, T) {}
void write(long long value) { write_decimal(value); }

void write(unsigned value) { write_decimal(value); }
void write(unsigned long value) { write_decimal(value); }
void write(unsigned long long value) { write_decimal(value); }

/**
  \rst
  Formats *value* and writes it to the buffer.
  \endrst
 */
template &lt;typename T, typename FormatSpec, typename... FormatSpecs&gt;
typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, void&gt;::type
    write(T value, FormatSpec spec, FormatSpecs... specs) {
  format_specs s(spec, specs...);
  s.align_ = ALIGN_RIGHT;
  write_int(value, s);
}

</t>
<t tx="leo.20220407205633.33">    bool dequeue_for(T &amp;popped_item, std::chrono::milliseconds wait_duration)
    {
        {
            std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
            if (!push_cv_.wait_for(lock, wait_duration, [this] { return !this-&gt;q_.empty(); }))
            {
                return false;
            }
            q_.pop_front(popped_item);
        }
        pop_cv_.notify_one();
        return true;
    }

#else
    // apparently mingw deadlocks if the mutex is released before cv.notify_one(),
    // so release the mutex at the very end each function.

    // try to enqueue and block if no room left
</t>
<t tx="leo.20220407205633.330">void write(double value) {
  write_double(value, format_specs());
}

/**
  \rst
  Formats *value* using the general format for floating-point numbers
  (``'g'``) and writes it to the buffer.
  \endrst
 */
</t>
<t tx="leo.20220407205633.331">void write(long double value) {
  write_double(value, format_specs());
}

/** Writes a character to the buffer. */
</t>
<t tx="leo.20220407205633.332">void write(char value) {
  *reserve(1) = value;
}

</t>
<t tx="leo.20220407205633.333">void write(wchar_t value) {
  internal::require_wchar&lt;char_type&gt;();
  *reserve(1) = value;
}

/**
  \rst
  Writes *value* to the buffer.
  \endrst
 */
</t>
<t tx="leo.20220407205633.334">void write(string_view value) {
  auto &amp;&amp;it = reserve(value.size());
  it = std::copy(value.begin(), value.end(), it);
}

</t>
<t tx="leo.20220407205633.335">void write(wstring_view value) {
  internal::require_wchar&lt;char_type&gt;();
  auto &amp;&amp;it = reserve(value.size());
  it = std::copy(value.begin(), value.end(), it);
}

template &lt;typename... FormatSpecs&gt;
</t>
<t tx="leo.20220407205633.336">void write(basic_string_view&lt;char_type&gt; str, FormatSpecs... specs) {
  write_str(str, format_specs(specs...));
}

template &lt;typename T&gt;
typename std::enable_if&lt;std::is_same&lt;T, void&gt;::value&gt;::type
    write(const T *p) {
  format_specs specs;
  specs.flags_ = HASH_FLAG;
  specs.type_ = 'x';
  write_int(reinterpret_cast&lt;uintptr_t&gt;(p), specs);
}
</t>
<t tx="leo.20220407205633.337">void basic_writer&lt;Range&gt;::write_padded(
    std::size_t size, const align_spec &amp;spec, F &amp;&amp;f) {
  unsigned width = spec.width();
  if (width &lt;= size)
    return f(reserve(size));
  auto &amp;&amp;it = reserve(width);
  char_type fill = static_cast&lt;char_type&gt;(spec.fill());
  std::size_t padding = width - size;
  if (spec.align() == ALIGN_RIGHT) {
    it = std::fill_n(it, padding, fill);
    f(it);
  } else if (spec.align() == ALIGN_CENTER) {
    std::size_t left_padding = padding / 2;
    it = std::fill_n(it, left_padding, fill);
    f(it);
    it = std::fill_n(it, padding - left_padding, fill);
  } else {
    f(it);
    it = std::fill_n(it, padding, fill);
  }
}

template &lt;typename Range&gt;
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.338">void basic_writer&lt;Range&gt;::write_str(
    basic_string_view&lt;Char&gt; s, const format_specs &amp;spec) {
  const Char *data = s.data();
  std::size_t size = s.size();
  std::size_t precision = static_cast&lt;std::size_t&gt;(spec.precision_);
  if (spec.precision_ &gt;= 0 &amp;&amp; precision &lt; size)
    size = precision;
  write_str(data, size, spec);
}

template &lt;typename Char&gt;
struct float_spec_handler {
  Char type;
  bool upper;

  explicit float_spec_handler(Char t) : type(t), upper(false) {}

</t>
<t tx="leo.20220407205633.339">void on_general() {
  if (type == 'G')
    upper = true;
  else
    type = 'g';
}

</t>
<t tx="leo.20220407205633.34">void enqueue(T &amp;&amp;item)
{
    std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
    pop_cv_.wait(lock, [this] { return !this-&gt;q_.full(); });
    q_.push_back(std::move(item));
    push_cv_.notify_one();
}

// enqueue immediately. overrun oldest message in the queue if no room left.
</t>
<t tx="leo.20220407205633.340">void on_exp() {
  if (type == 'E')
    upper = true;
}

</t>
<t tx="leo.20220407205633.341">  void on_fixed() {
    if (type == 'F') {
      upper = true;
#if FMT_MSC_VER
      // MSVC's printf doesn't support 'F'.
      type = 'f';
#endif
    }
  }

</t>
<t tx="leo.20220407205633.342">void on_hex() {
  if (type == 'A')
    upper = true;
}

</t>
<t tx="leo.20220407205633.343">  void on_error() {
    FMT_THROW(format_error("invalid type specifier"));
  }
};

template &lt;typename Range&gt;
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.344">void basic_writer&lt;Range&gt;::write_double(T value, const format_specs &amp;spec) {
  // Check type.
  float_spec_handler&lt;char_type&gt; handler(spec.type());
  internal::handle_float_type_spec(spec.type(), handler);

  char sign = 0;
  // Use isnegative instead of value &lt; 0 because the latter is always
  // false for NaN.
  if (internal::fputil::isnegative(static_cast&lt;double&gt;(value))) {
    sign = '-';
    value = -value;
  } else if (spec.flag(SIGN_FLAG)) {
    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';
  }

  struct write_inf_or_nan_t {
    basic_writer &amp;writer;
    format_specs spec;
    char sign;
    @others
}

template &lt;typename Range&gt;
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.345">  void operator()(const char *str) const {
    writer.write_padded(INF_SIZE + (sign ? 1 : 0), spec,
                        inf_or_nan_writer{sign, str});
  }
} write_inf_or_nan = {*this, spec, sign};

// Format NaN and ininity ourselves because sprintf's output is not consistent
// across platforms.
if (internal::fputil::isnotanumber(value))
  return write_inf_or_nan(handler.upper ? "NAN" : "nan");
if (internal::fputil::isinfinity(value))
  return write_inf_or_nan(handler.upper ? "INF" : "inf");

basic_memory_buffer&lt;char_type&gt; buffer;
char type = static_cast&lt;char&gt;(spec.type());
if (internal::const_check(
</t>
<t tx="leo.20220407205633.346">      internal::use_grisu() &amp;&amp; sizeof(T) &lt;= sizeof(double)) &amp;&amp;
    type != 'a' &amp;&amp; type != 'A') {
  char buf[100]; // TODO: correct buffer size
  size_t size = 0;
  internal::grisu2_format(static_cast&lt;double&gt;(value), buf, size, type,
if (spec.align() == ALIGN_NUMERIC) {
  if (sign) {
    auto &amp;&amp;it = reserve(1);
    *it++ = sign;
    sign = 0;
    if (as.width_)
      --as.width_;
  }
  as.align_ = ALIGN_RIGHT;
} else {
  if (spec.align() == ALIGN_DEFAULT)
    as.align_ = ALIGN_RIGHT;
  if (sign)
    ++n;
}
write_padded(n, as, double_writer{n, sign, buffer});
</t>
<t tx="leo.20220407205633.347">void basic_writer&lt;Range&gt;::write_double_sprintf(
    T value, const format_specs &amp;spec,
    internal::basic_buffer&lt;char_type&gt;&amp; buffer) {
  // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
  FMT_ASSERT(buffer.capacity() != 0, "empty buffer");

  // Build format string.
  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg
  char_type format[MAX_FORMAT_SIZE];
  char_type *format_ptr = format;
  *format_ptr++ = '%';
  if (spec.flag(HASH_FLAG))
    *format_ptr++ = '#';
  if (spec.precision() &gt;= 0) {
    *format_ptr++ = '.';
    *format_ptr++ = '*';
  }

  append_float_length(format_ptr, value);
  *format_ptr++ = spec.type();
  *format_ptr = '\0';

  // Format using snprintf.
  char_type *start = FMT_NULL;
  for (;;) {
    std::size_t buffer_size = buffer.capacity();
    start = &amp;buffer[0];
    @others
}

// Reports a system error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_system_error(int error_code,
                                 string_view message) FMT_NOEXCEPT;

#if FMT_USE_WINDOWS_H

/** A Windows error. */
</t>
<t tx="leo.20220407205633.348">  int result = internal::char_traits&lt;char_type&gt;::format_float(
      start, buffer_size, format, spec.precision(), value);
  if (result &gt;= 0) {
    unsigned n = internal::to_unsigned(result);
    if (n &lt; buffer.capacity()) {
      buffer.resize(n);
      break;  // The buffer is large enough - continue with formatting.
    }
    buffer.reserve(n + 1);
  } else {
    // If result is negative we ask to increase the capacity by at least 1,
    // but as std::vector, the buffer grows exponentially.
    buffer.reserve(buffer.capacity() + 1);
  }
}
</t>
<t tx="leo.20220407205633.349">class windows_error : public system_error {
 private:
  FMT_API void init(int error_code, string_view format_str, format_args args);

 public:
  /**
   \rst
   Constructs a :class:`fmt::windows_error` object with the description
   of the form

   .. parsed-literal::
     *&lt;message&gt;*: *&lt;system-message&gt;*

   where *&lt;message&gt;* is the formatted message and *&lt;system-message&gt;* is the
   system message corresponding to the error code.
   *error_code* is a Windows error code as given by ``GetLastError``.
   If *error_code* is not a valid error code such as -1, the system message
   will look like "error -1".

   **Example**::

     // This throws a windows_error with the description
     //   cannot open file 'madeup': The system cannot find the file specified.
     // or similar (system message may vary).
     const char *filename = "madeup";
     LPOFSTRUCT of = LPOFSTRUCT();
     HFILE file = OpenFile(filename, &amp;of, OF_READ);
     if (file == HFILE_ERROR) {
       throw fmt::windows_error(GetLastError(),
                                "cannot open file '{}'", filename);
     }
   \endrst
  */
  template &lt;typename... Args&gt;
  windows_error(int error_code, string_view message, const Args &amp; ... args) {
    init(error_code, message, make_format_args(args...));
  }
};

// Reports a Windows error without throwing an exception.
// Can be used to report errors from destructors.
FMT_API void report_windows_error(int error_code,
                                  string_view message) FMT_NOEXCEPT;

#endif

/** Fast integer formatter. */
</t>
<t tx="leo.20220407205633.35">void enqueue_nowait(T &amp;&amp;item)
{
    std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
    q_.push_back(std::move(item));
    push_cv_.notify_one();
}

// try to dequeue item. if no item found. wait upto timeout and try again
// Return true, if succeeded dequeue item, false otherwise
</t>
<t tx="leo.20220407205633.350">class format_int {
 private:
  // Buffer should be large enough to hold all digits (digits10 + 1),
  // a sign and a null character.
  enum {BUFFER_SIZE = std::numeric_limits&lt;unsigned long long&gt;::digits10 + 3};
  mutable char buffer_[BUFFER_SIZE];
  char *str_;

  // Formats value in reverse and returns a pointer to the beginning.
  char *format_decimal(unsigned long long value) {
    char *ptr = buffer_ + BUFFER_SIZE - 1;
    while (value &gt;= 100) {
      // Integer division is slow so do it for a group of two digits instead
      // of for every digit. The idea comes from the talk by Alexandrescu
      // "Three Optimization Tips for C++". See speed-test for a comparison.
      unsigned index = static_cast&lt;unsigned&gt;((value % 100) * 2);
      value /= 100;
      *--ptr = internal::data::DIGITS[index + 1];
      *--ptr = internal::data::DIGITS[index];
    }
    if (value &lt; 10) {
      *--ptr = static_cast&lt;char&gt;('0' + value);
      return ptr;
    }
    unsigned index = static_cast&lt;unsigned&gt;(value * 2);
    *--ptr = internal::data::DIGITS[index + 1];
    *--ptr = internal::data::DIGITS[index];
    return ptr;
  }

  @others
};

// Formats a decimal integer value writing into buffer and returns
// a pointer to the end of the formatted string. This function doesn't
// write a terminating null character.
template &lt;typename T&gt;
inline void format_decimal(char *&amp;buffer, T value) {
  typedef typename internal::int_traits&lt;T&gt;::main_type main_type;
  main_type abs_value = static_cast&lt;main_type&gt;(value);
  if (internal::is_negative(value)) {
    *buffer++ = '-';
    abs_value = 0 - abs_value;
  }
  if (abs_value &lt; 100) {
    if (abs_value &lt; 10) {
      *buffer++ = static_cast&lt;char&gt;('0' + abs_value);
      return;
    }
    unsigned index = static_cast&lt;unsigned&gt;(abs_value * 2);
    *buffer++ = internal::data::DIGITS[index];
    *buffer++ = internal::data::DIGITS[index + 1];
    return;
  }
  unsigned num_digits = internal::count_digits(abs_value);
  internal::format_decimal(buffer, abs_value, num_digits);
  buffer += num_digits;
}

// Formatter of objects of type T.
template &lt;typename T, typename Char&gt;
struct formatter&lt;
    T, Char,
    typename std::enable_if&lt;internal::format_type&lt;
        typename buffer_context&lt;Char&gt;::type, T&gt;::value&gt;::type&gt; {

  // Parses format specifiers stopping either at the end of the range or at the
  // terminating '}'.
  template &lt;typename ParseContext&gt;
  FMT_CONSTEXPR typename ParseContext::iterator parse(ParseContext &amp;ctx) {
    auto it = internal::null_terminating_iterator&lt;Char&gt;(ctx);
    typedef internal::dynamic_specs_handler&lt;ParseContext&gt; handler_type;
</t>
<t tx="leo.20220407205633.351"> void format_signed(long long value) {
   unsigned long long abs_value = static_cast&lt;unsigned long long&gt;(value);
   bool negative = value &lt; 0;
   if (negative)
     abs_value = 0 - abs_value;
   str_ = format_decimal(abs_value);
   if (negative)
     *--str_ = '-';
 }

public:
 explicit format_int(int value) { format_signed(value); }
 explicit format_int(long value) { format_signed(value); }
 explicit format_int(long long value) { format_signed(value); }
 explicit format_int(unsigned value) : str_(format_decimal(value)) {}
 explicit format_int(unsigned long value) : str_(format_decimal(value)) {}
 explicit format_int(unsigned long long value) : str_(format_decimal(value)) {}

 /** Returns the number of characters written to the output buffer. */
 std::size_t size() const {
   return internal::to_unsigned(buffer_ - str_ + BUFFER_SIZE - 1);
 }

 /**
   Returns a pointer to the output buffer content. No terminating null
   character is appended.
  */
 const char *data() const { return str_; }

 /**
   Returns a pointer to the output buffer content with terminating null
   character appended.
  */
</t>
<t tx="leo.20220407205633.352">const char *c_str() const {
  buffer_[BUFFER_SIZE - 1] = '\0';
  return str_;
}

/**
  \rst
  Returns the content of the output buffer as an ``std::string``.
  \endrst
 */
std::string str() const { return std::string(str_, size()); }
</t>
<t tx="leo.20220407205633.353">  auto type = internal::get_type&lt;
    typename buffer_context&lt;Char&gt;::type, T&gt;::value;
  internal::specs_checker&lt;handler_type&gt;
      handler(handler_type(specs_, ctx), type);
  it = parse_format_specs(it, handler);
  auto type_spec = specs_.type();
  auto eh = ctx.error_handler();
  switch (type) {
  case internal::none_type:
  case internal::named_arg_type:
    FMT_ASSERT(false, "invalid argument type");
    break;
  case internal::int_type:
  case internal::uint_type:
  case internal::long_long_type:
  case internal::ulong_long_type:
  case internal::bool_type:
    handle_int_type_spec(
          type_spec, internal::int_type_checker&lt;decltype(eh)&gt;(eh));
    break;
  case internal::char_type:
    handle_char_specs(
        &amp;specs_,
        internal::char_specs_checker&lt;decltype(eh), decltype(type_spec)&gt;(
    break;
  case internal::string_type:
    internal::check_string_type_spec(type_spec, eh);
    break;
  case internal::pointer_type:
    internal::check_pointer_type_spec(type_spec, eh);
    break;
  case internal::custom_type:
    // Custom format specifiers should be checked in parse functions of
    // formatter specializations.
    break;
  }
  return pointer_from(it);
}

template &lt;typename FormatContext&gt;
</t>
<t tx="leo.20220407205633.354">  auto format(const T &amp;val, FormatContext &amp;ctx) -&gt; decltype(ctx.out()) {
    internal::handle_dynamic_spec&lt;internal::width_checker&gt;(
  internal::dynamic_format_specs&lt;Char&gt; specs_;
};

// A formatter for types known only at run time such as variant alternatives.
//
// Usage:
//   typedef std::variant&lt;int, std::string&gt; variant;
//   template &lt;&gt;
//   struct formatter&lt;variant&gt;: dynamic_formatter&lt;&gt; {
//     void format(buffer &amp;buf, const variant &amp;v, context &amp;ctx) {
//       visit([&amp;](const auto &amp;val) { format(buf, val, ctx); }, v);
//     }
//   };
template &lt;typename Char = char&gt;
</t>
<t tx="leo.20220407205633.355">class dynamic_formatter {
 private:
  struct null_handler: internal::error_handler {
    @others
</t>
<t tx="leo.20220407205633.356">   void on_align(alignment) {}
   void on_plus() {}
   void on_minus() {}
   void on_space() {}
   void on_hash() {}
 };

public:
 template &lt;typename ParseContext&gt;
 auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin()) {
   auto it = internal::null_terminating_iterator&lt;Char&gt;(ctx);
   // Checks are deferred to formatting time when the argument type is known.
   internal::dynamic_specs_handler&lt;ParseContext&gt; handler(specs_, ctx);
   it = parse_format_specs(it, handler);
   return pointer_from(it);
 }

 template &lt;typename T, typename FormatContext&gt;
</t>
<t tx="leo.20220407205633.357">  auto format(const T &amp;val, FormatContext &amp;ctx) -&gt; decltype(ctx.out()) {
    handle_specs(ctx);
    @others
  basic_format_context&lt;Range, Char&gt;::get_arg(
    basic_string_view&lt;char_type&gt; name) {
  map_.init(this-&gt;args());
  format_arg arg = map_.find(name);
  if (arg.type() == internal::none_type)
    this-&gt;on_error("argument not found");
  return arg;
}

template &lt;typename ArgFormatter, typename Char, typename Context&gt;
struct format_handler : internal::error_handler {
  typedef internal::null_terminating_iterator&lt;Char&gt; iterator;
  typedef typename ArgFormatter::range range;

  format_handler(range r, basic_string_view&lt;Char&gt; str,
                 basic_format_args&lt;Context&gt; format_args)
    : context(r.begin(), str, format_args) {}

</t>
<t tx="leo.20220407205633.358">internal::specs_checker&lt;null_handler&gt;
    checker(null_handler(), internal::get_type&lt;FormatContext, T&gt;::value);
checker.on_align(specs_.align());
if (specs_.flags_ == 0) {
  // Do nothing.
} else if (specs_.flag(SIGN_FLAG)) {
  if (specs_.flag(PLUS_FLAG))
    checker.on_plus();
  else
    checker.on_space();
} else if (specs_.flag(MINUS_FLAG)) {
  checker.on_minus();
} else if (specs_.flag(HASH_FLAG)) {
  checker.on_hash();
}
if (specs_.precision_ != -1)
  checker.end_precision();
</t>
<t tx="leo.20220407205633.359">   typedef output_range&lt;typename FormatContext::iterator,
                        typename FormatContext::char_type&gt; range;
   fmt::visit(arg_formatter&lt;range&gt;(ctx, &amp;specs_),
              internal::make_arg&lt;FormatContext&gt;(val));
   return ctx.out();
 }

private:
 template &lt;typename Context&gt;
 void handle_specs(Context &amp;ctx) {
   internal::handle_dynamic_spec&lt;internal::width_checker&gt;(
</t>
<t tx="leo.20220407205633.36">    bool dequeue_for(T &amp;popped_item, std::chrono::milliseconds wait_duration)
    {
        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
        if (!push_cv_.wait_for(lock, wait_duration, [this] { return !this-&gt;q_.empty(); }))
        {
            return false;
        }
        q_.pop_front(popped_item);
        pop_cv_.notify_one();
        return true;
    }

#endif

    size_t overrun_counter()
    {
        std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);
        return q_.overrun_counter();
    }

private:
    std::mutex queue_mutex_;
    std::condition_variable push_cv_;
    std::condition_variable pop_cv_;
    spdlog::details::circular_q&lt;T&gt; q_;
</t>
<t tx="leo.20220407205633.360">void on_text(const Char *begin, const Char *end) {
  auto size = internal::to_unsigned(end - begin);
  auto out = context.out();
  auto &amp;&amp;it = internal::reserve(out, size);
  it = std::copy_n(begin, size, it);
  context.advance_to(out);
}

void on_arg_id() { arg = context.next_arg(); }
</t>
<t tx="leo.20220407205633.361">void on_arg_id(unsigned id) {
  context.parse_context().check_arg_id(id);
  arg = context.get_arg(id);
}
</t>
<t tx="leo.20220407205633.362">void on_arg_id(basic_string_view&lt;Char&gt; id) {
  arg = context.get_arg(id);
}

</t>
<t tx="leo.20220407205633.363">  void on_replacement_field(const Char *p) {
    context.parse_context().advance_to(p);
    if (!fmt::visit(internal::custom_formatter&lt;Char, Context&gt;(context), arg))
      context.advance_to(fmt::visit(ArgFormatter(context), arg));
  }

  iterator on_format_specs(iterator it) {
    auto&amp; parse_ctx = context.parse_context();
    parse_ctx.advance_to(pointer_from(it));
    if (fmt::visit(internal::custom_formatter&lt;Char, Context&gt;(context), arg))
      return iterator(parse_ctx);
    basic_format_specs&lt;Char&gt; specs;
    using internal::specs_handler;
    internal::specs_checker&lt;specs_handler&lt;Context&gt;&gt;
  basic_format_arg&lt;Context&gt; arg;
};

/** Formats arguments and writes the output to the range. */
template &lt;typename ArgFormatter, typename Char, typename Context&gt;
typename Context::iterator vformat_to(typename ArgFormatter::range out,
                                      basic_string_view&lt;Char&gt; format_str,
                                      basic_format_args&lt;Context&gt; args) {
  format_handler&lt;ArgFormatter, Char, Context&gt; h(out, format_str, args);
  internal::parse_format_string&lt;false&gt;(format_str, h);
  return h.context.out();
}

// Casts ``p`` to ``const void*`` for pointer formatting.
// Example:
//   auto s = format("{}", ptr(p));
template &lt;typename T&gt;
inline const void *ptr(const T *p) { return p; }

template &lt;typename It, typename Char&gt;
struct arg_join {
  It begin;
  It end;
  basic_string_view&lt;Char&gt; sep;

  arg_join(It begin, It end, basic_string_view&lt;Char&gt; sep)
    : begin(begin), end(end), sep(sep) {}
};

template &lt;typename It, typename Char&gt;
struct formatter&lt;arg_join&lt;It, Char&gt;, Char&gt;:
    formatter&lt;typename std::iterator_traits&lt;It&gt;::value_type, Char&gt; {
  template &lt;typename FormatContext&gt;
</t>
<t tx="leo.20220407205633.364">  auto format(const arg_join&lt;It, Char&gt; &amp;value, FormatContext &amp;ctx)
      -&gt; decltype(ctx.out()) {
    typedef formatter&lt;typename std::iterator_traits&lt;It&gt;::value_type, Char&gt; base;
    auto it = value.begin;
    auto out = ctx.out();
    if (it != value.end) {
      out = base::format(*it++, ctx);
      while (it != value.end) {
        out = std::copy(value.sep.begin(), value.sep.end(), out);
        ctx.advance_to(out);
        out = base::format(*it++, ctx);
      }
    }
    return out;
  }
};

template &lt;typename It&gt;
arg_join&lt;It, char&gt; join(It begin, It end, string_view sep) {
  return arg_join&lt;It, char&gt;(begin, end, sep);
}

template &lt;typename It&gt;
arg_join&lt;It, wchar_t&gt; join(It begin, It end, wstring_view sep) {
  return arg_join&lt;It, wchar_t&gt;(begin, end, sep);
}

// The following causes ICE in gcc 4.4.
#if FMT_USE_TRAILING_RETURN &amp;&amp; (!FMT_GCC_VERSION || FMT_GCC_VERSION &gt;= 405)
template &lt;typename Range&gt;
</t>
<t tx="leo.20220407205633.365">auto join(const Range &amp;range, string_view sep)
    -&gt; arg_join&lt;decltype(internal::begin(range)), char&gt; {
  return join(internal::begin(range), internal::end(range), sep);
}

template &lt;typename Range&gt;
</t>
<t tx="leo.20220407205633.366">auto join(const Range &amp;range, wstring_view sep)
    -&gt; arg_join&lt;decltype(internal::begin(range)), wchar_t&gt; {
  return join(internal::begin(range), internal::end(range), sep);
}
#endif

/**
  \rst
  Converts *value* to ``std::string`` using the default format for type *T*.
  It doesn't support user-defined types with custom formatters.

  **Example**::

    #include &lt;fmt/format.h&gt;

    std::string answer = fmt::to_string(42);
  \endrst
 */
template &lt;typename T&gt;
std::string to_string(const T &amp;value) {
  std::string str;
  internal::container_buffer&lt;std::string&gt; buf(str);
  writer(buf).write(value);
  return str;
}

/**
  Converts *value* to ``std::wstring`` using the default format for type *T*.
 */
template &lt;typename T&gt;
std::wstring to_wstring(const T &amp;value) {
  std::wstring str;
  internal::container_buffer&lt;std::wstring&gt; buf(str);
  wwriter(buf).write(value);
  return str;
}

template &lt;typename Char, std::size_t SIZE&gt;
std::basic_string&lt;Char&gt; to_string(const basic_memory_buffer&lt;Char, SIZE&gt; &amp;buf) {
  return std::basic_string&lt;Char&gt;(buf.data(), buf.size());
}

inline format_context::iterator vformat_to(
</t>
<t tx="leo.20220407205633.367">    internal::buffer &amp;buf, string_view format_str, format_args args) {
  typedef back_insert_range&lt;internal::buffer&gt; range;
  return vformat_to&lt;arg_formatter&lt;range&gt;&gt;(buf, format_str, args);
}

inline wformat_context::iterator vformat_to(
</t>
<t tx="leo.20220407205633.368">    internal::wbuffer &amp;buf, wstring_view format_str, wformat_args args) {
  typedef back_insert_range&lt;internal::wbuffer&gt; range;
  return vformat_to&lt;arg_formatter&lt;range&gt;&gt;(buf, format_str, args);
}

template &lt;
    typename String, typename... Args,
    std::size_t SIZE = inline_buffer_size,
    typename Char = typename internal::format_string_traits&lt;String&gt;::char_type&gt;
inline typename buffer_context&lt;Char&gt;::type::iterator format_to(
    basic_memory_buffer&lt;Char, SIZE&gt; &amp;buf, const String &amp;format_str,
</t>
<t tx="leo.20220407205633.369">    const Args &amp; ... args) {
  internal::check_format_string&lt;Args...&gt;(format_str);
  return vformat_to(
        buf, basic_string_view&lt;Char&gt;(format_str),
        make_format_args&lt;typename buffer_context&lt;Char&gt;::type&gt;(args...));
}

template &lt;typename OutputIt, typename Char = char&gt;
//using format_context_t = basic_format_context&lt;OutputIt, Char&gt;;
struct format_context_t { typedef basic_format_context&lt;OutputIt, Char&gt; type; };

template &lt;typename OutputIt, typename Char = char&gt;
//using format_args_t = basic_format_args&lt;format_context_t&lt;OutputIt, Char&gt;&gt;;
struct format_args_t {
</t>
<t tx="leo.20220407205633.37">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include &lt;atomic&gt;
// null, no cost dummy "mutex" and dummy "atomic" int

namespace spdlog {
namespace details {
struct null_mutex
{
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.370">  typedef basic_format_args&lt;
    typename format_context_t&lt;OutputIt, Char&gt;::type&gt; type;
};

template &lt;typename OutputIt, typename... Args&gt;
inline OutputIt vformat_to(OutputIt out, string_view format_str,
                           typename format_args_t&lt;OutputIt&gt;::type args) {
  typedef output_range&lt;OutputIt, char&gt; range;
  return vformat_to&lt;arg_formatter&lt;range&gt;&gt;(range(out), format_str, args);
}
template &lt;typename OutputIt, typename... Args&gt;
inline OutputIt vformat_to(
    OutputIt out, wstring_view format_str,
    typename format_args_t&lt;OutputIt, wchar_t&gt;::type args) {
  typedef output_range&lt;OutputIt, wchar_t&gt; range;
  return vformat_to&lt;arg_formatter&lt;range&gt;&gt;(range(out), format_str, args);
}

/**
 \rst
 Formats arguments, writes the result to the output iterator ``out`` and returns
 the iterator past the end of the output range.

 **Example**::

   std::vector&lt;char&gt; out;
   fmt::format_to(std::back_inserter(out), "{}", 42);
 \endrst
 */
template &lt;typename OutputIt, typename... Args&gt;
inline OutputIt format_to(OutputIt out, string_view format_str,
</t>
<t tx="leo.20220407205633.371">                          const Args &amp; ... args) {
  return vformat_to(out, format_str,
      make_format_args&lt;typename format_context_t&lt;OutputIt&gt;::type&gt;(args...));
}

template &lt;typename OutputIt&gt;
struct format_to_n_result {
  /** Iterator past the end of the output range. */
  OutputIt out;
  /** Total (not truncated) output size. */
  std::size_t size;
};

template &lt;typename OutputIt&gt;
using format_to_n_context = typename fmt::format_context_t&lt;
  fmt::internal::truncating_iterator&lt;OutputIt&gt;&gt;::type;

template &lt;typename OutputIt&gt;
using format_to_n_args = fmt::basic_format_args&lt;format_to_n_context&lt;OutputIt&gt;&gt;;

template &lt;typename OutputIt, typename ...Args&gt;
inline format_arg_store&lt;format_to_n_context&lt;OutputIt&gt;, Args...&gt;
    make_format_to_n_args(const Args &amp; ... args) {
  return format_arg_store&lt;format_to_n_context&lt;OutputIt&gt;, Args...&gt;(args...);
}

template &lt;typename OutputIt, typename... Args&gt;
inline format_to_n_result&lt;OutputIt&gt; vformat_to_n(
    OutputIt out, std::size_t n, string_view format_str,
    format_to_n_args&lt;OutputIt&gt; args) {
  typedef internal::truncating_iterator&lt;OutputIt&gt; It;
  auto it = vformat_to(It(out, n), format_str, args);
  return {it.base(), it.count()};
}

/**
 \rst
 Formats arguments, writes up to ``n`` characters of the result to the output
 iterator ``out`` and returns the total output size and the iterator past the
 end of the output range.
 \endrst
 */
template &lt;typename OutputIt, typename... Args&gt;
inline format_to_n_result&lt;OutputIt&gt; format_to_n(
    OutputIt out, std::size_t n, string_view format_str, const Args &amp;... args) {
  return vformat_to_n&lt;OutputIt&gt;(
    out, n, format_str, make_format_to_n_args&lt;OutputIt&gt;(args...));
}
template &lt;typename OutputIt, typename... Args&gt;
inline format_to_n_result&lt;OutputIt&gt; format_to_n(
    OutputIt out, std::size_t n, wstring_view format_str,
</t>
<t tx="leo.20220407205633.372">    const Args &amp;... args) {
  typedef internal::truncating_iterator&lt;OutputIt&gt; It;
  @others
}

template &lt;typename String, typename... Args&gt;
inline typename std::enable_if&lt;internal::is_compile_string&lt;String&gt;::value&gt;::type
    print(String format_str, const Args &amp; ... args) {
  internal::check_format_string&lt;Args...&gt;(format_str);
  return vprint(format_str.data(), make_format_args(args...));
}

/**
  Returns the number of characters in the output of
  ``format(format_str, args...)``.
 */
template &lt;typename... Args&gt;
inline std::size_t formatted_size(string_view format_str,
</t>
<t tx="leo.20220407205633.373">  auto it = vformat_to(It(out, n), format_str,
      make_format_args&lt;typename format_context_t&lt;It, wchar_t&gt;::type&gt;(args...));
  return {it.base(), it.count()};
}

template &lt;typename Char&gt;
inline std::basic_string&lt;Char&gt; internal::vformat(
    basic_string_view&lt;Char&gt; format_str,
    basic_format_args&lt;typename buffer_context&lt;Char&gt;::type&gt; args) {
  basic_memory_buffer&lt;Char&gt; buffer;
  vformat_to(buffer, format_str, args);
  return fmt::to_string(buffer);
</t>
<t tx="leo.20220407205633.374">                                  const Args &amp; ... args) {
  auto it = format_to(internal::counting_iterator&lt;char&gt;(), format_str, args...);
  return it.count();
}

#if FMT_USE_USER_DEFINED_LITERALS
namespace internal {

# if FMT_UDL_TEMPLATE
template &lt;typename Char, Char... CHARS&gt;
</t>
<t tx="leo.20220407205633.375">class udl_formatter {
 public:
  template &lt;typename... Args&gt;
  std::basic_string&lt;Char&gt; operator()(const Args &amp;... args) const {
    FMT_CONSTEXPR_DECL Char s[] = {CHARS..., '\0'};
    FMT_CONSTEXPR_DECL bool invalid_format =
        check_format_string&lt;Char, error_handler, Args...&gt;(
          basic_string_view&lt;Char&gt;(s, sizeof...(CHARS)));
    (void)invalid_format;
    return format(s, args...);
  }
};
# else
template &lt;typename Char&gt;
struct udl_formatter {
  const Char *str;

  template &lt;typename... Args&gt;
</t>
<t tx="leo.20220407205633.376">  auto operator()(Args &amp;&amp; ... args) const
                  -&gt; decltype(format(str, std::forward&lt;Args&gt;(args)...)) {
    return format(str, std::forward&lt;Args&gt;(args)...);
  }
};
# endif // FMT_UDL_TEMPLATE

template &lt;typename Char&gt;
struct udl_arg {
  const Char *str;

  template &lt;typename T&gt;
  named_arg&lt;T, Char&gt; operator=(T &amp;&amp;value) const {
    return {str, std::forward&lt;T&gt;(value)};
  }
};

} // namespace internal

inline namespace literals {

# if FMT_UDL_TEMPLATE
template &lt;typename Char, Char... CHARS&gt;
FMT_CONSTEXPR internal::udl_formatter&lt;Char, CHARS...&gt; operator""_format() {
  return {};
}
# else
/**
  \rst
  User-defined literal equivalent of :func:`fmt::format`.

  **Example**::

    using namespace fmt::literals;
    std::string message = "The answer is {}"_format(42);
  \endrst
 */
inline internal::udl_formatter&lt;char&gt;
operator"" _format(const char *s, std::size_t) { return {s}; }
inline internal::udl_formatter&lt;wchar_t&gt;
operator"" _format(const wchar_t *s, std::size_t) { return {s}; }
# endif // FMT_UDL_TEMPLATE

/**
  \rst
  User-defined literal equivalent of :func:`fmt::arg`.

  **Example**::

    using namespace fmt::literals;
    fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
  \endrst
 */
inline internal::udl_arg&lt;char&gt;
operator"" _a(const char *s, std::size_t) { return {s}; }
inline internal::udl_arg&lt;wchar_t&gt;
operator"" _a(const wchar_t *s, std::size_t) { return {s}; }
} // inline namespace literals
#endif // FMT_USE_USER_DEFINED_LITERALS
FMT_END_NAMESPACE

#define FMT_STRING(s) [] { \
    typedef typename std::decay&lt;decltype(s)&gt;::type pointer; \
    struct S : fmt::compile_string { \
      static FMT_CONSTEXPR pointer data() { return s; } \
      static FMT_CONSTEXPR size_t size() { return sizeof(s); } \
      explicit operator fmt::string_view() const { return s; } \
    }; \
    return S{}; \
  }()

#if defined(FMT_STRING_ALIAS) &amp;&amp; FMT_STRING_ALIAS
/**
  \rst
  Constructs a compile-time format string. This macro is disabled by default to
  prevent potential name collisions. To enable it define ``FMT_STRING_ALIAS`` to
  1 before including ``fmt/format.h``.

  **Example**::

    #define FMT_STRING_ALIAS 1
    #include &lt;fmt/format.h&gt;
    // A compile-time error because 'd' is an invalid specifier for strings.
    std::string s = format(fmt("{:d}"), "foo");
  \endrst
 */
# define fmt(s) FMT_STRING(s)
#endif

#ifdef FMT_HEADER_ONLY
# define FMT_FUNC inline
# include "format-inl.h"
#else
# define FMT_FUNC
#endif

// Restore warnings.
#if FMT_GCC_VERSION &gt;= 406 || FMT_CLANG_VERSION
# pragma GCC diagnostic pop
#endif

#endif  // FMT_FORMAT_H_
</t>
<t tx="leo.20220407205633.377">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++ - std::ostream support
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_OSTREAM_H_
#define FMT_OSTREAM_H_

#include "format.h"
#include &lt;ostream&gt;

FMT_BEGIN_NAMESPACE
namespace internal {

template &lt;class Char&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.378">class formatbuf : public std::basic_streambuf&lt;Char&gt; {
 private:
  typedef typename std::basic_streambuf&lt;Char&gt;::int_type int_type;
  typedef typename std::basic_streambuf&lt;Char&gt;::traits_type traits_type;

  basic_buffer&lt;Char&gt; &amp;buffer_;

 public:
  formatbuf(basic_buffer&lt;Char&gt; &amp;buffer) : buffer_(buffer) {}

 protected:
  // The put-area is actually always empty. This makes the implementation
  // simpler and has the advantage that the streambuf and the buffer are always
  // in sync and sputc never writes into uninitialized memory. The obvious
  // disadvantage is that each call to sputc always results in a (virtual) call
  // to overflow. There is no disadvantage here for sputn since this always
  // results in a call to xsputn.

  @others
};

template &lt;typename Char&gt;
struct test_stream : std::basic_ostream&lt;Char&gt; {
 private:
  struct null;
  // Hide all operator&lt;&lt; from std::basic_ostream&lt;Char&gt;.
  void operator&lt;&lt;(null);
};

// Checks if T has a user-defined operator&lt;&lt; (e.g. not a member of std::ostream).
template &lt;typename T, typename Char&gt;
</t>
<t tx="leo.20220407205633.379">int_type overflow(int_type ch = traits_type::eof()) FMT_OVERRIDE {
  if (!traits_type::eq_int_type(ch, traits_type::eof()))
    buffer_.push_back(static_cast&lt;Char&gt;(ch));
  return ch;
}

std::streamsize xsputn(const Char *s, std::streamsize count) FMT_OVERRIDE {
  buffer_.append(s, s + count);
  return count;
}
</t>
<t tx="leo.20220407205633.38">    void lock() {}
    void unlock() {}
    bool try_lock()
    {
        return true;
    }
};

struct null_atomic_int
{
    int value;
    null_atomic_int() = default;

    explicit null_atomic_int(int val)
        : value(val)
    {
    }

</t>
<t tx="leo.20220407205633.380">class is_streamable {
 private:
  template &lt;typename U&gt;
  static decltype(
};

// Write the content of buf to os.
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.381">void write(std::basic_ostream&lt;Char&gt; &amp;os, basic_buffer&lt;Char&gt; &amp;buf) {
  const Char *data = buf.data();
  typedef std::make_unsigned&lt;std::streamsize&gt;::type UnsignedStreamSize;
  UnsignedStreamSize size = buf.size();
  UnsignedStreamSize max_size =
      internal::to_unsigned((std::numeric_limits&lt;std::streamsize&gt;::max)());
  do {
    UnsignedStreamSize n = size &lt;= max_size ? size : max_size;
    os.write(data, static_cast&lt;std::streamsize&gt;(n));
    data += n;
    size -= n;
  } while (size != 0);
}

template &lt;typename Char, typename T&gt;
</t>
<t tx="leo.20220407205633.382">void format_value(basic_buffer&lt;Char&gt; &amp;buffer, const T &amp;value) {
  internal::formatbuf&lt;Char&gt; format_buf(buffer);
  std::basic_ostream&lt;Char&gt; output(&amp;format_buf);
  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
  output &lt;&lt; value;
  buffer.resize(buffer.size());
}
}  // namespace internal

// Disable conversion to int if T has an overloaded operator&lt;&lt; which is a free
// function (not a member of std::ostream).
template &lt;typename T, typename Char&gt;
struct convert_to_int&lt;T, Char, void&gt; {
  static const bool value =
        typename buffer_context&lt;Char&gt;::type, T&gt;::value&gt;::type&gt;
    : formatter&lt;basic_string_view&lt;Char&gt;, Char&gt; {

  template &lt;typename Context&gt;
</t>
<t tx="leo.20220407205633.383">  auto format(const T &amp;value, Context &amp;ctx) -&gt; decltype(ctx.out()) {
    basic_memory_buffer&lt;Char&gt; buffer;
    internal::format_value(buffer, value);
    basic_string_view&lt;Char&gt; str(buffer.data(), buffer.size());
    return formatter&lt;basic_string_view&lt;Char&gt;, Char&gt;::format(str, ctx);
  }
};

template &lt;typename Char&gt;
inline void vprint(std::basic_ostream&lt;Char&gt; &amp;os,
                   basic_string_view&lt;Char&gt; format_str,
                   basic_format_args&lt;typename buffer_context&lt;Char&gt;::type&gt; args) {
  basic_memory_buffer&lt;Char&gt; buffer;
  vformat_to(buffer, format_str, args);
  internal::write(os, buffer);
}
/**
  \rst
  Prints formatted data to the stream *os*.

  **Example**::

    fmt::print(cerr, "Don't {}!", "panic");
  \endrst
 */
template &lt;typename... Args&gt;
inline void print(std::ostream &amp;os, string_view format_str,
</t>
<t tx="leo.20220407205633.384">                  const Args &amp; ... args) {
  vprint&lt;char&gt;(os, format_str, make_format_args&lt;format_context&gt;(args...));
}

template &lt;typename... Args&gt;
inline void print(std::wostream &amp;os, wstring_view format_str,
</t>
<t tx="leo.20220407205633.385">                  const Args &amp; ... args) {
  vprint&lt;wchar_t&gt;(os, format_str, make_format_args&lt;wformat_context&gt;(args...));
}
FMT_END_NAMESPACE

#endif  // FMT_OSTREAM_H_
</t>
<t tx="leo.20220407205633.386">@path ./v-rep_plugin/spdlog/fmt/bundled/
// A C++ interface to POSIX functions.
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_POSIX_H_
#define FMT_POSIX_H_

#if defined(__MINGW32__) || defined(__CYGWIN__)
// Workaround MinGW bug https://sourceforge.net/p/mingw/bugs/2024/.
# undef __STRICT_ANSI__
#endif

#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;   // for O_RDONLY
#include &lt;locale.h&gt;  // for locale_t
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  // for strtod_l

#include &lt;cstddef&gt;

#if defined __APPLE__ || defined(__FreeBSD__)
# include &lt;xlocale.h&gt;  // for LC_NUMERIC_MASK on OS X
#endif

#include "format.h"

#ifndef FMT_POSIX
# if defined(_WIN32) &amp;&amp; !defined(__MINGW32__)
// Fix warnings about deprecated symbols.
#  define FMT_POSIX(call) _##call
# else
#  define FMT_POSIX(call) call
# endif
#endif

// Calls to system functions are wrapped in FMT_SYSTEM for testability.
#ifdef FMT_SYSTEM
# define FMT_POSIX_CALL(call) FMT_SYSTEM(call)
#else
# define FMT_SYSTEM(call) call
# ifdef _WIN32
// Fix warnings about deprecated symbols.
#  define FMT_POSIX_CALL(call) ::_##call
# else
#  define FMT_POSIX_CALL(call) ::call
# endif
#endif

// Retries the expression while it evaluates to error_result and errno
// equals to EINTR.
#ifndef _WIN32
# define FMT_RETRY_VAL(result, expression, error_result) \
  do { \
    result = (expression); \
  } while (result == error_result &amp;&amp; errno == EINTR)
#else
# define FMT_RETRY_VAL(result, expression, error_result) result = (expression)
#endif

#define FMT_RETRY(result, expression) FMT_RETRY_VAL(result, expression, -1)

FMT_BEGIN_NAMESPACE

/**
  \rst
  A reference to a null-terminated string. It can be constructed from a C
  string or ``std::string``.

  You can use one of the following typedefs for common character types:

  +---------------+-----------------------------+
  | Type          | Definition                  |
  +===============+=============================+
  | cstring_view  | basic_cstring_view&lt;char&gt;    |
  +---------------+-----------------------------+
  | wcstring_view | basic_cstring_view&lt;wchar_t&gt; |
  +---------------+-----------------------------+

  This class is most useful as a parameter type to allow passing
  different types of strings to a function, for example::

    template &lt;typename... Args&gt;
    std::string format(cstring_view format_str, const Args &amp; ... args);

    format("{}", 42);
    format(std::string("{}"), 42);
  \endrst
 */
template &lt;typename Char&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.387">class basic_cstring_view {
 private:
  const Char *data_;

 public:
  /** Constructs a string reference object from a C string. */
  basic_cstring_view(const Char *s) : data_(s) {}

  /**
    \rst
    Constructs a string reference from an ``std::string`` object.
    \endrst
   */
  basic_cstring_view(const std::basic_string&lt;Char&gt; &amp;s) : data_(s.c_str()) {}

  /** Returns the pointer to a C string. */
  const Char *c_str() const { return data_; }
};

typedef basic_cstring_view&lt;char&gt; cstring_view;
typedef basic_cstring_view&lt;wchar_t&gt; wcstring_view;

// An error code.
</t>
<t tx="leo.20220407205633.388">class error_code {
 private:
  int value_;

 public:
  explicit error_code(int value = 0) FMT_NOEXCEPT : value_(value) {}

  int get() const FMT_NOEXCEPT { return value_; }
};

// A buffered file.
</t>
<t tx="leo.20220407205633.389">class buffered_file {
 private:
  FILE *file_;

  friend class file;

  explicit buffered_file(FILE *f) : file_(f) {}

 public:
  // Constructs a buffered_file object which doesn't represent any file.
  buffered_file() FMT_NOEXCEPT : file_(FMT_NULL) {}

  // Destroys the object closing the file it represents if any.
  FMT_API ~buffered_file() FMT_DTOR_NOEXCEPT;

 private:
  buffered_file(const buffered_file &amp;) = delete;
  void operator=(const buffered_file &amp;) = delete;


 public:
  buffered_file(buffered_file &amp;&amp;other) FMT_NOEXCEPT : file_(other.file_) {
    other.file_ = FMT_NULL;
  }

  buffered_file&amp; operator=(buffered_file &amp;&amp;other) {
    close();
    file_ = other.file_;
    other.file_ = FMT_NULL;
    return *this;
  }

  // Opens a file.
  FMT_API buffered_file(cstring_view filename, cstring_view mode);

  // Closes the file.
  FMT_API void close();

  // Returns the pointer to a FILE object representing this file.
  FILE *get() const FMT_NOEXCEPT { return file_; }

  // We place parentheses around fileno to workaround a bug in some versions
  // of MinGW that define fileno as a macro.
  FMT_API int (fileno)() const;

  @others
};

// A file. Closed file is represented by a file object with descriptor -1.
// Methods that are not declared with FMT_NOEXCEPT may throw
// fmt::system_error in case of failure. Note that some errors such as
// closing the file multiple times will cause a crash on Windows rather
// than an exception. You can get standard behavior by overriding the
// invalid parameter handler with _set_invalid_parameter_handler.
</t>
<t tx="leo.20220407205633.39">int load(std::memory_order) const
{
    return value;
}

</t>
<t tx="leo.20220407205633.390">void vprint(string_view format_str, format_args args) {
  fmt::vprint(file_, format_str, args);
}

template &lt;typename... Args&gt;
inline void print(string_view format_str, const Args &amp; ... args) {
  vprint(format_str, make_format_args(args...));
}
</t>
<t tx="leo.20220407205633.391">class file {
 private:
  int fd_;  // File descriptor.

  // Constructs a file object with a given descriptor.
  explicit file(int fd) : fd_(fd) {}

 public:
  // Possible values for the oflag argument to the constructor.
  enum {
    RDONLY = FMT_POSIX(O_RDONLY), // Open for reading only.
    WRONLY = FMT_POSIX(O_WRONLY), // Open for writing only.
    RDWR   = FMT_POSIX(O_RDWR)    // Open for reading and writing.
  };

  // Constructs a file object which doesn't represent any file.
  file() FMT_NOEXCEPT : fd_(-1) {}

  // Opens a file and constructs a file object representing this file.
  FMT_API file(cstring_view path, int oflag);

 private:
  file(const file &amp;) = delete;
  void operator=(const file &amp;) = delete;

 public:
  file(file &amp;&amp;other) FMT_NOEXCEPT : fd_(other.fd_) {
    other.fd_ = -1;
  }

  file&amp; operator=(file &amp;&amp;other) {
    close();
    fd_ = other.fd_;
    other.fd_ = -1;
    return *this;
  }

  // Destroys the object closing the file it represents if any.
  FMT_API ~file() FMT_DTOR_NOEXCEPT;

  // Returns the file descriptor.
  int descriptor() const FMT_NOEXCEPT { return fd_; }

  // Closes the file.
  FMT_API void close();

  // Returns the file size. The size has signed type for consistency with
  // stat::st_size.
  FMT_API long long size() const;

  // Attempts to read count bytes from the file into the specified buffer.
  FMT_API std::size_t read(void *buffer, std::size_t count);

  // Attempts to write count bytes from the specified buffer to the file.
  FMT_API std::size_t write(const void *buffer, std::size_t count);

  // Duplicates a file descriptor with the dup function and returns
  // the duplicate as a file object.
  FMT_API static file dup(int fd);

  // Makes fd be the copy of this file descriptor, closing fd first if
  // necessary.
  FMT_API void dup2(int fd);

  // Makes fd be the copy of this file descriptor, closing fd first if
  // necessary.
  FMT_API void dup2(int fd, error_code &amp;ec) FMT_NOEXCEPT;

  // Creates a pipe setting up read_end and write_end file objects for reading
  // and writing respectively.
  FMT_API static void pipe(file &amp;read_end, file &amp;write_end);

  // Creates a buffered_file object associated with this file and detaches
  // this file object from the file.
  FMT_API buffered_file fdopen(const char *mode);
};

// Returns the memory page size.
long getpagesize();

#if (defined(LC_NUMERIC_MASK) || defined(_MSC_VER)) &amp;&amp; \
    !defined(__ANDROID__) &amp;&amp; !defined(__CYGWIN__) &amp;&amp; !defined(__OpenBSD__) &amp;&amp; \
    !defined(__NEWLIB_H__)
# define FMT_LOCALE
#endif

#ifdef FMT_LOCALE
// A "C" numeric locale.
</t>
<t tx="leo.20220407205633.392">class Locale {
 private:
# ifdef _MSC_VER
  typedef _locale_t locale_t;

  enum { LC_NUMERIC_MASK = LC_NUMERIC };

  @others
};
#endif  // FMT_LOCALE
FMT_END_NAMESPACE

#endif  // FMT_POSIX_H_
</t>
<t tx="leo.20220407205633.393">static locale_t newlocale(int category_mask, const char *locale, locale_t) {
  return _create_locale(category_mask, locale);
}

</t>
<t tx="leo.20220407205633.394">static void freelocale(locale_t locale) {
  _free_locale(locale);
}

</t>
<t tx="leo.20220407205633.395">  static double strtod_l(const char *nptr, char **endptr, _locale_t locale) {
    return _strtod_l(nptr, endptr, locale);
  }
# endif

  locale_t locale_;

  Locale(const Locale &amp;) = delete;
  void operator=(const Locale &amp;) = delete;

 public:
  typedef locale_t Type;

  Locale() : locale_(newlocale(LC_NUMERIC_MASK, "C", FMT_NULL)) {
    if (!locale_)
      FMT_THROW(system_error(errno, "cannot create locale"));
  }
  ~Locale() { freelocale(locale_); }

  Type get() const { return locale_; }

  // Converts string to floating-point number and advances str past the end
  // of the parsed input.
</t>
<t tx="leo.20220407205633.396">double strtod(const char *&amp;str) const {
  char *end = FMT_NULL;
  double result = strtod_l(str, &amp;end, locale_);
  str = end;
  return result;
}
</t>
<t tx="leo.20220407205633.397">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_PRINTF_H_
#define FMT_PRINTF_H_

#include &lt;algorithm&gt;  // std::fill_n
#include &lt;limits&gt;     // std::numeric_limits

#include "ostream.h"

FMT_BEGIN_NAMESPACE
namespace internal {

// Checks if a value fits in int - used to avoid warnings about comparing
// signed and unsigned integers.
template &lt;bool IsSigned&gt;
struct int_checker {
  template &lt;typename T&gt;
  @others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.398">  static bool fits_in_int(T value) {
    unsigned max = std::numeric_limits&lt;int&gt;::max();
    return value &lt;= max;
  }
  static bool fits_in_int(bool) { return true; }
};

template &lt;&gt;
struct int_checker&lt;true&gt; {
  template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.399">  static bool fits_in_int(T value) {
    return value &gt;= std::numeric_limits&lt;int&gt;::min() &amp;&amp;
           value &lt;= std::numeric_limits&lt;int&gt;::max();
  }
  static bool fits_in_int(int) { return true; }
};

</t>
<t tx="leo.20220407205633.4">class circular_q
{
public:
    using item_type = T;

    explicit circular_q(size_t max_items)
        : max_items_(max_items + 1) // one item is reserved as marker for full q
        , v_(max_items_)
    {
    }

    // push back, overrun (oldest) item if no room left
    @others
};
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.40">    void store(int val)
    {
        value = val;
    }
};

} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.400">class printf_precision_handler: public function&lt;int&gt; {
 public:
  template &lt;typename T&gt;
  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, int&gt;::type
      operator()(T value) {
    if (!int_checker&lt;std::numeric_limits&lt;T&gt;::is_signed&gt;::fits_in_int(value))
      FMT_THROW(format_error("number is too big"));
    return static_cast&lt;int&gt;(value);
  }

  template &lt;typename T&gt;
  typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value, int&gt;::type operator()(T) {
    FMT_THROW(format_error("precision is not integer"));
    return 0;
  }
};

// An argument visitor that returns true iff arg is a zero integer.
</t>
<t tx="leo.20220407205633.401">class is_zero_int: public function&lt;bool&gt; {
 public:
  template &lt;typename T&gt;
  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, bool&gt;::type
      operator()(T value) { return value == 0; }

  template &lt;typename T&gt;
  typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value, bool&gt;::type
      operator()(T) { return false; }
};

template &lt;typename T&gt;
struct make_unsigned_or_bool : std::make_unsigned&lt;T&gt; {};

template &lt;&gt;
struct make_unsigned_or_bool&lt;bool&gt; {
  typedef bool type;
};

template &lt;typename T, typename Context&gt;
</t>
<t tx="leo.20220407205633.402">class arg_converter: public function&lt;void&gt; {
 private:
  typedef typename Context::char_type Char;

  basic_format_arg&lt;Context&gt; &amp;arg_;
  typename Context::char_type type_;

 public:
  arg_converter(basic_format_arg&lt;Context&gt; &amp;arg, Char type)
    : arg_(arg), type_(type) {}

  @others
};

// Converts an integer argument to T for printf, if T is an integral type.
// If T is void, the argument is converted to corresponding signed or unsigned
// type depending on the type specifier: 'd' and 'i' - signed, other -
// unsigned).
template &lt;typename T, typename Context, typename Char&gt;
</t>
<t tx="leo.20220407205633.403">void operator()(bool value) {
  if (type_ != 's')
    operator()&lt;bool&gt;(value);
}

template &lt;typename U&gt;
typename std::enable_if&lt;std::is_integral&lt;U&gt;::value&gt;::type
    operator()(U value) {
  bool is_signed = type_ == 'd' || type_ == 'i';
</t>
<t tx="leo.20220407205633.404">  typedef typename std::conditional&lt;
      std::is_same&lt;T, void&gt;::value, U, T&gt;::type TargetType;
  if (const_check(sizeof(TargetType) &lt;= sizeof(int))) {
    // Extra casts are used to silence warnings.
    if (is_signed) {
      arg_ = internal::make_arg&lt;Context&gt;(
        static_cast&lt;int&gt;(static_cast&lt;TargetType&gt;(value)));
    } else {
      typedef typename make_unsigned_or_bool&lt;TargetType&gt;::type Unsigned;
      arg_ = internal::make_arg&lt;Context&gt;(
        static_cast&lt;unsigned&gt;(static_cast&lt;Unsigned&gt;(value)));
    }
  } else {
    if (is_signed) {
      // glibc's printf doesn't sign extend arguments of smaller types:
      //   std::printf("%lld", -42);  // prints "4294967254"
      // but we don't have to do the same because it's a UB.
      arg_ = internal::make_arg&lt;Context&gt;(static_cast&lt;long long&gt;(value));
    } else {
      arg_ = internal::make_arg&lt;Context&gt;(
        static_cast&lt;typename make_unsigned_or_bool&lt;U&gt;::type&gt;(value));
    }
  }
}

template &lt;typename U&gt;
typename std::enable_if&lt;!std::is_integral&lt;U&gt;::value&gt;::type operator()(U) {
  // No coversion needed for non-integral types.
}
</t>
<t tx="leo.20220407205633.405">void convert_arg(basic_format_arg&lt;Context&gt; &amp;arg, Char type) {
  fmt::visit(arg_converter&lt;T, Context&gt;(arg, type), arg);
}

// Converts an integer argument to char for printf.
template &lt;typename Context&gt;
</t>
<t tx="leo.20220407205633.406">class char_converter: public function&lt;void&gt; {
 private:
  basic_format_arg&lt;Context&gt; &amp;arg_;

 public:
  explicit char_converter(basic_format_arg&lt;Context&gt; &amp;arg) : arg_(arg) {}

  template &lt;typename T&gt;
  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value&gt;::type
      operator()(T value) {
    typedef typename Context::char_type Char;
    arg_ = internal::make_arg&lt;Context&gt;(static_cast&lt;Char&gt;(value));
  }

  template &lt;typename T&gt;
  typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value&gt;::type operator()(T) {
    // No coversion needed for non-integral types.
  }
};

// Checks if an argument is a valid printf width specifier and sets
// left alignment if it is negative.
template &lt;typename Char&gt;
</t>
<t tx="leo.20220407205633.407">class printf_width_handler: public function&lt;unsigned&gt; {
 private:
  typedef basic_format_specs&lt;Char&gt; format_specs;

  format_specs &amp;spec_;

 public:
  explicit printf_width_handler(format_specs &amp;spec) : spec_(spec) {}

  template &lt;typename T&gt;
  typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, unsigned&gt;::type
      operator()(T value) {
    typedef typename internal::int_traits&lt;T&gt;::main_type UnsignedType;
    UnsignedType width = static_cast&lt;UnsignedType&gt;(value);
    if (internal::is_negative(value)) {
      spec_.align_ = ALIGN_LEFT;
      width = 0 - width;
    }
    unsigned int_max = std::numeric_limits&lt;int&gt;::max();
    if (width &gt; int_max)
      FMT_THROW(format_error("number is too big"));
    return static_cast&lt;unsigned&gt;(width);
  }

  template &lt;typename T&gt;
  typename std::enable_if&lt;!std::is_integral&lt;T&gt;::value, unsigned&gt;::type
      operator()(T) {
    FMT_THROW(format_error("width is not integer"));
    return 0;
  }
};
}  // namespace internal

template &lt;typename Range&gt;
class printf_arg_formatter;

template &lt;
    typename OutputIt, typename Char,
    typename ArgFormatter =
      printf_arg_formatter&lt;back_insert_range&lt;internal::basic_buffer&lt;Char&gt;&gt;&gt;&gt;
class basic_printf_context;

/**
  \rst
  The ``printf`` argument formatter.
  \endrst
 */
template &lt;typename Range&gt;
</t>
<t tx="leo.20220407205633.408">class printf_arg_formatter:
  public internal::function&lt;
    typename internal::arg_formatter_base&lt;Range&gt;::iterator&gt;,
  public internal::arg_formatter_base&lt;Range&gt; {
 private:
  typedef typename Range::value_type char_type;
  typedef decltype(internal::declval&lt;Range&gt;().begin()) iterator;
  typedef internal::arg_formatter_base&lt;Range&gt; base;
  typedef basic_printf_context&lt;iterator, char_type&gt; context_type;

  context_type &amp;context_;

  @others
};

template &lt;typename T&gt;
struct printf_formatter {
  template &lt;typename ParseContext&gt;
  auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin()) { return ctx.begin(); }

  template &lt;typename FormatContext&gt;
</t>
<t tx="leo.20220407205633.409">void write_null_pointer(char) {
  this-&gt;spec()-&gt;type_ = 0;
  this-&gt;write("(nil)");
}

</t>
<t tx="leo.20220407205633.41">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//
#pragma once

#include "../common.h"

#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;thread&gt;

#ifdef _WIN32

#ifndef NOMINMAX
#define NOMINMAX // prevent windows redefining min/max
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include &lt;io.h&gt;      // _get_osfhandle and _isatty support
#include &lt;process.h&gt; //  _get_pid support
#include &lt;windows.h&gt;

#ifdef __MINGW32__
#include &lt;share.h&gt;
#endif

#else // unix

#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;

#ifdef __linux__
#include &lt;sys/syscall.h&gt; //Use gettid() syscall under linux to get thread id

#elif __FreeBSD__
#include &lt;sys/thr.h&gt; //Use thr_self() syscall under FreeBSD to get thread id
#endif

#endif // unix

#ifndef __has_feature      // Clang - feature checking macros.
#define __has_feature(x) 0 // Compatibility with non-clang compilers.
#endif

namespace spdlog {
namespace details {
namespace os {

inline spdlog::log_clock::time_point now() SPDLOG_NOEXCEPT
{

#if defined __linux__ &amp;&amp; defined SPDLOG_CLOCK_COARSE
    timespec ts;
    ::clock_gettime(CLOCK_REALTIME_COARSE, &amp;ts);
    return std::chrono::time_point&lt;log_clock, typename log_clock::duration&gt;(
        std::chrono::duration_cast&lt;typename log_clock::duration&gt;(std::chrono::seconds(ts.tv_sec) + std::chrono::nanoseconds(ts.tv_nsec)));

#else
    return log_clock::now();
#endif
}
inline std::tm localtime(const std::time_t &amp;time_tt) SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    std::tm tm;
    localtime_s(&amp;tm, &amp;time_tt);
#else
    std::tm tm;
    localtime_r(&amp;time_tt, &amp;tm);
#endif
    return tm;
}

inline std::tm localtime() SPDLOG_NOEXCEPT
{
    std::time_t now_t = time(nullptr);
    return localtime(now_t);
}

inline std::tm gmtime(const std::time_t &amp;time_tt) SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    std::tm tm;
    gmtime_s(&amp;tm, &amp;time_tt);
#else
    std::tm tm;
    gmtime_r(&amp;time_tt, &amp;tm);
#endif
    return tm;
}

inline std::tm gmtime() SPDLOG_NOEXCEPT
{
    std::time_t now_t = time(nullptr);
    return gmtime(now_t);
}

// eol definition
#if !defined(SPDLOG_EOL)
#ifdef _WIN32
#define SPDLOG_EOL "\r\n"
#else
#define SPDLOG_EOL "\n"
#endif
#endif

SPDLOG_CONSTEXPR static const char *default_eol = SPDLOG_EOL;

// folder separator
#ifdef _WIN32
SPDLOG_CONSTEXPR static const char folder_sep = '\\';
#else
SPDLOG_CONSTEXPR static const char folder_sep = '/';
#endif

inline void prevent_child_fd(FILE *f)
{

#ifdef _WIN32
#if !defined(__cplusplus_winrt)
    auto file_handle = (HANDLE)_get_osfhandle(_fileno(f));
    if (!::SetHandleInformation(file_handle, HANDLE_FLAG_INHERIT, 0))
        throw spdlog_ex("SetHandleInformation failed", errno);
#endif
#else
    auto fd = fileno(f);
    if (fcntl(fd, F_SETFD, FD_CLOEXEC) == -1)
    {
        throw spdlog_ex("fcntl with FD_CLOEXEC failed", errno);
    }
#endif
}

// fopen_s on non windows for writing
inline bool fopen_s(FILE **fp, const filename_t &amp;filename, const filename_t &amp;mode)
{
#ifdef _WIN32
#ifdef SPDLOG_WCHAR_FILENAMES
    *fp = _wfsopen((filename.c_str()), mode.c_str(), _SH_DENYNO);
#else
    *fp = _fsopen((filename.c_str()), mode.c_str(), _SH_DENYNO);
#endif
#else // unix
    *fp = fopen((filename.c_str()), mode.c_str());
#endif

#ifdef SPDLOG_PREVENT_CHILD_FD
    if (*fp != nullptr)
    {
        prevent_child_fd(*fp);
    }
#endif
    return *fp == nullptr;
}

inline int remove(const filename_t &amp;filename) SPDLOG_NOEXCEPT
{
#if defined(_WIN32) &amp;&amp; defined(SPDLOG_WCHAR_FILENAMES)
    return _wremove(filename.c_str());
#else
    return std::remove(filename.c_str());
#endif
}

inline int rename(const filename_t &amp;filename1, const filename_t &amp;filename2) SPDLOG_NOEXCEPT
{
#if defined(_WIN32) &amp;&amp; defined(SPDLOG_WCHAR_FILENAMES)
    return _wrename(filename1.c_str(), filename2.c_str());
#else
    return std::rename(filename1.c_str(), filename2.c_str());
#endif
}

// Return if file exists
inline bool file_exists(const filename_t &amp;filename) SPDLOG_NOEXCEPT
{
#ifdef _WIN32
#ifdef SPDLOG_WCHAR_FILENAMES
    auto attribs = GetFileAttributesW(filename.c_str());
#else
    auto attribs = GetFileAttributesA(filename.c_str());
#endif
    return (attribs != INVALID_FILE_ATTRIBUTES &amp;&amp; !(attribs &amp; FILE_ATTRIBUTE_DIRECTORY));
#else // common linux/unix all have the stat system call
    struct stat buffer;
    return (stat(filename.c_str(), &amp;buffer) == 0);
#endif
}

// Return file size according to open FILE* object
inline size_t filesize(FILE *f)
{
    if (f == nullptr)
    {
        throw spdlog_ex("Failed getting file size. fd is null");
    }
#if defined(_WIN32) &amp;&amp; !defined(__CYGWIN__)
    int fd = _fileno(f);
#if _WIN64 // 64 bits
    __int64 ret = _filelengthi64(fd);
    if (ret &gt;= 0)
    {
        return static_cast&lt;size_t&gt;(ret);
    }

#else // windows 32 bits
    long ret = _filelength(fd);
    if (ret &gt;= 0)
    {
        return static_cast&lt;size_t&gt;(ret);
    }
#endif

#else // unix
    int fd = fileno(f);
// 64 bits(but not in osx or cygwin, where fstat64 is deprecated)
#if !defined(__FreeBSD__) &amp;&amp; !defined(__APPLE__) &amp;&amp; (defined(__x86_64__) || defined(__ppc64__)) &amp;&amp; !defined(__CYGWIN__)
    struct stat64 st;
    if (fstat64(fd, &amp;st) == 0)
    {
        return static_cast&lt;size_t&gt;(st.st_size);
    }
#else // unix 32 bits or cygwin
    struct stat st;

    if (fstat(fd, &amp;st) == 0)
    {
        return static_cast&lt;size_t&gt;(st.st_size);
    }
#endif
#endif
    throw spdlog_ex("Failed getting file size from fd", errno);
}

// Return utc offset in minutes or throw spdlog_ex on failure
inline int utc_minutes_offset(const std::tm &amp;tm = details::os::localtime())
{

#ifdef _WIN32
#if _WIN32_WINNT &lt; _WIN32_WINNT_WS08
    TIME_ZONE_INFORMATION tzinfo;
    auto rv = GetTimeZoneInformation(&amp;tzinfo);
#else
    DYNAMIC_TIME_ZONE_INFORMATION tzinfo;
    auto rv = GetDynamicTimeZoneInformation(&amp;tzinfo);
#endif
    if (rv == TIME_ZONE_ID_INVALID)
        throw spdlog::spdlog_ex("Failed getting timezone info. ", errno);

    int offset = -tzinfo.Bias;
    if (tm.tm_isdst)
    {
        offset -= tzinfo.DaylightBias;
    }
    else
    {
        offset -= tzinfo.StandardBias;
    }
    return offset;
#else

#if defined(sun) || defined(__sun) || defined(_AIX)
    // 'tm_gmtoff' field is BSD extension and it's missing on SunOS/Solaris
    struct helper
    {
        @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.410"> void write_null_pointer(wchar_t) {
   this-&gt;spec()-&gt;type_ = 0;
   this-&gt;write(L"(nil)");
 }

public:
 typedef typename base::format_specs format_specs;

 /**
   \rst
   Constructs an argument formatter object.
   *buffer* is a reference to the output buffer and *spec* contains format
   specifier information for standard argument types.
   \endrst
  */
 printf_arg_formatter(internal::basic_buffer&lt;char_type&gt; &amp;buffer,
                      format_specs &amp;spec, context_type &amp;ctx)
   : base(back_insert_range&lt;internal::basic_buffer&lt;char_type&gt;&gt;(buffer), &amp;spec),
     context_(ctx) {}

 template &lt;typename T&gt;
 typename std::enable_if&lt;std::is_integral&lt;T&gt;::value, iterator&gt;::type
     operator()(T value) {
   // MSVC2013 fails to compile separate overloads for bool and char_type so
   // use std::is_same instead.
   if (std::is_same&lt;T, bool&gt;::value) {
     format_specs &amp;fmt_spec = *this-&gt;spec();
     if (fmt_spec.type_ != 's')
       return base::operator()(value ? 1 : 0);
     fmt_spec.type_ = 0;
     this-&gt;write(value != 0);
   } else if (std::is_same&lt;T, char_type&gt;::value) {
     format_specs &amp;fmt_spec = *this-&gt;spec();
     if (fmt_spec.type_ &amp;&amp; fmt_spec.type_ != 'c')
       return (*this)(static_cast&lt;int&gt;(value));
     fmt_spec.flags_ = 0;
     fmt_spec.align_ = ALIGN_RIGHT;
     return base::operator()(value);
   } else {
     return base::operator()(value);
   }
   return this-&gt;out();
 }

 template &lt;typename T&gt;
 typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, iterator&gt;::type
     operator()(T value) {
   return base::operator()(value);
 }

 /** Formats a null-terminated C string. */
 iterator operator()(const char *value) {
   if (value)
     base::operator()(value);
   else if (this-&gt;spec()-&gt;type_ == 'p')
     write_null_pointer(char_type());
   else
     this-&gt;write("(null)");
   return this-&gt;out();
 }

 /** Formats a null-terminated wide C string. */
 iterator operator()(const wchar_t *value) {
   if (value)
     base::operator()(value);
   else if (this-&gt;spec()-&gt;type_ == 'p')
     write_null_pointer(char_type());
   else
     this-&gt;write(L"(null)");
   return this-&gt;out();
 }

 iterator operator()(basic_string_view&lt;char_type&gt; value) {
   return base::operator()(value);
 }

 iterator operator()(monostate value) {
   return base::operator()(value);
 }

 /** Formats a pointer. */
 iterator operator()(const void *value) {
   if (value)
     return base::operator()(value);
   this-&gt;spec()-&gt;type_ = 0;
   write_null_pointer(char_type());
   return this-&gt;out();
 }

 /** Formats an argument of a custom (user-defined) type. */
 iterator operator()(typename basic_format_arg&lt;context_type&gt;::handle handle) {
   handle.format(context_);
   return this-&gt;out();
 }
</t>
<t tx="leo.20220407205633.411">  auto format(const T &amp;value, FormatContext &amp;ctx) -&gt; decltype(ctx.out()) {
    internal::format_value(internal::get_container(ctx.out()), value);
    return ctx.out();
  }
};

/** This template formats data and writes the output to a writer. */
template &lt;typename OutputIt, typename Char, typename ArgFormatter&gt;
</t>
<t tx="leo.20220407205633.412">class basic_printf_context :
  // Inherit publicly as a workaround for the icc bug
  // https://software.intel.com/en-us/forums/intel-c-compiler/topic/783476.
  public internal::context_base&lt;
    OutputIt, basic_printf_context&lt;OutputIt, Char, ArgFormatter&gt;, Char&gt; {
 public:
  /** The character type for the output. */
  typedef Char char_type;

  template &lt;typename T&gt;
  struct formatter_type { typedef printf_formatter&lt;T&gt; type; };

 private:
  typedef internal::context_base&lt;OutputIt, basic_printf_context, Char&gt; base;
  typedef typename base::format_arg format_arg;
  typedef basic_format_specs&lt;char_type&gt; format_specs;
  typedef internal::null_terminating_iterator&lt;char_type&gt; iterator;

  void parse_flags(format_specs &amp;spec, iterator &amp;it);

  // Returns the argument with specified index or, if arg_index is equal
  // to the maximum unsigned value, the next argument.
  format_arg get_arg(
      iterator it,
      unsigned arg_index = (std::numeric_limits&lt;unsigned&gt;::max)());

  // Parses argument index, flags and width and returns the argument index.
  unsigned parse_header(iterator &amp;it, format_specs &amp;spec);

 public:
  /**
   \rst
   Constructs a ``printf_context`` object. References to the arguments and
   the writer are stored in the context object so make sure they have
   appropriate lifetimes.
   \endrst
   */
  basic_printf_context(OutputIt out, basic_string_view&lt;char_type&gt; format_str,
                       basic_format_args&lt;basic_printf_context&gt; args)
    : base(out, format_str, args) {}

  using base::parse_context;
  using base::out;
  using base::advance_to;

  /** Formats stored arguments and writes the output to the range. */
  void format();
};

template &lt;typename OutputIt, typename Char, typename AF&gt;
</t>
<t tx="leo.20220407205633.413">void basic_printf_context&lt;OutputIt, Char, AF&gt;::parse_flags(
    format_specs &amp;spec, iterator &amp;it) {
  for (;;) {
    switch (*it++) {
      case '-':
        spec.align_ = ALIGN_LEFT;
        break;
      case '+':
        spec.flags_ |= SIGN_FLAG | PLUS_FLAG;
        break;
      case '0':
        spec.fill_ = '0';
        break;
      case ' ':
        spec.flags_ |= SIGN_FLAG;
        break;
      case '#':
        spec.flags_ |= HASH_FLAG;
        break;
      default:
        --it;
        return;
    }
  }
}

template &lt;typename OutputIt, typename Char, typename AF&gt;
typename basic_printf_context&lt;OutputIt, Char, AF&gt;::format_arg
  basic_printf_context&lt;OutputIt, Char, AF&gt;::get_arg(
    iterator it, unsigned arg_index) {
  (void)it;
  if (arg_index == std::numeric_limits&lt;unsigned&gt;::max())
    return this-&gt;do_get_arg(this-&gt;parse_context().next_arg_id());
  return base::get_arg(arg_index - 1);
}

template &lt;typename OutputIt, typename Char, typename AF&gt;
</t>
<t tx="leo.20220407205633.414">unsigned basic_printf_context&lt;OutputIt, Char, AF&gt;::parse_header(
  iterator &amp;it, format_specs &amp;spec) {
  unsigned arg_index = std::numeric_limits&lt;unsigned&gt;::max();
  char_type c = *it;
  if (c &gt;= '0' &amp;&amp; c &lt;= '9') {
    // Parse an argument index (if followed by '$') or a width possibly
    // preceded with '0' flag(s).
    internal::error_handler eh;
    unsigned value = parse_nonnegative_int(it, eh);
    if (*it == '$') {  // value is an argument index
      ++it;
      arg_index = value;
    } else {
      if (c == '0')
        spec.fill_ = '0';
      if (value != 0) {
        // Nonzero value means that we parsed width and don't need to
        // parse it or flags again, so return now.
        spec.width_ = value;
        return arg_index;
      }
    }
  }
  parse_flags(spec, it);
  // Parse width.
  if (*it &gt;= '0' &amp;&amp; *it &lt;= '9') {
    internal::error_handler eh;
    spec.width_ = parse_nonnegative_int(it, eh);
  } else if (*it == '*') {
    ++it;
    spec.width_ =
        fmt::visit(internal::printf_width_handler&lt;char_type&gt;(spec), get_arg(it));
  }
  return arg_index;
}

template &lt;typename OutputIt, typename Char, typename AF&gt;
</t>
<t tx="leo.20220407205633.415">void basic_printf_context&lt;OutputIt, Char, AF&gt;::format() {
  auto &amp;buffer = internal::get_container(this-&gt;out());
  auto start = iterator(this-&gt;parse_context());
  auto it = start;
  using internal::pointer_from;
  while (*it) {
    char_type c = *it++;
    if (c != '%') continue;
    if (*it == c) {
      buffer.append(pointer_from(start), pointer_from(it));
      start = ++it;
      continue;
    }
    buffer.append(pointer_from(start), pointer_from(it) - 1);

    format_specs spec;
    spec.align_ = ALIGN_RIGHT;

    // Parse argument index, flags and width.
    unsigned arg_index = parse_header(it, spec);

    // Parse precision.
    if (*it == '.') {
      ++it;
      if ('0' &lt;= *it &amp;&amp; *it &lt;= '9') {
        internal::error_handler eh;
        spec.precision_ = static_cast&lt;int&gt;(parse_nonnegative_int(it, eh));
      } else if (*it == '*') {
        ++it;
        spec.precision_ =
            fmt::visit(internal::printf_precision_handler(), get_arg(it));
      } else {
        spec.precision_ = 0;
      }
    }

    format_arg arg = get_arg(it, arg_index);
    if (spec.flag(HASH_FLAG) &amp;&amp; fmt::visit(internal::is_zero_int(), arg))
      spec.flags_ &amp;= ~internal::to_unsigned&lt;int&gt;(HASH_FLAG);
    if (spec.fill_ == '0') {
      if (arg.is_arithmetic())
        spec.align_ = ALIGN_NUMERIC;
      else
        spec.fill_ = ' ';  // Ignore '0' flag for non-numeric types.
    }

    // Parse length and convert the argument to the required type.
    using internal::convert_arg;
    switch (*it++) {
    case 'h':
      if (*it == 'h')
        convert_arg&lt;signed char&gt;(arg, *++it);
      else
        convert_arg&lt;short&gt;(arg, *it);
      break;
    case 'l':
      if (*it == 'l')
        convert_arg&lt;long long&gt;(arg, *++it);
      else
        convert_arg&lt;long&gt;(arg, *it);
      break;
    case 'j':
      convert_arg&lt;intmax_t&gt;(arg, *it);
      break;
    case 'z':
      convert_arg&lt;std::size_t&gt;(arg, *it);
      break;
    case 't':
      convert_arg&lt;std::ptrdiff_t&gt;(arg, *it);
      break;
    case 'L':
      // printf produces garbage when 'L' is omitted for long double, no
      // need to do the same.
      break;
    default:
      --it;
      convert_arg&lt;void&gt;(arg, *it);
    }

    // Parse type.
    if (!*it)
      FMT_THROW(format_error("invalid format string"));
    spec.type_ = static_cast&lt;char&gt;(*it++);
    if (arg.is_integral()) {
      // Normalize type.
      switch (spec.type_) {
      case 'i': case 'u':
        spec.type_ = 'd';
        break;
      case 'c':
        // TODO: handle wchar_t better?
        fmt::visit(internal::char_converter&lt;basic_printf_context&gt;(arg), arg);
        break;
      }
    }

    start = it;

    // Format argument.
    fmt::visit(AF(buffer, spec, *this), arg);
  }
  buffer.append(pointer_from(start), pointer_from(it));
}

template &lt;typename Char, typename Context&gt;
</t>
<t tx="leo.20220407205633.416">void printf(internal::basic_buffer&lt;Char&gt; &amp;buf, basic_string_view&lt;Char&gt; format,
            basic_format_args&lt;Context&gt; args) {
  Context(std::back_inserter(buf), format, args).format();
}

template &lt;typename Buffer&gt;
struct printf_context {
</t>
<t tx="leo.20220407205633.417">  typedef basic_printf_context&lt;
    std::back_insert_iterator&lt;Buffer&gt;, typename Buffer::value_type&gt; type;
};

template &lt;typename ...Args&gt;
inline format_arg_store&lt;printf_context&lt;internal::buffer&gt;::type, Args...&gt;
    make_printf_args(const Args &amp; ... args) {
  return format_arg_store&lt;printf_context&lt;internal::buffer&gt;::type, Args...&gt;(
      args...);
}
typedef basic_format_args&lt;printf_context&lt;internal::buffer&gt;::type&gt; printf_args;
typedef basic_format_args&lt;printf_context&lt;internal::wbuffer&gt;::type&gt; wprintf_args;

inline std::string vsprintf(string_view format, printf_args args) {
  memory_buffer buffer;
  printf(buffer, format, args);
  return to_string(buffer);
}

/**
  \rst
  Formats arguments and returns the result as a string.

  **Example**::

    std::string message = fmt::sprintf("The answer is %d", 42);
  \endrst
*/
template &lt;typename... Args&gt;
inline std::string sprintf(string_view format_str, const Args &amp; ... args) {
  return vsprintf(format_str,
    make_format_args&lt;typename printf_context&lt;internal::buffer&gt;::type&gt;(args...));
}

inline std::wstring vsprintf(wstring_view format, wprintf_args args) {
  wmemory_buffer buffer;
  printf(buffer, format, args);
  return to_string(buffer);
}

template &lt;typename... Args&gt;
inline std::wstring sprintf(wstring_view format_str, const Args &amp; ... args) {
  return vsprintf(format_str,
    make_format_args&lt;typename printf_context&lt;internal::wbuffer&gt;::type&gt;(args...));
}

template &lt;typename Char&gt;
inline int vfprintf(std::FILE *f, basic_string_view&lt;Char&gt; format,
                    basic_format_args&lt;typename printf_context&lt;
</t>
<t tx="leo.20220407205633.418">                      internal::basic_buffer&lt;Char&gt;&gt;::type&gt; args) {
  basic_memory_buffer&lt;Char&gt; buffer;
  printf(buffer, format, args);
  std::size_t size = buffer.size();
  return std::fwrite(
    buffer.data(), sizeof(Char), size, f) &lt; size ? -1 : static_cast&lt;int&gt;(size);
}

/**
  \rst
  Prints formatted data to the file *f*.

  **Example**::

    fmt::fprintf(stderr, "Don't %s!", "panic");
  \endrst
 */
template &lt;typename... Args&gt;
inline int fprintf(std::FILE *f, string_view format_str, const Args &amp; ... args) {
</t>
<t tx="leo.20220407205633.419">  auto vargs = make_format_args&lt;
    typename printf_context&lt;internal::buffer&gt;::type&gt;(args...);
  return vfprintf&lt;char&gt;(f, format_str, vargs);
}

template &lt;typename... Args&gt;
inline int fprintf(std::FILE *f, wstring_view format_str,
                   const Args &amp; ... args) {
  return vfprintf(f, format_str,
    make_format_args&lt;typename printf_context&lt;internal::wbuffer&gt;::type&gt;(args...));
}

inline int vprintf(string_view format, printf_args args) {
  return vfprintf(stdout, format, args);
}

inline int vprintf(wstring_view format, wprintf_args args) {
  return vfprintf(stdout, format, args);
}

/**
  \rst
  Prints formatted data to ``stdout``.

  **Example**::

    fmt::printf("Elapsed time: %.2f seconds", 1.23);
  \endrst
 */
template &lt;typename... Args&gt;
inline int printf(string_view format_str, const Args &amp; ... args) {
  return vprintf(format_str,
    make_format_args&lt;typename printf_context&lt;internal::buffer&gt;::type&gt;(args...));
}

template &lt;typename... Args&gt;
inline int printf(wstring_view format_str, const Args &amp; ... args) {
  return vprintf(format_str,
    make_format_args&lt;typename printf_context&lt;internal::wbuffer&gt;::type&gt;(args...));
}

inline int vfprintf(std::ostream &amp;os, string_view format_str,
                    printf_args args) {
  memory_buffer buffer;
  printf(buffer, format_str, args);
  internal::write(os, buffer);
  return static_cast&lt;int&gt;(buffer.size());
}

inline int vfprintf(std::wostream &amp;os, wstring_view format_str,
                    wprintf_args args) {
  wmemory_buffer buffer;
  printf(buffer, format_str, args);
  internal::write(os, buffer);
  return static_cast&lt;int&gt;(buffer.size());
}

/**
  \rst
  Prints formatted data to the stream *os*.

  **Example**::

    fmt::fprintf(cerr, "Don't %s!", "panic");
  \endrst
 */
template &lt;typename... Args&gt;
inline int fprintf(std::ostream &amp;os, string_view format_str,
</t>
<t tx="leo.20220407205633.42">        static long int calculate_gmt_offset(const std::tm &amp;localtm = details::os::localtime(), const std::tm &amp;gmtm = details::os::gmtime())
        {
            int local_year = localtm.tm_year + (1900 - 1);
            int gmt_year = gmtm.tm_year + (1900 - 1);

            long int days = (
                // difference in day of year
                localtm.tm_yday -
                gmtm.tm_yday

                // + intervening leap days
                + ((local_year &gt;&gt; 2) - (gmt_year &gt;&gt; 2)) - (local_year / 100 - gmt_year / 100) +
                ((local_year / 100 &gt;&gt; 2) - (gmt_year / 100 &gt;&gt; 2))

                // + difference in years * 365 */
                + (long int)(local_year - gmt_year) * 365);

            long int hours = (24 * days) + (localtm.tm_hour - gmtm.tm_hour);
            long int mins = (60 * hours) + (localtm.tm_min - gmtm.tm_min);
            long int secs = (60 * mins) + (localtm.tm_sec - gmtm.tm_sec);

            return secs;
        }
    };

    auto offset_seconds = helper::calculate_gmt_offset(tm);
#else
    auto offset_seconds = tm.tm_gmtoff;
#endif

    return static_cast&lt;int&gt;(offset_seconds / 60);
#endif
}

// Return current thread id as size_t
// It exists because the std::this_thread::get_id() is much slower(especially
// under VS 2013)
inline size_t _thread_id() SPDLOG_NOEXCEPT
{
#ifdef _WIN32
    return static_cast&lt;size_t&gt;(::GetCurrentThreadId());
#elif __linux__
#if defined(__ANDROID__) &amp;&amp; defined(__ANDROID_API__) &amp;&amp; (__ANDROID_API__ &lt; 21)
#define SYS_gettid __NR_gettid
#endif
    return static_cast&lt;size_t&gt;(syscall(SYS_gettid));
#elif __FreeBSD__
    long tid;
    thr_self(&amp;tid);
    return static_cast&lt;size_t&gt;(tid);
#elif __APPLE__
    uint64_t tid;
    pthread_threadid_np(nullptr, &amp;tid);
    return static_cast&lt;size_t&gt;(tid);
#else // Default to standard C++11 (other Unix)
    return static_cast&lt;size_t&gt;(std::hash&lt;std::thread::id&gt;()(std::this_thread::get_id()));
#endif
}

// Return current thread id as size_t (from thread local storage)
inline size_t thread_id() SPDLOG_NOEXCEPT
{
#if defined(SPDLOG_NO_TLS)
    return _thread_id();
#else // cache thread id in tls
    static thread_local const size_t tid = _thread_id();
    return tid;
#endif
}

// This is avoid msvc issue in sleep_for that happens if the clock changes.
// See https://github.com/gabime/spdlog/issues/609
inline void sleep_for_millis(int milliseconds) SPDLOG_NOEXCEPT
{
#if defined(_WIN32)
    ::Sleep(milliseconds);
#else
    std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
#endif
}

// wchar support for windows file names (SPDLOG_WCHAR_FILENAMES must be defined)
#if defined(_WIN32) &amp;&amp; defined(SPDLOG_WCHAR_FILENAMES)
#define SPDLOG_FILENAME_T(s) L##s
inline std::string filename_to_str(const filename_t &amp;filename)
{
    std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;, wchar_t&gt; c;
    return c.to_bytes(filename);
}
#else
#define SPDLOG_FILENAME_T(s) s
inline std::string filename_to_str(const filename_t &amp;filename)
{
    return filename;
}
#endif

inline int pid()
{

#ifdef _WIN32
    return static_cast&lt;int&gt;(::GetCurrentProcessId());
#else
    return static_cast&lt;int&gt;(::getpid());
#endif
}

// Determine if the terminal supports colors
// Source: https://github.com/agauniyal/rang/
inline bool is_color_terminal() SPDLOG_NOEXCEPT
{
#ifdef _WIN32
    return true;
#else
</t>
<t tx="leo.20220407205633.420">                 const Args &amp; ... args) {
@others
</t>
<t tx="leo.20220407205633.421">  auto vargs = make_format_args&lt;
    typename printf_context&lt;internal::buffer&gt;::type&gt;(args...);
  return vfprintf(os, format_str, vargs);
}

template &lt;typename... Args&gt;
inline int fprintf(std::wostream &amp;os, wstring_view format_str,
                   const Args &amp; ... args) {
  auto vargs = make_format_args&lt;
</t>
<t tx="leo.20220407205633.422">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++ - the core API
//
// Copyright (c) 2012 - present, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.
//
// Copyright (c) 2018 - present, Remotion (Igor Schulz)
// All Rights Reserved
// {fmt} support for ranges, containers and types tuple interface.

#ifndef FMT_RANGES_H_
#define FMT_RANGES_H_

#include "format.h"
#include &lt;type_traits&gt;

// output only up to N items from the range.
#ifndef FMT_RANGE_OUTPUT_LENGTH_LIMIT
# define FMT_RANGE_OUTPUT_LENGTH_LIMIT 256
#endif

FMT_BEGIN_NAMESPACE

template &lt;typename Char&gt;
struct formatting_base {
  template &lt;typename ParseContext&gt;
  FMT_CONSTEXPR auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin()) {
    return ctx.begin();
  }
};

template &lt;typename Char, typename Enable = void&gt;
struct formatting_range : formatting_base&lt;Char&gt; {
  static FMT_CONSTEXPR_DECL const std::size_t range_length_limit =
struct formatting_tuple : formatting_base&lt;Char&gt; {
  Char prefix;
  Char delimiter;
  Char postfix;
  formatting_tuple() : prefix('('), delimiter(','), postfix(')') {}
  static FMT_CONSTEXPR_DECL const bool add_delimiter_spaces = true;
  static FMT_CONSTEXPR_DECL const bool add_prepostfix_space = false;
};

namespace internal {

template &lt;typename RangeT, typename OutputIterator&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205633.423">void copy(const RangeT &amp;range, OutputIterator out) {
  for (auto it = range.begin(), end = range.end(); it != end; ++it)
    *out++ = *it;
}

template &lt;typename OutputIterator&gt;
</t>
<t tx="leo.20220407205633.424">void copy(const char *str, OutputIterator out) {
  const char *p_curr = str;
  while (*p_curr) {
    *out++ = *p_curr++;
  }
}

template &lt;typename OutputIterator&gt;
</t>
<t tx="leo.20220407205633.425">void copy(char ch, OutputIterator out) {
  *out++ = ch;
}

/// Return true value if T has std::string interface, like std::string_view.
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.426">class is_like_std_string {
  template &lt;typename U&gt;
  static auto check(U *p) -&gt;
struct is_like_std_string&lt;fmt::basic_string_view&lt;Char&gt;&gt; : std::true_type {};

template &lt;typename... Ts&gt;
struct conditional_helper {};

template &lt;typename T, typename _ = void&gt;
struct is_range_ : std::false_type {};

#if !FMT_MSC_VER || FMT_MSC_VER &gt; 1800
template &lt;typename T&gt;
struct is_range_&lt;T, typename std::conditional&lt;
                    false,
                    conditional_helper&lt;decltype(internal::declval&lt;T&gt;().begin()),
                                       decltype(internal::declval&lt;T&gt;().end())&gt;,
                    void&gt;::type&gt; : std::true_type {};
#endif

/// tuple_size and tuple_element check.
template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.427">class is_tuple_like_ {
  template &lt;typename U&gt;
  static auto check(U *p) -&gt;
// Check for integer_sequence
#if defined(__cpp_lib_integer_sequence) || FMT_MSC_VER &gt;= 1900
template &lt;typename T, T... N&gt;
using integer_sequence = std::integer_sequence&lt;T, N...&gt;;
template &lt;std::size_t... N&gt;
using index_sequence = std::index_sequence&lt;N...&gt;;
template &lt;std::size_t N&gt;
using make_index_sequence = std::make_index_sequence&lt;N&gt;;
#else
template &lt;typename T, T... N&gt;
struct integer_sequence {
  typedef T value_type;

</t>
<t tx="leo.20220407205633.428">  static FMT_CONSTEXPR std::size_t size() {
    return sizeof...(N);
  }
};

template &lt;std::size_t... N&gt;
using index_sequence = integer_sequence&lt;std::size_t, N...&gt;;

template &lt;typename T, std::size_t N, T... Ns&gt;
struct make_integer_sequence : make_integer_sequence&lt;T, N - 1, N - 1, Ns...&gt; {};
template &lt;typename T, T... Ns&gt;
struct make_integer_sequence&lt;T, 0, Ns...&gt; : integer_sequence&lt;T, Ns...&gt; {};

template &lt;std::size_t N&gt;
using make_index_sequence = make_integer_sequence&lt;std::size_t, N&gt;;
#endif

template &lt;class Tuple, class F, size_t... Is&gt;
</t>
<t tx="leo.20220407205633.429">void for_each(index_sequence&lt;Is...&gt;, Tuple &amp;&amp;tup, F &amp;&amp;f) FMT_NOEXCEPT {
  using std::get;
  // using free function get&lt;I&gt;(T) now.
  const int _[] = {0, ((void)f(get&lt;Is&gt;(tup)), 0)...};
  (void)_;  // blocks warnings
}

template &lt;class T&gt;
FMT_CONSTEXPR make_index_sequence&lt;std::tuple_size&lt;T&gt;::value&gt; 
get_indexes(T const &amp;) { return {}; }

template &lt;class Tuple, class F&gt;
</t>
<t tx="leo.20220407205633.43">static constexpr const char *Terms[] = {
    "ansi", "color", "console", "cygwin", "gnome", "konsole", "kterm", "linux", "msys", "putty", "rxvt", "screen", "vt100", "xterm"};

const char *env_p = std::getenv("TERM");
if (env_p == nullptr)
{
    return false;
}

</t>
<t tx="leo.20220407205633.430">void for_each(Tuple &amp;&amp;tup, F &amp;&amp;f) {
  const auto indexes = get_indexes(tup);
  for_each(indexes, std::forward&lt;Tuple&gt;(tup), std::forward&lt;F&gt;(f));
}

template&lt;typename Arg&gt;
FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const Arg&amp;, 
  typename std::enable_if&lt;
    !is_like_std_string&lt;typename std::decay&lt;Arg&gt;::type&gt;::value&gt;::type* = nullptr) {
  return add_space ? " {}" : "{}";
}

template&lt;typename Arg&gt;
FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const Arg&amp;, 
  typename std::enable_if&lt;
    is_like_std_string&lt;typename std::decay&lt;Arg&gt;::type&gt;::value&gt;::type* = nullptr) {
  return add_space ? " \"{}\"" : "\"{}\"";
}

FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const char*) {
  return add_space ? " \"{}\"" : "\"{}\"";
}
FMT_CONSTEXPR const wchar_t* format_str_quoted(bool add_space, const wchar_t*) {
    return add_space ? L" \"{}\"" : L"\"{}\"";
}

FMT_CONSTEXPR const char* format_str_quoted(bool add_space, const char) {
    return add_space ? " '{}'" : "'{}'";
}
FMT_CONSTEXPR const wchar_t* format_str_quoted(bool add_space, const wchar_t) {
    return add_space ? L" '{}'" : L"'{}'";
}

}  // namespace internal

template &lt;typename T&gt;
struct is_tuple_like {
</t>
<t tx="leo.20220407205633.431">  static FMT_CONSTEXPR_DECL const bool value =
    internal::is_tuple_like_&lt;T&gt;::value &amp;&amp; !internal::is_range_&lt;T&gt;::value;
};

template &lt;typename TupleT, typename Char&gt;
struct formatter&lt;TupleT, Char, 
    typename std::enable_if&lt;fmt::is_tuple_like&lt;TupleT&gt;::value&gt;::type&gt; {
private:
  // C++11 generic lambda for format()
  template &lt;typename FormatContext&gt;
  struct format_each {
    template &lt;typename T&gt;
</t>
<t tx="leo.20220407205633.432">    void operator()(const T&amp; v) {
      if (i &gt; 0) {
        if (formatting.add_prepostfix_space) {
          *out++ = ' ';
        }
        internal::copy(formatting.delimiter, out);
      }
      format_to(out,
                internal::format_str_quoted(
public:
  formatting_tuple&lt;Char&gt; formatting;

  template &lt;typename ParseContext&gt;
  FMT_CONSTEXPR auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin()) {
    return formatting.parse(ctx);
  }

  template &lt;typename FormatContext = format_context&gt;
</t>
<t tx="leo.20220407205633.433">  auto format(const TupleT &amp;values, FormatContext &amp;ctx) -&gt; decltype(ctx.out()) {
    auto out = ctx.out();
    std::size_t i = 0;
    internal::copy(formatting.prefix, out);

    internal::for_each(values, format_each&lt;FormatContext&gt;{formatting, i, out});
    if (formatting.add_prepostfix_space) {
      *out++ = ' ';
    }
    internal::copy(formatting.postfix, out);

    return ctx.out();
  }
};

template &lt;typename T&gt;
struct is_range {
</t>
<t tx="leo.20220407205633.434">  static FMT_CONSTEXPR_DECL const bool value =
    internal::is_range_&lt;T&gt;::value &amp;&amp; !internal::is_like_std_string&lt;T&gt;::value;
};

template &lt;typename RangeT, typename Char&gt;
struct formatter&lt;RangeT, Char,
    typename std::enable_if&lt;fmt::is_range&lt;RangeT&gt;::value&gt;::type&gt; {

  formatting_range&lt;Char&gt; formatting;

  template &lt;typename ParseContext&gt;
  FMT_CONSTEXPR auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin()) {
    return formatting.parse(ctx);
  }

  template &lt;typename FormatContext&gt;
  typename FormatContext::iterator format(
</t>
<t tx="leo.20220407205633.435">      const RangeT &amp;values, FormatContext &amp;ctx) {
    auto out = ctx.out();
    internal::copy(formatting.prefix, out);
    std::size_t i = 0;
    for (auto it = values.begin(), end = values.end(); it != end; ++it) {
      if (i &gt; 0) {
        if (formatting.add_prepostfix_space) {
          *out++ = ' ';
        }
        internal::copy(formatting.delimiter, out);
      }
      format_to(out,
                @others
  }
};

FMT_END_NAMESPACE

#endif // FMT_RANGES_H_

</t>
<t tx="leo.20220407205633.436">            internal::format_str_quoted(
                (formatting.add_delimiter_spaces &amp;&amp; i &gt; 0), *it),
            *it);
  if (++i &gt; formatting.range_length_limit) {
    format_to(out, " ... &lt;other elements&gt;");
    break;
  }
}
if (formatting.add_prepostfix_space) {
  *out++ = ' ';
}
internal::copy(formatting.postfix, out);
return ctx.out();
</t>
<t tx="leo.20220407205633.437">@path ./v-rep_plugin/spdlog/fmt/bundled/
// Formatting library for C++ - time formatting
//
// Copyright (c) 2012 - 2016, Victor Zverovich
// All rights reserved.
//
// For the license information refer to format.h.

#ifndef FMT_TIME_H_
#define FMT_TIME_H_

#include "format.h"
#include &lt;ctime&gt;

FMT_BEGIN_NAMESPACE

// Prevents expansion of a preceding token as a function-style macro.
// Usage: f FMT_NOMACRO()
#define FMT_NOMACRO

namespace internal{
inline null&lt;&gt; localtime_r FMT_NOMACRO(...) { return null&lt;&gt;(); }
inline null&lt;&gt; localtime_s(...) { return null&lt;&gt;(); }
inline null&lt;&gt; gmtime_r(...) { return null&lt;&gt;(); }
inline null&lt;&gt; gmtime_s(...) { return null&lt;&gt;(); }
}

// Thread-safe replacement for std::localtime
inline std::tm localtime(std::time_t time) {
  struct dispatcher {
    std::time_t time_;
    std::tm tm_;

    dispatcher(std::time_t t): time_(t) {}

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.438">bool run() {
  using namespace fmt::internal;
  return handle(localtime_r(&amp;time_, &amp;tm_));
}

bool handle(std::tm *tm) { return tm != FMT_NULL; }

</t>
<t tx="leo.20220407205633.439">bool handle(internal::null&lt;&gt;) {
  using namespace fmt::internal;
  return fallback(localtime_s(&amp;tm_, &amp;time_));
}

bool fallback(int res) { return res == 0; }

</t>
<t tx="leo.20220407205633.44">    static const bool result =
        std::any_of(std::begin(Terms), std::end(Terms), [&amp;](const char *term) { return std::strstr(env_p, term) != nullptr; });
    return result;
#endif
}

// Detrmine if the terminal attached
// Source: https://github.com/agauniyal/rang/
inline bool in_terminal(FILE *file) SPDLOG_NOEXCEPT
{

#ifdef _WIN32
    return _isatty(_fileno(file)) != 0;
#else
    return isatty(fileno(file)) != 0;
#endif
}
} // namespace os
} // namespace details
} // namespace spdlog
</t>
<t tx="leo.20220407205633.440">    bool fallback(internal::null&lt;&gt;) {
      using namespace fmt::internal;
      std::tm *tm = std::localtime(&amp;time_);
      if (tm) tm_ = *tm;
      return tm != FMT_NULL;
    }
  };
  dispatcher lt(time);
  if (lt.run())
    return lt.tm_;
  // Too big time values may be unsupported.
  FMT_THROW(format_error("time_t value out of range"));
}

// Thread-safe replacement for std::gmtime
inline std::tm gmtime(std::time_t time) {
  struct dispatcher {
    std::time_t time_;
    std::tm tm_;

    dispatcher(std::time_t t): time_(t) {}

</t>
<t tx="leo.20220407205633.441">bool run() {
  using namespace fmt::internal;
  return handle(gmtime_r(&amp;time_, &amp;tm_));
}

bool handle(std::tm *tm) { return tm != FMT_NULL; }

</t>
<t tx="leo.20220407205633.442">bool handle(internal::null&lt;&gt;) {
  using namespace fmt::internal;
  return fallback(gmtime_s(&amp;tm_, &amp;time_));
}

bool fallback(int res) { return res == 0; }

</t>
<t tx="leo.20220407205633.443">    bool fallback(internal::null&lt;&gt;) {
      std::tm *tm = std::gmtime(&amp;time_);
      if (tm) tm_ = *tm;
      return tm != FMT_NULL;
    }
  };
  dispatcher gt(time);
  if (gt.run())
    return gt.tm_;
  // Too big time values may be unsupported.
  FMT_THROW(format_error("time_t value out of range"));
}

namespace internal {
inline std::size_t strftime(char *str, std::size_t count, const char *format,
</t>
<t tx="leo.20220407205633.444">                            const std::tm *time) {
  return std::strftime(str, count, format, time);
}

inline std::size_t strftime(wchar_t *str, std::size_t count,
</t>
<t tx="leo.20220407205633.445">                            const wchar_t *format, const std::tm *time) {
  return std::wcsftime(str, count, format, time);
}
}

template &lt;typename Char&gt;
struct formatter&lt;std::tm, Char&gt; {
  template &lt;typename ParseContext&gt;
</t>
<t tx="leo.20220407205633.446">auto parse(ParseContext &amp;ctx) -&gt; decltype(ctx.begin()) {
  auto it = internal::null_terminating_iterator&lt;Char&gt;(ctx);
  if (*it == ':')
    ++it;
  auto end = it;
  while (*end &amp;&amp; *end != '}')
    ++end;
  tm_format.reserve(end - it + 1);
  using internal::pointer_from;
  tm_format.append(pointer_from(it), pointer_from(end));
  tm_format.push_back('\0');
  return pointer_from(end);
}

template &lt;typename FormatContext&gt;
</t>
<t tx="leo.20220407205633.447">  auto format(const std::tm &amp;tm, FormatContext &amp;ctx) -&gt; decltype(ctx.out()) {
    internal::basic_buffer&lt;Char&gt; &amp;buf = internal::get_container(ctx.out());
    std::size_t start = buf.size();
    for (;;) {
      std::size_t size = buf.capacity() - start;
      std::size_t count =
        internal::strftime(&amp;buf[start], size, &amp;tm_format[0], &amp;tm);
      if (count != 0) {
        buf.resize(start + count);
        break;
      }
      if (size &gt;= tm_format.size() * 256) {
        // If the buffer is 256 times larger than the format string, assume
        // that `strftime` gives an empty result. There doesn't seem to be a
        // better way to distinguish the two cases:
        // https://github.com/fmtlib/fmt/issues/367
        break;
      }
      const std::size_t MIN_GROWTH = 10;
      buf.reserve(buf.capacity() + (size &gt; MIN_GROWTH ? size : MIN_GROWTH));
    }
    return ctx.out();
  }

  basic_memory_buffer&lt;Char&gt; tm_format;
};
FMT_END_NAMESPACE

#endif  // FMT_TIME_H_
</t>
<t tx="leo.20220407205633.448"></t>
<t tx="leo.20220407205633.449">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/fmt_helper.h"
#include "spdlog/details/null_mutex.h"
#include "spdlog/details/os.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;android/log.h&gt;
#include &lt;chrono&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;

#if !defined(SPDLOG_ANDROID_RETRIES)
#define SPDLOG_ANDROID_RETRIES 2
#endif

namespace spdlog {
namespace sinks {

/*
 * Android sink (logging using __android_log_write)
 */
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.45">@path ./v-rep_plugin/spdlog/details/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include "spdlog/details/fmt_helper.h"
#include "spdlog/details/log_msg.h"
#include "spdlog/details/os.h"
#include "spdlog/fmt/fmt.h"
#include "spdlog/formatter.h"

#include &lt;array&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;cctype&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

namespace spdlog {
namespace details {

// padding information.
struct padding_info
{
    enum pad_side
    {
        left,
        right,
        center
    };

    padding_info() = default;
    padding_info(size_t width, padding_info::pad_side side)
        : width_(width)
        , side_(side)
    {
    }

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.450">class android_sink final : public base_sink&lt;Mutex&gt;
{
public:
    explicit android_sink(std::string tag = "spdlog", bool use_raw_msg = false)
        : tag_(std::move(tag))
        , use_raw_msg_(use_raw_msg)
    {
    }

protected:
    @others
};

using android_sink_mt = android_sink&lt;std::mutex&gt;;
using android_sink_st = android_sink&lt;details::null_mutex&gt;;
} // namespace sinks

// Create and register android syslog logger

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; android_logger_mt(const std::string &amp;logger_name, const std::string &amp;tag = "spdlog")
{
    return Factory::template create&lt;sinks::android_sink_mt&gt;(logger_name, tag);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; android_logger_st(const std::string &amp;logger_name, const std::string &amp;tag = "spdlog")
{
    return Factory::template create&lt;sinks::android_sink_st&gt;(logger_name, tag);
}

} // namespace spdlog
</t>
<t tx="leo.20220407205633.451">void sink_it_(const details::log_msg &amp;msg) override
{
    const android_LogPriority priority = convert_to_android_(msg.level);
    fmt::memory_buffer formatted;
    if (use_raw_msg_)
    {
        details::fmt_helper::append_string_view(msg.payload, formatted);
    }
    else
    {
        sink::formatter_-&gt;format(msg, formatted);
    }
    formatted.push_back('\0');
    const char *msg_output = formatted.data();

    // See system/core/liblog/logger_write.c for explanation of return value
    int ret = __android_log_write(priority, tag_.c_str(), msg_output);
    int retry_count = 0;
    while ((ret == -11 /*EAGAIN*/) &amp;&amp; (retry_count &lt; SPDLOG_ANDROID_RETRIES))
    {
        details::os::sleep_for_millis(5);
        ret = __android_log_write(priority, tag_.c_str(), msg_output);
        retry_count++;
    }

    if (ret &lt; 0)
    {
        throw spdlog_ex("__android_log_write() failed", ret);
    }
}

</t>
<t tx="leo.20220407205633.452">    void flush_() override {}

private:
    static android_LogPriority convert_to_android_(spdlog::level::level_enum level)
    {
        switch (level)
        {
        case spdlog::level::trace:
            return ANDROID_LOG_VERBOSE;
        case spdlog::level::debug:
            return ANDROID_LOG_DEBUG;
        case spdlog::level::info:
            return ANDROID_LOG_INFO;
        case spdlog::level::warn:
            return ANDROID_LOG_WARN;
        case spdlog::level::err:
            return ANDROID_LOG_ERROR;
        case spdlog::level::critical:
            return ANDROID_LOG_FATAL;
        default:
            return ANDROID_LOG_DEFAULT;
        }
    }

    std::string tag_;
    bool use_raw_msg_;
</t>
<t tx="leo.20220407205633.453">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2017 spdlog authors.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/console_globals.h"
#include "spdlog/details/null_mutex.h"
#include "spdlog/details/os.h"
#include "spdlog/sinks/sink.h"

#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

namespace spdlog {
namespace sinks {

/**
 * This sink prefixes the output with an ANSI escape sequence color code
 * depending on the severity
 * of the message.
 * If no color terminal detected, omit the escape codes.
 */
template&lt;typename TargetStream, class ConsoleMutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.454">class ansicolor_sink final : public sink
{
public:
    using mutex_t = typename ConsoleMutex::mutex_t;
    ansicolor_sink()
        : target_file_(TargetStream::stream())
        , mutex_(ConsoleMutex::mutex())

    {
        should_do_colors_ = details::os::in_terminal(target_file_) &amp;&amp; details::os::is_color_terminal();
        colors_[level::trace] = white;
        colors_[level::debug] = cyan;
        colors_[level::info] = green;
        colors_[level::warn] = yellow + bold;
        colors_[level::err] = red + bold;
        colors_[level::critical] = bold + on_red;
        colors_[level::off] = reset;
    }

    ~ansicolor_sink() override = default;

    ansicolor_sink(const ansicolor_sink &amp;other) = delete;
    ansicolor_sink &amp;operator=(const ansicolor_sink &amp;other) = delete;

    @others
};

using ansicolor_stdout_sink_mt = ansicolor_sink&lt;details::console_stdout, details::console_mutex&gt;;
using ansicolor_stdout_sink_st = ansicolor_sink&lt;details::console_stdout, details::console_nullmutex&gt;;

using ansicolor_stderr_sink_mt = ansicolor_sink&lt;details::console_stderr, details::console_mutex&gt;;
using ansicolor_stderr_sink_st = ansicolor_sink&lt;details::console_stderr, details::console_nullmutex&gt;;

} // namespace sinks

} // namespace spdlog
</t>
<t tx="leo.20220407205633.455">void set_color(level::level_enum color_level, const std::string &amp;color)
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    colors_[color_level] = color;
}

/// Formatting codes
const std::string reset = "\033[m";
const std::string bold = "\033[1m";
const std::string dark = "\033[2m";
const std::string underline = "\033[4m";
const std::string blink = "\033[5m";
const std::string reverse = "\033[7m";
const std::string concealed = "\033[8m";
const std::string clear_line = "\033[K";

// Foreground colors
const std::string black = "\033[30m";
const std::string red = "\033[31m";
const std::string green = "\033[32m";
const std::string yellow = "\033[33m";
const std::string blue = "\033[34m";
const std::string magenta = "\033[35m";
const std::string cyan = "\033[36m";
const std::string white = "\033[37m";

/// Background colors
const std::string on_black = "\033[40m";
const std::string on_red = "\033[41m";
const std::string on_green = "\033[42m";
const std::string on_yellow = "\033[43m";
const std::string on_blue = "\033[44m";
const std::string on_magenta = "\033[45m";
const std::string on_cyan = "\033[46m";
const std::string on_white = "\033[47m";

</t>
<t tx="leo.20220407205633.456">void log(const details::log_msg &amp;msg) override
{
    // Wrap the originally formatted message in color codes.
    // If color is not supported in the terminal, log as is instead.
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);

    fmt::memory_buffer formatted;
    formatter_-&gt;format(msg, formatted);
    if (should_do_colors_ &amp;&amp; msg.color_range_end &gt; msg.color_range_start)
    {
        // before color range
        print_range_(formatted, 0, msg.color_range_start);
        // in color range
        print_ccode_(colors_[msg.level]);
        print_range_(formatted, msg.color_range_start, msg.color_range_end);
        print_ccode_(reset);
        // after color range
        print_range_(formatted, msg.color_range_end, formatted.size());
    }
    else // no color
    {
        print_range_(formatted, 0, formatted.size());
    }
    fflush(target_file_);
}

</t>
<t tx="leo.20220407205633.457">void flush() override
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    fflush(target_file_);
}

</t>
<t tx="leo.20220407205633.458">void set_pattern(const std::string &amp;pattern) final
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    formatter_ = std::unique_ptr&lt;spdlog::formatter&gt;(new pattern_formatter(pattern));
}

</t>
<t tx="leo.20220407205633.459">    void set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter) override
    {
        std::lock_guard&lt;mutex_t&gt; lock(mutex_);
        formatter_ = std::move(sink_formatter);
    }

private:
</t>
<t tx="leo.20220407205633.46">    bool enabled() const
    {
        return width_ != 0;
    }
    const size_t width_ = 0;
    const pad_side side_ = left;
};

</t>
<t tx="leo.20220407205633.460">void print_ccode_(const std::string &amp;color_code)
{
    fwrite(color_code.data(), sizeof(char), color_code.size(), target_file_);
}
</t>
<t tx="leo.20220407205633.461">void print_range_(const fmt::memory_buffer &amp;formatted, size_t start, size_t end)
{
    fwrite(formatted.data() + start, sizeof(char), end - start, target_file_);
}

FILE *target_file_;
mutex_t &amp;mutex_;

bool should_do_colors_;
std::unordered_map&lt;level::level_enum, std::string, level::level_hasher&gt; colors_;
</t>
<t tx="leo.20220407205633.462">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once
//
// base sink templated over a mutex (either dummy or real)
// concrete implementation should override the sink_it_() and flush_()  methods.
// locking is taken care of in this class - no locking needed by the
// implementers..
//

#include "spdlog/common.h"
#include "spdlog/details/log_msg.h"
#include "spdlog/formatter.h"
#include "spdlog/sinks/sink.h"

namespace spdlog {
namespace sinks {
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.463">class base_sink : public sink
{
public:
    base_sink() = default;
    base_sink(const base_sink &amp;) = delete;
    base_sink &amp;operator=(const base_sink &amp;) = delete;

    @others
};
} // namespace sinks
} // namespace spdlog
</t>
<t tx="leo.20220407205633.464">void log(const details::log_msg &amp;msg) final
{
    std::lock_guard&lt;Mutex&gt; lock(mutex_);
    sink_it_(msg);
}

</t>
<t tx="leo.20220407205633.465">void flush() final
{
    std::lock_guard&lt;Mutex&gt; lock(mutex_);
    flush_();
}

</t>
<t tx="leo.20220407205633.466">void set_pattern(const std::string &amp;pattern) final
{
    std::lock_guard&lt;Mutex&gt; lock(mutex_);
    set_pattern_(pattern);
}

</t>
<t tx="leo.20220407205633.467">    void set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter) final
    {
        std::lock_guard&lt;Mutex&gt; lock(mutex_);
        set_formatter_(std::move(sink_formatter));
    }

protected:
    virtual void sink_it_(const details::log_msg &amp;msg) = 0;
    virtual void flush_() = 0;

    virtual void set_pattern_(const std::string &amp;pattern)
    {
        set_formatter_(details::make_unique&lt;spdlog::pattern_formatter&gt;(pattern));
    }

    virtual void set_formatter_(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter)
    {
        formatter_ = std::move(sink_formatter);
    }
    Mutex mutex_;
</t>
<t tx="leo.20220407205633.468">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015-2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/file_helper.h"
#include "spdlog/details/null_mutex.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;mutex&gt;
#include &lt;string&gt;

namespace spdlog {
namespace sinks {
/*
 * Trivial file sink with single file as target
 */
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.469">class basic_file_sink final : public base_sink&lt;Mutex&gt;
{
public:
    explicit basic_file_sink(const filename_t &amp;filename, bool truncate = false)
    {
        file_helper_.open(filename, truncate);
    }

protected:
    @others
};

using basic_file_sink_mt = basic_file_sink&lt;std::mutex&gt;;
using basic_file_sink_st = basic_file_sink&lt;details::null_mutex&gt;;

} // namespace sinks

//
// factory functions
//
template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; basic_logger_mt(const std::string &amp;logger_name, const filename_t &amp;filename, bool truncate = false)
{
    return Factory::template create&lt;sinks::basic_file_sink_mt&gt;(logger_name, filename, truncate);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; basic_logger_st(const std::string &amp;logger_name, const filename_t &amp;filename, bool truncate = false)
{
    return Factory::template create&lt;sinks::basic_file_sink_st&gt;(logger_name, filename, truncate);
}

} // namespace spdlog
</t>
<t tx="leo.20220407205633.47">class scoped_pad
{
public:
    scoped_pad(size_t wrapped_size, padding_info &amp;padinfo, fmt::memory_buffer &amp;dest)
        : padinfo_(padinfo)
        , dest_(dest)
    {

        if (padinfo_.width_ &lt;= wrapped_size)
        {
            total_pad_ = 0;
            return;
        }

        total_pad_ = padinfo.width_ - wrapped_size;
        if (padinfo_.side_ == padding_info::left)
        {
            pad_it(total_pad_);
            total_pad_ = 0;
        }
        else if (padinfo_.side_ == padding_info::center)
        {
            auto half_pad = total_pad_ / 2;
            auto reminder = total_pad_ &amp; 1;
            pad_it(half_pad);
            total_pad_ = half_pad + reminder; // for the right side
        }
    }

    scoped_pad(spdlog::string_view_t txt, padding_info &amp;padinfo, fmt::memory_buffer &amp;dest)
        : scoped_pad(txt.size(), padinfo, dest)
    {
    }

    ~scoped_pad()
    {
        if (total_pad_)
        {
            pad_it(total_pad_);
        }
    }

private:
    @others
};

</t>
<t tx="leo.20220407205633.470">void sink_it_(const details::log_msg &amp;msg) override
{
    fmt::memory_buffer formatted;
    sink::formatter_-&gt;format(msg, formatted);
    file_helper_.write(formatted);
}

</t>
<t tx="leo.20220407205633.471">    void flush_() override
    {
        file_helper_.flush();
    }

private:
    details::file_helper file_helper_;
</t>
<t tx="leo.20220407205633.472">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/file_helper.h"
#include "spdlog/details/null_mutex.h"
#include "spdlog/fmt/fmt.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;chrono&gt;
#include &lt;cstdio&gt;
#include &lt;ctime&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;

namespace spdlog {
namespace sinks {

/*
 * Generator of daily log file names in format basename.YYYY-MM-DD.ext
 */
struct daily_filename_calculator
{
    // Create filename for the form basename.YYYY-MM-DD
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.473">    static filename_t calc_filename(const filename_t &amp;filename, const tm &amp;now_tm)
    {
        filename_t basename, ext;
        std::tie(basename, ext) = details::file_helper::split_by_extenstion(filename);
        std::conditional&lt;std::is_same&lt;filename_t::value_type, char&gt;::value, fmt::memory_buffer, fmt::wmemory_buffer&gt;::type w;
        fmt::format_to(
            w, SPDLOG_FILENAME_T("{}_{:04d}-{:02d}-{:02d}{}"), basename, now_tm.tm_year + 1900, now_tm.tm_mon + 1, now_tm.tm_mday, ext);
        return fmt::to_string(w);
    }
};

/*
 * Rotating file sink based on date. rotates at midnight
 */
template&lt;typename Mutex, typename FileNameCalc = daily_filename_calculator&gt;
</t>
<t tx="leo.20220407205633.474">class daily_file_sink final : public base_sink&lt;Mutex&gt;
{
public:
    // create daily file sink which rotates on given time
    daily_file_sink(filename_t base_filename, int rotation_hour, int rotation_minute, bool truncate = false)
        : base_filename_(std::move(base_filename))
        , rotation_h_(rotation_hour)
        , rotation_m_(rotation_minute)
        , truncate_(truncate)
    {
        if (rotation_hour &lt; 0 || rotation_hour &gt; 23 || rotation_minute &lt; 0 || rotation_minute &gt; 59)
        {
            throw spdlog_ex("daily_file_sink: Invalid rotation time in ctor");
        }
        auto now = log_clock::now();
        file_helper_.open(FileNameCalc::calc_filename(base_filename_, now_tm(now)), truncate_);
        rotation_tp_ = next_rotation_tp_();
    }

protected:
    @others
};

using daily_file_sink_mt = daily_file_sink&lt;std::mutex&gt;;
using daily_file_sink_st = daily_file_sink&lt;details::null_mutex&gt;;

} // namespace sinks

//
// factory functions
//
template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; daily_logger_mt(
</t>
<t tx="leo.20220407205633.475">void sink_it_(const details::log_msg &amp;msg) override
{

    if (msg.time &gt;= rotation_tp_)
    {
        file_helper_.open(FileNameCalc::calc_filename(base_filename_, now_tm(msg.time)), truncate_);
        rotation_tp_ = next_rotation_tp_();
    }
    fmt::memory_buffer formatted;
    sink::formatter_-&gt;format(msg, formatted);
    file_helper_.write(formatted);
}

</t>
<t tx="leo.20220407205633.476">    void flush_() override
    {
        file_helper_.flush();
    }

private:
    tm now_tm(log_clock::time_point tp)
    {
        time_t tnow = log_clock::to_time_t(tp);
        return spdlog::details::os::localtime(tnow);
    }

    log_clock::time_point next_rotation_tp_()
    {
        auto now = log_clock::now();
        tm date = now_tm(now);
        date.tm_hour = rotation_h_;
        date.tm_min = rotation_m_;
        date.tm_sec = 0;
        auto rotation_time = log_clock::from_time_t(std::mktime(&amp;date));
        if (rotation_time &gt; now)
        {
            return rotation_time;
        }
        return {rotation_time + std::chrono::hours(24)};
    }

    filename_t base_filename_;
    int rotation_h_;
    int rotation_m_;
    log_clock::time_point rotation_tp_;
    details::file_helper file_helper_;
    bool truncate_;
</t>
<t tx="leo.20220407205633.477">    const std::string &amp;logger_name, const filename_t &amp;filename, int hour = 0, int minute = 0, bool truncate = false)
{
    return Factory::template create&lt;sinks::daily_file_sink_mt&gt;(logger_name, filename, hour, minute, truncate);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; daily_logger_st(
</t>
<t tx="leo.20220407205633.478">    const std::string &amp;logger_name, const filename_t &amp;filename, int hour = 0, int minute = 0, bool truncate = false)
{
    return Factory::template create&lt;sinks::daily_file_sink_st&gt;(logger_name, filename, hour, minute, truncate);
}
} // namespace spdlog
</t>
<t tx="leo.20220407205633.479">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright (c) 2015 David Schury, Gabi Melman
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "base_sink.h"
#include "spdlog/details/log_msg.h"
#include "spdlog/details/null_mutex.h"

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

// Distribution sink (mux). Stores a vector of sinks which get called when log
// is called

namespace spdlog {
namespace sinks {

template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.48">void pad_it(size_t count)
{
    // count = std::min(count, spaces_.size());
    assert(count &lt;= spaces_.size());
    fmt_helper::append_string_view(string_view_t(spaces_.data(), count), dest_);
}

const padding_info &amp;padinfo_;
fmt::memory_buffer &amp;dest_;
size_t total_pad_;
string_view_t spaces_{"                                                                "
                      "                                                                ",
    128};
</t>
<t tx="leo.20220407205633.480">class dist_sink : public base_sink&lt;Mutex&gt;
{
public:
    dist_sink() = default;
    dist_sink(const dist_sink &amp;) = delete;
    dist_sink &amp;operator=(const dist_sink &amp;) = delete;

    @others
};

using dist_sink_mt = dist_sink&lt;std::mutex&gt;;
using dist_sink_st = dist_sink&lt;details::null_mutex&gt;;

} // namespace sinks
} // namespace spdlog
</t>
<t tx="leo.20220407205633.481">void add_sink(std::shared_ptr&lt;sink&gt; sink)
{
    std::lock_guard&lt;Mutex&gt; lock(base_sink&lt;Mutex&gt;::mutex_);
    sinks_.push_back(sink);
}

</t>
<t tx="leo.20220407205633.482">void remove_sink(std::shared_ptr&lt;sink&gt; sink)
{
    std::lock_guard&lt;Mutex&gt; lock(base_sink&lt;Mutex&gt;::mutex_);
    sinks_.erase(std::remove(sinks_.begin(), sinks_.end(), sink), sinks_.end());
}

</t>
<t tx="leo.20220407205633.483">    void set_sinks(std::vector&lt;std::shared_ptr&lt;sink&gt;&gt; sinks)
    {
        std::lock_guard&lt;Mutex&gt; lock(base_sink&lt;Mutex&gt;::mutex_);
        sinks_ = std::move(sinks);
    }

protected:
</t>
<t tx="leo.20220407205633.484">void sink_it_(const details::log_msg &amp;msg) override
{

    for (auto &amp;sink : sinks_)
    {
        if (sink-&gt;should_log(msg.level))
        {
            sink-&gt;log(msg);
        }
    }
}

</t>
<t tx="leo.20220407205633.485">void flush_() override
{
    for (auto &amp;sink : sinks_)
    {
        sink-&gt;flush();
    }
}

</t>
<t tx="leo.20220407205633.486">void set_pattern_(const std::string &amp;pattern) override
{
    set_formatter_(details::make_unique&lt;spdlog::pattern_formatter&gt;(pattern));
}

</t>
<t tx="leo.20220407205633.487">void set_formatter_(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter) override
{
    base_sink&lt;Mutex&gt;::formatter_ = std::move(sink_formatter);
    for (auto &amp;sink : sinks_)
    {
        sink-&gt;set_formatter(base_sink&lt;Mutex&gt;::formatter_-&gt;clone());
    }
}
std::vector&lt;std::shared_ptr&lt;sink&gt;&gt; sinks_;
</t>
<t tx="leo.20220407205633.49">class flag_formatter
{
public:
    explicit flag_formatter(padding_info padinfo)
        : padinfo_(padinfo)
    {
    }
    flag_formatter() = default;
    virtual ~flag_formatter() = default;
    virtual void format(const details::log_msg &amp;msg, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) = 0;

protected:
    padding_info padinfo_;
};

///////////////////////////////////////////////////////////////////////
// name &amp; level pattern appender
///////////////////////////////////////////////////////////////////////
</t>
<t tx="leo.20220407205633.5">void push_back(T &amp;&amp;item)
{
    v_[tail_] = std::move(item);
    tail_ = (tail_ + 1) % max_items_;

    if (tail_ == head_) // overrun last item if full
    {
        head_ = (head_ + 1) % max_items_;
        ++overrun_counter_;
    }
}

// Pop item from front.
// If there are no elements in the container, the behavior is undefined.
</t>
<t tx="leo.20220407205633.50">class name_formatter : public flag_formatter
{
public:
    explicit name_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// log level appender
</t>
<t tx="leo.20220407205633.51">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    if (padinfo_.enabled())
    {
        scoped_pad p(*msg.logger_name, padinfo_, dest);
        fmt_helper::append_string_view(*msg.logger_name, dest);
    }
    else
    {
        fmt_helper::append_string_view(*msg.logger_name, dest);
    }
}
</t>
<t tx="leo.20220407205633.52">class level_formatter : public flag_formatter
{
public:
    explicit level_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// short log level appender
</t>
<t tx="leo.20220407205633.53">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    string_view_t &amp;level_name = level::to_string_view(msg.level);
    if (padinfo_.enabled())
    {
        scoped_pad p(level_name, padinfo_, dest);
        fmt_helper::append_string_view(level_name, dest);
    }
    else
    {
        fmt_helper::append_string_view(level_name, dest);
    }
}
</t>
<t tx="leo.20220407205633.54">class short_level_formatter : public flag_formatter
{
public:
    explicit short_level_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

///////////////////////////////////////////////////////////////////////
// Date time pattern appenders
///////////////////////////////////////////////////////////////////////

</t>
<t tx="leo.20220407205633.55">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    string_view_t level_name{level::to_short_c_str(msg.level)};
    scoped_pad p(level_name, padinfo_, dest);
    fmt_helper::append_string_view(level_name, dest);
}
</t>
<t tx="leo.20220407205633.56">static const char *ampm(const tm &amp;t)
{
    return t.tm_hour &gt;= 12 ? "PM" : "AM";
}

</t>
<t tx="leo.20220407205633.57">static int to12h(const tm &amp;t)
{
    return t.tm_hour &gt; 12 ? t.tm_hour - 12 : t.tm_hour;
}

// Abbreviated weekday name
static const char *days[]{"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
</t>
<t tx="leo.20220407205633.58">class a_formatter : public flag_formatter
{
public:
    explicit a_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// Full weekday name
static const char *full_days[]{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
</t>
<t tx="leo.20220407205633.59">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    string_view_t field_value{days[tm_time.tm_wday]};
    scoped_pad p(field_value, padinfo_, dest);
    fmt_helper::append_string_view(field_value, dest);
}
</t>
<t tx="leo.20220407205633.6">void pop_front(T &amp;popped_item)
{
    popped_item = std::move(v_[head_]);
    head_ = (head_ + 1) % max_items_;
}

</t>
<t tx="leo.20220407205633.60">class A_formatter : public flag_formatter
{
public:
    explicit A_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// Abbreviated month
static const char *months[]{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sept", "Oct", "Nov", "Dec"};
</t>
<t tx="leo.20220407205633.61">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    string_view_t field_value{full_days[tm_time.tm_wday]};
    scoped_pad p(field_value, padinfo_, dest);
    fmt_helper::append_string_view(field_value, dest);
}
</t>
<t tx="leo.20220407205633.62">class b_formatter : public flag_formatter
{
public:
    explicit b_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// Full month name
</t>
<t tx="leo.20220407205633.63">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    string_view_t field_value{months[tm_time.tm_mon]};
    scoped_pad p(field_value, padinfo_, dest);
    fmt_helper::append_string_view(field_value, dest);
}
</t>
<t tx="leo.20220407205633.64">static const char *full_months[]{
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
</t>
<t tx="leo.20220407205633.65">class B_formatter : public flag_formatter
{
public:
    explicit B_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// Date and time representation (Thu Aug 23 15:35:46 2014)
</t>
<t tx="leo.20220407205633.66">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    string_view_t field_value{full_months[tm_time.tm_mon]};
    scoped_pad p(field_value, padinfo_, dest);
    fmt_helper::append_string_view(field_value, dest);
}
</t>
<t tx="leo.20220407205633.67">class c_formatter final : public flag_formatter
{
public:
    explicit c_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// year - 2 digit
</t>
<t tx="leo.20220407205633.68">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 24;
    scoped_pad p(field_size, padinfo_, dest);

    fmt_helper::append_string_view(days[tm_time.tm_wday], dest);
    dest.push_back(' ');
    fmt_helper::append_string_view(months[tm_time.tm_mon], dest);
    dest.push_back(' ');
    fmt_helper::append_int(tm_time.tm_mday, dest);
    dest.push_back(' ');
    // time

    fmt_helper::pad2(tm_time.tm_hour, dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_min, dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_sec, dest);
    dest.push_back(' ');
    fmt_helper::append_int(tm_time.tm_year + 1900, dest);
}
</t>
<t tx="leo.20220407205633.69">class C_formatter final : public flag_formatter
{
public:
    explicit C_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// Short MM/DD/YY date, equivalent to %m/%d/%y 08/23/01
</t>
<t tx="leo.20220407205633.7">bool empty()
{
    return tail_ == head_;
}

</t>
<t tx="leo.20220407205633.70">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(tm_time.tm_year % 100, dest);
}
</t>
<t tx="leo.20220407205633.71">class D_formatter final : public flag_formatter
{
public:
    explicit D_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// year - 4 digit
</t>
<t tx="leo.20220407205633.72">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 10;
    scoped_pad p(field_size, padinfo_, dest);

    fmt_helper::pad2(tm_time.tm_mon + 1, dest);
    dest.push_back('/');
    fmt_helper::pad2(tm_time.tm_mday, dest);
    dest.push_back('/');
    fmt_helper::pad2(tm_time.tm_year % 100, dest);
}
</t>
<t tx="leo.20220407205633.73">class Y_formatter final : public flag_formatter
{
public:
    explicit Y_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// month 1-12
</t>
<t tx="leo.20220407205633.74">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 4;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::append_int(tm_time.tm_year + 1900, dest);
}
</t>
<t tx="leo.20220407205633.75">class m_formatter final : public flag_formatter
{
public:
    explicit m_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// day of month 1-31
</t>
<t tx="leo.20220407205633.76">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(tm_time.tm_mon + 1, dest);
}
</t>
<t tx="leo.20220407205633.77">class d_formatter final : public flag_formatter
{
public:
    explicit d_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// hours in 24 format 0-23
</t>
<t tx="leo.20220407205633.78">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(tm_time.tm_mday, dest);
}
</t>
<t tx="leo.20220407205633.79">class H_formatter final : public flag_formatter
{
public:
    explicit H_formatter(padding_info padinfo)
        : flag_formatter(padinfo)
    {
    }

    @others
};

// hours in 12 format 1-12
</t>
<t tx="leo.20220407205633.8">    bool full()
    {
        // head is ahead of the tail by 1
        return ((tail_ + 1) % max_items_) == head_;
    }

    size_t overrun_counter() const
    {
        return overrun_counter_;
    }

private:
    size_t max_items_;
    typename std::vector&lt;T&gt;::size_type head_ = 0;
    typename std::vector&lt;T&gt;::size_type tail_ = 0;

    std::vector&lt;T&gt; v_;

    size_t overrun_counter_ = 0;
</t>
<t tx="leo.20220407205633.80">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(tm_time.tm_hour, dest);
}
</t>
<t tx="leo.20220407205633.81">class I_formatter final : public flag_formatter
{
public:
    explicit I_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// minutes 0-59
</t>
<t tx="leo.20220407205633.82">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(to12h(tm_time), dest);
}
</t>
<t tx="leo.20220407205633.83">class M_formatter final : public flag_formatter
{
public:
    explicit M_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// seconds 0-59
</t>
<t tx="leo.20220407205633.84">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(tm_time.tm_min, dest);
}
</t>
<t tx="leo.20220407205633.85">class S_formatter final : public flag_formatter
{
public:
    explicit S_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// milliseconds
</t>
<t tx="leo.20220407205633.86">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::pad2(tm_time.tm_sec, dest);
}
</t>
<t tx="leo.20220407205633.87">class e_formatter final : public flag_formatter
{
public:
    explicit e_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// microseconds
</t>
<t tx="leo.20220407205633.88">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    auto millis = fmt_helper::time_fraction&lt;std::chrono::milliseconds&gt;(msg.time);
    if (padinfo_.enabled())
    {
        const size_t field_size = 3;
        scoped_pad p(field_size, padinfo_, dest);
        fmt_helper::pad3(static_cast&lt;uint32_t&gt;(millis.count()), dest);
    }
    else
    {
        fmt_helper::pad3(static_cast&lt;uint32_t&gt;(millis.count()), dest);
    }
}
</t>
<t tx="leo.20220407205633.89">class f_formatter final : public flag_formatter
{
public:
    explicit f_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// nanoseconds
</t>
<t tx="leo.20220407205633.9">@path ./v-rep_plugin/spdlog/details/
#pragma once
//
// Copyright(c) 2018 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#include "spdlog/details/null_mutex.h"
#include &lt;cstdio&gt;
#include &lt;mutex&gt;

#ifdef _WIN32

#ifndef NOMINMAX
#define NOMINMAX // prevent windows redefining min/max
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include &lt;windows.h&gt;
#endif

namespace spdlog {
namespace details {
struct console_stdout
{
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205633.90">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    auto micros = fmt_helper::time_fraction&lt;std::chrono::microseconds&gt;(msg.time);
    if (padinfo_.enabled())
    {
        const size_t field_size = 6;
        scoped_pad p(field_size, padinfo_, dest);
        fmt_helper::pad6(static_cast&lt;size_t&gt;(micros.count()), dest);
    }
    else
    {
        fmt_helper::pad6(static_cast&lt;size_t&gt;(micros.count()), dest);
    }
}
</t>
<t tx="leo.20220407205633.91">class F_formatter final : public flag_formatter
{
public:
    explicit F_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// seconds since epoch
</t>
<t tx="leo.20220407205633.92">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    auto ns = fmt_helper::time_fraction&lt;std::chrono::nanoseconds&gt;(msg.time);
    if (padinfo_.enabled())
    {
        const size_t field_size = 9;
        scoped_pad p(field_size, padinfo_, dest);
        fmt_helper::pad9(static_cast&lt;size_t&gt;(ns.count()), dest);
    }
    else
    {
        fmt_helper::pad9(static_cast&lt;size_t&gt;(ns.count()), dest);
    }
}
</t>
<t tx="leo.20220407205633.93">class E_formatter final : public flag_formatter
{
public:
    explicit E_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// AM/PM
</t>
<t tx="leo.20220407205633.94">void format(const details::log_msg &amp;msg, const std::tm &amp;, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 10;
    scoped_pad p(field_size, padinfo_, dest);
    auto duration = msg.time.time_since_epoch();
    auto seconds = std::chrono::duration_cast&lt;std::chrono::seconds&gt;(duration).count();
    fmt_helper::append_int(seconds, dest);
}
</t>
<t tx="leo.20220407205633.95">class p_formatter final : public flag_formatter
{
public:
    explicit p_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// 12 hour clock 02:55:02 pm
</t>
<t tx="leo.20220407205633.96">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 2;
    scoped_pad p(field_size, padinfo_, dest);
    fmt_helper::append_string_view(ampm(tm_time), dest);
}
</t>
<t tx="leo.20220407205633.97">class r_formatter final : public flag_formatter
{
public:
    explicit r_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// 24-hour HH:MM time, equivalent to %H:%M
</t>
<t tx="leo.20220407205633.98">void format(const details::log_msg &amp;, const std::tm &amp;tm_time, fmt::memory_buffer &amp;dest) override
{
    const size_t field_size = 11;
    scoped_pad p(field_size, padinfo_, dest);

    fmt_helper::pad2(to12h(tm_time), dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_min, dest);
    dest.push_back(':');
    fmt_helper::pad2(tm_time.tm_sec, dest);
    dest.push_back(' ');
    fmt_helper::append_string_view(ampm(tm_time), dest);
}
</t>
<t tx="leo.20220407205633.99">class R_formatter final : public flag_formatter
{
public:
    explicit R_formatter(padding_info padinfo)
        : flag_formatter(padinfo){};

    @others
};

// ISO 8601 time format (HH:MM:SS), equivalent to %H:%M:%S
</t>
<t tx="leo.20220407205634.1">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2016 Alexander Dalshov.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#if defined(_WIN32)

#include "spdlog/details/null_mutex.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;winbase.h&gt;

#include &lt;mutex&gt;
#include &lt;string&gt;

namespace spdlog {
namespace sinks {
/*
 * MSVC sink (logging using OutputDebugStringA)
 */
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205634.10">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/file_helper.h"
#include "spdlog/details/null_mutex.h"
#include "spdlog/fmt/fmt.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;cerrno&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

namespace spdlog {
namespace sinks {

//
// Rotating file sink based on size
//
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.100">void Trajectory::CircleTrajectory(double start[5], double center[5], Plane plane, bool clkwise, double vel[3], double acc, bool interpolation)
{
    //Split path into XYZ and BC
    double
        start_xyz[3], center_xyz[3],
        start_bc[2], center_bc[2];

    vector_split(start, start_xyz, start_bc);
    vector_split(center, center_xyz, center_bc);

    //Center relative to start point
    center_xyz[0] += start_xyz[0];
    center_xyz[1] += start_xyz[1];
    center_xyz[2] += start_xyz[2];

    //Set path
    m_path-&gt;SetCirclePath(start_xyz, center_xyz, plane, clkwise);
    //m_path-&gt;SetBCPath(start_bc, finish_bc);

    double xyz_plen = m_path-&gt;get_path_length();
    //double bc_plen = m_path-&gt;get_bc_path_length();
    double combined_plen = sqrt(pow(xyz_plen, 2));// +pow(bc_plen, 2));

                                                  //Set velocity profile
    if (interpolation)
    {
        m_vel_prof-&gt;SetInterpolationProfile(vel[0], vel[2], m_path-&gt;get_path_length());
    }
    else
    {
        m_vel_prof-&gt;SetRampProfile(vel, acc, m_path-&gt;get_path_length());
    }

    //Get path information
    double gamma, alpha, radius;
    double uvec_bc[2];
    m_path-&gt;GetArcPath(gamma, alpha, radius);
    //m_path-&gt;GetBCPath(uvec_bc);


    //Get profile path positions
    double path_time;
    vector&lt;double&gt; path_pos;
    m_vel_prof-&gt;GetProfile(path_time, path_pos);

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_bc / len)
    //double path_racio = m_path-&gt;get_bc_path_length() / m_path-&gt;get_path_length();

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_bc / len)
    double xyz_racio = m_path-&gt;get_path_length() / combined_plen;
    //double bc_racio = m_path-&gt;get_bc_path_length() / combined_plen;

    //Sample path according to the sample times
    vector&lt;double&gt; ti = linspace(0, 1, path_pos.size());

    //Initialize vector of joint coordinates
    m_joints.assign(path_pos.size(), vector&lt;double&gt;(5, 0.0));

    int c1, c2, c3;
    switch (plane)
    {
    case Motion::XY:
        c1 = 0; //x
        c2 = 1; //y
        c3 = 2; //z
        break;
    case Motion::XZ:
        c1 = 0; //x
        c2 = 2; //z
        c3 = 1; //y
        break;
    case Motion::YZ:
        c1 = 1; //y
        c2 = 2; //z
        c3 = 0; //x
        break;
    }

    for (size_t i = 0; i &lt; path_pos.size(); ++i)
    {
        double path = alpha + gamma * ti[i];
        m_joints[i][c1] = (radius * cos(path) * xyz_racio + center_xyz[c1]) / 1000;
        m_joints[i][c2] = (radius * sin(path) * xyz_racio + center_xyz[c2]) / 1000;
        m_joints[i][c3] = (start_xyz[c3]) / 1000;

        //m_joints[i][3] = (uvec_bc[0] * path_pos[i] * bc_racio + start_bc[0]) * (M_PI / 180);
        //m_joints[i][4] = (uvec_bc[1] * path_pos[i] * bc_racio + start_bc[1]) * (M_PI / 180);
    }
}

</t>
<t tx="leo.20220407205634.101">void Trajectory::Dwell(double start[5], double time)
{
    //Calculate number of dwell steps
    int it = ceil(time / m_dt);

    //Initialize vector of joint coordinates
    m_joints.assign(it, vector&lt;double&gt;(5, 0.0));
    
    for (size_t i = 0; i &lt; it; ++i)
    {
        m_joints[i][0] = start[0] / 1000;
        m_joints[i][1] = start[1] / 1000;
        m_joints[i][2] = start[2] / 1000;
        m_joints[i][3] = start[3] / 1000;
        m_joints[i][4] = start[4] / 1000;
    }
}

</t>
<t tx="leo.20220407205634.102">void Trajectory::GetTrajectory(std::vector&lt;std::vector&lt;double&gt; &gt; &amp;joints)
{
    joints = m_joints;
}

std::vector&lt;double&gt; Trajectory::linspace(double a, double b, size_t N)
{
    vector&lt;double&gt; xs(N);
    vector&lt;double&gt;::iterator it;
    
    double h = (b - a) / N;
    double val;
    for (it = xs.begin(), val = a; it != xs.end(); ++it, val += h)
    {
        *it = val;
    }

    return xs;
}

</t>
<t tx="leo.20220407205634.103">    void Trajectory::vector_split(double in[5], double out1[3], double out2[2])
    {
        std::copy(in, in + 3, out1);
        std::copy(in + 3, in + 5, out2);
    }
}
</t>
<t tx="leo.20220407205634.104">@path ./v-rep_plugin/src/
#include "VelocityProfile.h"

#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

using namespace std;

static double TOLERANCE = 0.00001;

template &lt;typename T&gt; int sgn(T val) {
    return (T(0) &lt; val + std::numeric_limits&lt;T&gt;::epsilon()) - (val &lt; T(0));
}

template &lt;typename T&gt; T sgn_tol(T val) {
    return (T(TOLERANCE) &lt; val) - (val &lt; -T(TOLERANCE));
}

namespace Motion {

    VelocityProfile::VelocityProfile(double dt) :
        m_dt(dt)
    {
    }

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.105">void VelocityProfile::SetRampProfile(double vel[3], double acc, double length)
{
    m_path_pos.clear();

    //maximum acceleration allowed with signals
    double a[3];
    a[0] = sgn_tol(vel[1] - vel[0]) * acc;
    a[1] = 0.0;
    a[2] = sgn_tol(vel[2] - vel[1]) * acc;

    //distance, time of each segment
    double 
        ds[3] = { 0.0, 0.0, 0.0 }, 
        ts[3] = { 0.0, 0.0, 0.0 };

    //check what ramps are needed
    if (abs(vel[0] - vel[1]) &gt; TOLERANCE) //start ramp
    {
        ts[0] = abs(vel[1] - vel[0]) / acc;
        ds[0] = vel[0] * ts[0] + 0.5 * a[0] * pow(ts[0], 2);
    }
    if (abs(vel[1] - vel[2]) &gt; TOLERANCE) //end ramp
    {
        ts[2] = abs(vel[2] - vel[1]) / acc;
        ds[2] = vel[1] * ts[2] + 0.5 * a[2] * pow(ts[2], 2);
    }

    //If distance covered in ramps is greater than total distance
    // In this case the actuators do not reach the target velocity,
    // instead the actuators reach an intermediate velocity that 
    // allows it to go from current to the needed velocity and cover
    // the path, respecting the accelerations imposed.
    if(length &gt;= ds[0] + ds[2])
    { 
        //constant velocity segment length
        ds[1] = length - (ds[0] + ds[2]);
        //check time needed at constant speed
        ts[1] = ds[1] / vel[1];
    }
    else
    {
        if (ts[2] &lt; TOLERANCE)
        {
            ts[0] = (2 * length) / (vel[2] + vel[0]);
            a[0] = (vel[2] - vel[0]) / ts[0];
            ds[0] = vel[0] * ts[0] + 0.5 * a[0] * pow(ts[0], 2);
            ds[1] = 0.0; 
            ds[2] = 0.0;
            ts[1] = 0.0;
            ts[2] = 0.0;
        }
        else if(ts[0] &lt; TOLERANCE)
        {
            ts[2] = (2 * length) / (vel[2] + vel[0]);
            a[2] = (vel[2] - vel[0]) / ts[2];
            ds[2] = vel[0] * ts[2] + 0.5 * a[2] * pow(ts[2], 2);
            ds[0] = 0.0;
            ds[1] = 0.0;
            ts[0] = 0.0;
            ts[1] = 0.0;
        }
        else
        {
            //intermediate point in path space
            double p_i = ((pow(vel[2], 2) - pow(vel[0], 2)) - 2 * a[2] * length) / (2 * a[0] - 2 * a[2]);
            //polynomial solving coefficients
            double as = 0.5*a[0];
            double bs = vel[0];
            double cs = -p_i;

            double r1, r2;
            if (quadroots(as, bs, cs, r1, r2))
            {
                //Use fastest solution
                // total time1 = ts + tf = ts + (vf - vi)/af = ts + (vf - (vs + as*ts))/af
                double
                    t1 = r1 + (vel[2] - (vel[0] + a[0] * r1)) / a[2],
                    t2 = r2 + (vel[2] - (vel[0] + a[0] * r2)) / a[2];
                
                double sol = 0.0;
                if (t1 &gt; 0 &amp;&amp; t2 &gt; 0)
                    sol = (t1 &lt;= t2 ? r1 : r2);
                else if (t1 &gt; 0)
                    sol = r1;
                else if (t2 &gt; 0)
                    sol = r2;
                else
                    throw runtime_error("No real roots found when computing Ramp Velocity Profile found");


                vel[1] = vel[0] + a[0] * sol;

                //New times
                ts[0] = sol;
                ts[1] = 0.0;
                ts[2] = (vel[2] - vel[1]) / a[2];

                //New distances
                ds[0] = vel[0] * ts[0] + 0.5 * a[0] * pow(ts[0], 2);
                ds[1] = 0.0;
                ds[2] = vel[1] * ts[2] + 0.5 * a[2] * pow(ts[2], 2);
            }
            else
            {
                throw runtime_error("No real roots found when computing Ramp Velocity Profile found");
            }
        }
    }
    //total time of all segments 
    double tt = ts[0] + ts[1] + ts[2];
    //number of trajectory samples
    int num_samples = ceil(tt / m_dt);

    if(num_samples &gt; 0) 
    {
        m_path_pos.assign(num_samples, 0.0);
        m_path_time = num_samples * m_dt;

        for (size_t i = 0; i &lt; num_samples - 1; i++)
        {
            //sample time
            double ti = (i+1) * m_dt;
            if (ti &lt; ts[0])
            {
                m_path_pos[i] = vel[0] * ti + 0.5 * a[0] * pow(ti, 2);
            }
            else if (ti &gt;= ts[0] &amp;&amp; ti &lt; (ts[1] + ts[0]))
            {
                m_path_pos[i] = ds[0] + vel[1] * (ti - ts[0]);
            }
            else
            {
                double tf = ti - (ts[1] + ts[0]);
                m_path_pos[i] = (ds[0] + ds[1]) + vel[1] * tf + 0.5 * a[2] * pow(tf, 2);
            }
        }
        m_path_pos[num_samples - 1] = length;
    }
}

</t>
<t tx="leo.20220407205634.106">void VelocityProfile::SetInterpolationProfile(double vel_i, double vel_f, double length)
{
    //Total time of path at constant acceleration from vel_i to vel_f
    m_path_time = (2 * length) / (vel_f + vel_i);
    //Acceleration required
    double acc = (vel_f - vel_i) / m_path_time;

    //Path samples
    double num_samples = ceil(m_path_time / m_dt);
    //Array of path positions
    m_path_pos.assign(num_samples, 0.0);

    for (size_t i = 0; i &lt; num_samples; i++)
    {
        //sample time
        double ti = i * m_dt;
        //acceleration formula
        m_path_pos[i] = vel_i * ti + 0.5 * acc * pow(ti, 2);
    }
}

</t>
<t tx="leo.20220407205634.107">void VelocityProfile::GetProfile(double &amp; path_time, std::vector&lt;double&gt;&amp; path_pos)
{
    path_time = m_path_time;
    path_pos = m_path_pos;
}

</t>
<t tx="leo.20220407205634.108">    bool VelocityProfile::quadroots(double a, double b, double c, double &amp; r1, double &amp; r2)
    {
        //returns false if there is no real only root
        double determinant = pow(b,2) - 4 * a*c;

        if (determinant &gt; 0) {
            //Roots are real and different
            r1 = (-b + sqrt(determinant)) / (2 * a);
            r2 = (-b - sqrt(determinant)) / (2 * a);
        }

        else if (determinant == 0) {
            //Roots are real and same.
            r1 = (-b + sqrt(determinant)) / (2 * a);
        }

        else {
            return false;
        }

        return true;
    }

}
</t>
<t tx="leo.20220407205634.109">@path ./v-rep_plugin/src/
#include "string_concurrent_queue.h"

StringConcurrentQueue::StringConcurrentQueue()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.11">class rotating_file_sink final : public base_sink&lt;Mutex&gt;
{
public:
    rotating_file_sink(filename_t base_filename, std::size_t max_size, std::size_t max_files)
        : base_filename_(std::move(base_filename))
        , max_size_(max_size)
        , max_files_(max_files)
    {
        file_helper_.open(calc_filename(base_filename_, 0));
        current_size_ = file_helper_.size(); // expensive. called only once
    }

    // calc filename according to index and file extension if exists.
    // e.g. calc_filename("logs/mylog.txt, 3) =&gt; "logs/mylog.3.txt".
    @others
};

using rotating_file_sink_mt = rotating_file_sink&lt;std::mutex&gt;;
using rotating_file_sink_st = rotating_file_sink&lt;details::null_mutex&gt;;

} // namespace sinks

//
// factory functions
//

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; rotating_logger_mt(
</t>
<t tx="leo.20220407205634.110">int StringConcurrentQueue::size() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    size_t sz = m_deque.size();
    lk.unlock();
    return sz;
}

</t>
<t tx="leo.20220407205634.111">bool StringConcurrentQueue::empty() {
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    bool empty = m_deque.empty();
    lk.unlock();
    return empty;
}

</t>
<t tx="leo.20220407205634.112">void StringConcurrentQueue::clear()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.clear();
    lk.unlock();
}

</t>
<t tx="leo.20220407205634.113">void StringConcurrentQueue::push_front(const std::string &amp;t)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_front(t);
    lk.unlock();
    m_cond.notify_one();
}

</t>
<t tx="leo.20220407205634.114">void StringConcurrentQueue::push_back(const std::string &amp;t)
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    m_deque.push_back(t);
    lk.unlock();
    m_cond.notify_one();
}

std::string&amp; StringConcurrentQueue::back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    return m_deque.back();
}

</t>
<t tx="leo.20220407205634.115">void StringConcurrentQueue::pop_back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait(lk);
    }
    m_deque.pop_back();
}

std::string StringConcurrentQueue::consume_back()
{
    std::unique_lock&lt;std::mutex&gt; lk(m_mutex);
    while (m_deque.empty()) {
        m_cond.wait_for(lk, std::chrono::milliseconds(100));
    }
    std::string msg = m_deque.back();
    m_deque.pop_back();
    return msg;
}


</t>
<t tx="leo.20220407205634.12">    static filename_t calc_filename(const filename_t &amp;filename, std::size_t index)
    {
        typename std::conditional&lt;std::is_same&lt;filename_t::value_type, char&gt;::value, fmt::memory_buffer, fmt::wmemory_buffer&gt;::type w;
        if (index != 0u)
        {
            filename_t basename, ext;
            std::tie(basename, ext) = details::file_helper::split_by_extenstion(filename);
            fmt::format_to(w, SPDLOG_FILENAME_T("{}.{}{}"), basename, index, ext);
        }
        else
        {
            fmt::format_to(w, SPDLOG_FILENAME_T("{}"), filename);
        }
        return fmt::to_string(w);
    }

protected:
</t>
<t tx="leo.20220407205634.13">void sink_it_(const details::log_msg &amp;msg) override
{
    fmt::memory_buffer formatted;
    sink::formatter_-&gt;format(msg, formatted);
    current_size_ += formatted.size();
    if (current_size_ &gt; max_size_)
    {
        rotate_();
        current_size_ = formatted.size();
    }
    file_helper_.write(formatted);
}

</t>
<t tx="leo.20220407205634.14">    void flush_() override
    {
        file_helper_.flush();
    }

private:
    // Rotate files:
    // log.txt -&gt; log.1.txt
    // log.1.txt -&gt; log.2.txt
    // log.2.txt -&gt; log.3.txt
    // log.3.txt -&gt; delete
</t>
<t tx="leo.20220407205634.15">void rotate_()
{
    using details::os::filename_to_str;
    file_helper_.close();
    for (auto i = max_files_; i &gt; 0; --i)
    {
        filename_t src = calc_filename(base_filename_, i - 1);
        if (!details::file_helper::file_exists(src))
        {
            continue;
        }
        filename_t target = calc_filename(base_filename_, i);

        if (!rename_file(src, target))
        {
            // if failed try again after a small delay.
            // this is a workaround to a windows issue, where very high rotation
            // rates can cause the rename to fail with permission denied (because of antivirus?).
            details::os::sleep_for_millis(100);
            if (!rename_file(src, target))
            {
                file_helper_.reopen(true); // truncate the log file anyway to prevent it to grow beyond its limit!
                current_size_ = 0;
                throw spdlog_ex(
                    "rotating_file_sink: failed renaming " + filename_to_str(src) + " to " + filename_to_str(target), errno);
            }
        }
    }
    file_helper_.reopen(true);
}

// delete the target if exists, and rename the src file  to target
// return true on success, false otherwise.
</t>
<t tx="leo.20220407205634.16">bool rename_file(const filename_t &amp;src_filename, const filename_t &amp;target_filename)
{
    // try to delete the target file in case it already exists.
    (void)details::os::remove(target_filename);
    return details::os::rename(src_filename, target_filename) == 0;
}

filename_t base_filename_;
std::size_t max_size_;
std::size_t max_files_;
std::size_t current_size_;
details::file_helper file_helper_;
</t>
<t tx="leo.20220407205634.17">    const std::string &amp;logger_name, const filename_t &amp;filename, size_t max_file_size, size_t max_files)
{
    return Factory::template create&lt;sinks::rotating_file_sink_mt&gt;(logger_name, filename, max_file_size, max_files);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; rotating_logger_st(
</t>
<t tx="leo.20220407205634.18">    const std::string &amp;logger_name, const filename_t &amp;filename, size_t max_file_size, size_t max_files)
{
    return Factory::template create&lt;sinks::rotating_file_sink_st&gt;(logger_name, filename, max_file_size, max_files);
}
} // namespace spdlog
</t>
<t tx="leo.20220407205634.19">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#include "spdlog/details/log_msg.h"
#include "spdlog/details/pattern_formatter.h"
#include "spdlog/formatter.h"

namespace spdlog {
namespace sinks {
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.2">class msvc_sink : public base_sink&lt;Mutex&gt;
{
public:
    explicit msvc_sink() {}

protected:
    @others
#endif
</t>
<t tx="leo.20220407205634.20">class sink
{
public:
    sink()
        : level_(level::trace)
        , formatter_(new pattern_formatter())
    {
    }

    explicit sink(std::unique_ptr&lt;spdlog::pattern_formatter&gt; formatter)
        : level_(level::trace)
        , formatter_(std::move(formatter))
    {
    }

    virtual ~sink() = default;
    virtual void log(const details::log_msg &amp;msg) = 0;
    virtual void flush() = 0;
    virtual void set_pattern(const std::string &amp;pattern) = 0;
    virtual void set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter) = 0;

    @others
};

} // namespace sinks
} // namespace spdlog
</t>
<t tx="leo.20220407205634.21">bool should_log(level::level_enum msg_level) const
{
    return msg_level &gt;= level_.load(std::memory_order_relaxed);
}

</t>
<t tx="leo.20220407205634.22">    void set_level(level::level_enum log_level)
    {
        level_.store(log_level);
    }

    level::level_enum level() const
    {
        return static_cast&lt;spdlog::level::level_enum&gt;(level_.load(std::memory_order_relaxed));
    }

protected:
    // sink log level - default is all
    level_t level_;

    // sink formatter - default is full format
    std::unique_ptr&lt;spdlog::formatter&gt; formatter_;
</t>
<t tx="leo.20220407205634.23">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2018 spdlog
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#ifdef _WIN32
#include "spdlog/sinks/wincolor_sink.h"
#else
#include "spdlog/sinks/ansicolor_sink.h"
#endif

namespace spdlog {
namespace sinks {
#ifdef _WIN32
using stdout_color_sink_mt = wincolor_stdout_sink_mt;
using stdout_color_sink_st = wincolor_stdout_sink_st;
using stderr_color_sink_mt = wincolor_stderr_sink_mt;
using stderr_color_sink_st = wincolor_stderr_sink_st;
#else
using stdout_color_sink_mt = ansicolor_stdout_sink_mt;
using stdout_color_sink_st = ansicolor_stdout_sink_st;
using stderr_color_sink_mt = ansicolor_stderr_sink_mt;
using stderr_color_sink_st = ansicolor_stderr_sink_st;
#endif
} // namespace sinks

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stdout_color_mt(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stdout_color_sink_mt&gt;(logger_name);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stdout_color_st(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stdout_color_sink_st&gt;(logger_name);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stderr_color_mt(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stderr_color_sink_mt&gt;(logger_name);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stderr_color_st(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stderr_color_sink_mt&gt;(logger_name);
}
} // namespace spdlog
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.24">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/console_globals.h"
#include "spdlog/details/null_mutex.h"

#include &lt;cstdio&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;

namespace spdlog {

namespace sinks {

template&lt;typename TargetStream, typename ConsoleMutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.25">class stdout_sink final : public sink
{
public:
    using mutex_t = typename ConsoleMutex::mutex_t;
    stdout_sink()
        : mutex_(ConsoleMutex::mutex())
        , file_(TargetStream::stream())
    {
    }
    ~stdout_sink() override = default;

    stdout_sink(const stdout_sink &amp;other) = delete;
    stdout_sink &amp;operator=(const stdout_sink &amp;other) = delete;

    @others
};

using stdout_sink_mt = stdout_sink&lt;details::console_stdout, details::console_mutex&gt;;
using stdout_sink_st = stdout_sink&lt;details::console_stdout, details::console_nullmutex&gt;;

using stderr_sink_mt = stdout_sink&lt;details::console_stderr, details::console_mutex&gt;;
using stderr_sink_st = stdout_sink&lt;details::console_stderr, details::console_nullmutex&gt;;

} // namespace sinks

// factory methods
template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stdout_logger_mt(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stdout_sink_mt&gt;(logger_name);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stdout_logger_st(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stdout_sink_st&gt;(logger_name);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stderr_logger_mt(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stderr_sink_mt&gt;(logger_name);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; stderr_logger_st(const std::string &amp;logger_name)
{
    return Factory::template create&lt;sinks::stderr_sink_st&gt;(logger_name);
}
} // namespace spdlog
</t>
<t tx="leo.20220407205634.26">void log(const details::log_msg &amp;msg) override
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    fmt::memory_buffer formatted;
    formatter_-&gt;format(msg, formatted);
    fwrite(formatted.data(), sizeof(char), formatted.size(), file_);
    fflush(TargetStream::stream());
}

</t>
<t tx="leo.20220407205634.27">void flush() override
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    fflush(file_);
}

</t>
<t tx="leo.20220407205634.28">void set_pattern(const std::string &amp;pattern) override
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    formatter_ = std::unique_ptr&lt;spdlog::formatter&gt;(new pattern_formatter(pattern));
}

</t>
<t tx="leo.20220407205634.29">    void set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter) override
    {
        std::lock_guard&lt;mutex_t&gt; lock(mutex_);
        formatter_ = std::move(sink_formatter);
    }

private:
    mutex_t &amp;mutex_;
    FILE *file_;
</t>
<t tx="leo.20220407205634.3">void sink_it_(const details::log_msg &amp;msg) override
{

    fmt::memory_buffer formatted;
    sink::formatter_-&gt;format(msg, formatted);
    OutputDebugStringA(fmt::to_string(formatted).c_str());
}

void flush_() override {}

</t>
<t tx="leo.20220407205634.30">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/sinks/base_sink.h"

#include &lt;array&gt;
#include &lt;string&gt;
#include &lt;syslog.h&gt;

namespace spdlog {
namespace sinks {
/**
 * Sink that write to syslog using the `syscall()` library call.
 *
 * Locking is not needed, as `syslog()` itself is thread-safe.
 */
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205634.31">class syslog_sink : public base_sink&lt;Mutex&gt;
{
public:
    //
    explicit syslog_sink(std::string ident = "", int syslog_option = 0, int syslog_facility = LOG_USER)
        : ident_(std::move(ident))
    {
        priorities_[static_cast&lt;size_t&gt;(level::trace)] = LOG_DEBUG;
        priorities_[static_cast&lt;size_t&gt;(level::debug)] = LOG_DEBUG;
        priorities_[static_cast&lt;size_t&gt;(level::info)] = LOG_INFO;
        priorities_[static_cast&lt;size_t&gt;(level::warn)] = LOG_WARNING;
        priorities_[static_cast&lt;size_t&gt;(level::err)] = LOG_ERR;
        priorities_[static_cast&lt;size_t&gt;(level::critical)] = LOG_CRIT;
        priorities_[static_cast&lt;size_t&gt;(level::off)] = LOG_INFO;

        // set ident to be program name if empty
        ::openlog(ident_.empty() ? nullptr : ident_.c_str(), syslog_option, syslog_facility);
    }

    ~syslog_sink() override
    {
        ::closelog();
    }

    syslog_sink(const syslog_sink &amp;) = delete;
    syslog_sink &amp;operator=(const syslog_sink &amp;) = delete;

protected:
    @others
};

using syslog_sink_mt = syslog_sink&lt;std::mutex&gt;;
using syslog_sink_st = syslog_sink&lt;details::null_mutex&gt;;
} // namespace sinks

// Create and register a syslog logger
template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; syslog_logger_mt(
</t>
<t tx="leo.20220407205634.32">void sink_it_(const details::log_msg &amp;msg) override
{
    ::syslog(syslog_prio_from_level(msg), "%s", fmt::to_string(msg.payload).c_str());
}

void flush_() override {}
</t>
<t tx="leo.20220407205634.33">int syslog_prio_from_level(const details::log_msg &amp;msg) const
{
    return priorities_[static_cast&lt;size_t&gt;(msg.level)];
}
</t>
<t tx="leo.20220407205634.34">    const std::string &amp;logger_name, const std::string &amp;syslog_ident = "", int syslog_option = 0, int syslog_facility = (1 &lt;&lt; 3))
{
    return Factory::template create&lt;sinks::syslog_sink_mt&gt;(logger_name, syslog_ident, syslog_option, syslog_facility);
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; syslog_logger_st(
</t>
<t tx="leo.20220407205634.35">    const std::string &amp;logger_name, const std::string &amp;syslog_ident = "", int syslog_option = 0, int syslog_facility = (1 &lt;&lt; 3))
{
    return Factory::template create&lt;sinks::syslog_sink_st&gt;(logger_name, syslog_ident, syslog_option, syslog_facility);
}
} // namespace spdlog
</t>
<t tx="leo.20220407205634.36">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2016 spdlog
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/common.h"
#include "spdlog/details/console_globals.h"
#include "spdlog/details/null_mutex.h"
#include "spdlog/sinks/sink.h"

#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;wincon.h&gt;

namespace spdlog {
namespace sinks {
/*
 * Windows color console sink. Uses WriteConsoleA to write to the console with
 * colors
 */
template&lt;typename OutHandle, typename ConsoleMutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.37">class wincolor_sink : public sink
{
public:
    const WORD BOLD = FOREGROUND_INTENSITY;
    const WORD RED = FOREGROUND_RED;
    const WORD GREEN = FOREGROUND_GREEN;
    const WORD CYAN = FOREGROUND_GREEN | FOREGROUND_BLUE;
    const WORD WHITE = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
    const WORD YELLOW = FOREGROUND_RED | FOREGROUND_GREEN;

    wincolor_sink()
        : out_handle_(OutHandle::handle())
        , mutex_(ConsoleMutex::mutex())
    {
        colors_[level::trace] = WHITE;
        colors_[level::debug] = CYAN;
        colors_[level::info] = GREEN;
        colors_[level::warn] = YELLOW | BOLD;
        colors_[level::err] = RED | BOLD;                         // red bold
        colors_[level::critical] = BACKGROUND_RED | WHITE | BOLD; // white bold on red background
        colors_[level::off] = 0;
    }

    ~wincolor_sink() override
    {
        this-&gt;flush();
    }

    wincolor_sink(const wincolor_sink &amp;other) = delete;
    wincolor_sink &amp;operator=(const wincolor_sink &amp;other) = delete;

    // change the color for the given level
    @others
};

using wincolor_stdout_sink_mt = wincolor_sink&lt;details::console_stdout, details::console_mutex&gt;;
using wincolor_stdout_sink_st = wincolor_sink&lt;details::console_stdout, details::console_nullmutex&gt;;

using wincolor_stderr_sink_mt = wincolor_sink&lt;details::console_stderr, details::console_mutex&gt;;
using wincolor_stderr_sink_st = wincolor_sink&lt;details::console_stderr, details::console_nullmutex&gt;;

} // namespace sinks
} // namespace spdlog
</t>
<t tx="leo.20220407205634.38">void set_color(level::level_enum level, WORD color)
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    colors_[level] = color;
}

</t>
<t tx="leo.20220407205634.39">void log(const details::log_msg &amp;msg) final override
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    fmt::memory_buffer formatted;
    formatter_-&gt;format(msg, formatted);
    if (msg.color_range_end &gt; msg.color_range_start)
    {
        // before color range
        print_range_(formatted, 0, msg.color_range_start);

        // in color range
        auto orig_attribs = set_console_attribs(colors_[msg.level]);
        print_range_(formatted, msg.color_range_start, msg.color_range_end);
        ::SetConsoleTextAttribute(out_handle_,
            orig_attribs); // reset to orig colors
                           // after color range
        print_range_(formatted, msg.color_range_end, formatted.size());
    }
    else // print without colors if color range is invalid
    {
        print_range_(formatted, 0, formatted.size());
    }
}

</t>
<t tx="leo.20220407205634.4">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/null_mutex.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;mutex&gt;

namespace spdlog {
namespace sinks {

template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20220407205634.40">void flush() final override
{
    // windows console always flushed?
}

</t>
<t tx="leo.20220407205634.41">void set_pattern(const std::string &amp;pattern) override final
{
    std::lock_guard&lt;mutex_t&gt; lock(mutex_);
    formatter_ = std::unique_ptr&lt;spdlog::formatter&gt;(new pattern_formatter(pattern));
}

</t>
<t tx="leo.20220407205634.42">    void set_formatter(std::unique_ptr&lt;spdlog::formatter&gt; sink_formatter) override final
    {
        std::lock_guard&lt;mutex_t&gt; lock(mutex_);
        formatter_ = std::move(sink_formatter);
    }

private:
    using mutex_t = typename ConsoleMutex::mutex_t;
    // set color and return the orig console attributes (for resetting later)
    WORD set_console_attribs(WORD attribs)
    {
        CONSOLE_SCREEN_BUFFER_INFO orig_buffer_info;
        ::GetConsoleScreenBufferInfo(out_handle_, &amp;orig_buffer_info);
        WORD back_color = orig_buffer_info.wAttributes;
        // retrieve the current background color
        back_color &amp;= static_cast&lt;WORD&gt;(~(FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE | FOREGROUND_INTENSITY));
        // keep the background color unchanged
        ::SetConsoleTextAttribute(out_handle_, attribs | back_color);
        return orig_buffer_info.wAttributes; // return orig attribs
    }

    // print a range of formatted message to console
</t>
<t tx="leo.20220407205634.43">void print_range_(const fmt::memory_buffer &amp;formatted, size_t start, size_t end)
{
    auto size = static_cast&lt;DWORD&gt;(end - start);
    ::WriteConsoleA(out_handle_, formatted.data() + start, size, nullptr, nullptr);
}

HANDLE out_handle_;
mutex_t &amp;mutex_;
std::unordered_map&lt;level::level_enum, WORD, level::level_hasher&gt; colors_;
</t>
<t tx="leo.20220407205634.44"></t>
<t tx="leo.20220407205634.45">@path ./v-rep_plugin/src/
#include "Extruder.h"

#include "simConst.h"

using namespace std;

Extruder::Extruder(const string &amp;ename, const string &amp;bname) :
    ext_name(ename),
    bed_name(bname)
{
    vector&lt;float&gt; color_red = { 1.000f, 0.2706f, 0.000f };
    vector&lt;float&gt; color_green = { 0.0274f, 0.8039f, 0.1961f };
    vector&lt;float&gt; color_blue = { 0.1176f, 0.5647f, 1.000f };
    vector&lt;float&gt; color_yellow = { 1.000f, 1.000f, 0.000f };

    color_map.emplace(std::pair&lt;int, vector&lt;float&gt; &gt;(0, color_red));
    color_map.emplace(std::pair&lt;int, vector&lt;float&gt; &gt;(1, color_green));
    color_map.emplace(std::pair&lt;int, vector&lt;float&gt; &gt;(2, color_blue));

    //drawobj_mode = (int)sim_drawing_spherepoints;
    drawobj_mode = (int)sim_drawing_cubepoints;

    //color - RGB
    std::copy(color_red.begin(), color_red.end(), drawobj_color);

    //Filament size meters
    drawobj_size = 0.0015f;

    //Filament resolution
    filament_resolution = 0.5;

    //Alternative filament
    alternative_color1 = color_yellow;
    alternative_size1 = 0.0004;

    //Octree name
    octree_name = "FilamentOctree";
    octree_leaf_size = 0.01;

    //if vector of points is float
    // 200.000.000 points represent ~2400mb
    buffer_size = 200000000;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.46">void Extruder::SetInitialTransformation(const std::vector&lt;float&gt;&amp; transf)
{
    init_transf = transf;
}

std::vector&lt;float&gt; Extruder::GetInitialTransformation()
{
    return init_transf;
}

</t>
<t tx="leo.20220407205634.47">void Extruder::CalculateWorldPoint(const std::vector&lt;double&gt;&amp; cpos, float wp[3])
{
    wp[0] = (cpos[0] * init_transf[0] + cpos[1] * init_transf[1] + cpos[2] * init_transf[2]) + init_transf[3];
    wp[1] = (cpos[0] * init_transf[4] + cpos[1] * init_transf[5] + cpos[2] * init_transf[6]) + init_transf[7];
    wp[2] = (cpos[0] * init_transf[8] + cpos[1] * init_transf[9] + cpos[2] * init_transf[10]) + init_transf[11];
}

</t>
<t tx="leo.20220407205634.48">void Extruder::CalculateWorldPoint(float cpos[3], float wp[3])
{
    wp[0] = (cpos[0] * init_transf[0] + cpos[1] * init_transf[1] + cpos[2] * init_transf[2]) + init_transf[3];
    wp[1] = (cpos[0] * init_transf[4] + cpos[1] * init_transf[5] + cpos[2] * init_transf[6]) + init_transf[7];
    wp[2] = (cpos[0] * init_transf[8] + cpos[1] * init_transf[9] + cpos[2] * init_transf[10]) + init_transf[11];
}

</t>
<t tx="leo.20220407205634.49">void Extruder::CalculateRealPoint(const std::vector&lt;double&gt;&amp; cpos, std::vector&lt;double&gt;&amp; bpos)
{
    ///Calculates the actual coordinates of the extrusion point in the bed
    /// uses the XYZ and BC coordinates (check MATLAB NewCoordinates.m)

    bpos.assign(3, 0.0);
    //bpos[0] = (Z*sin(B)*pow(cos(C), 2) + X*cos(B)*cos(C) + Z*sin(B)*pow(sin(C), 2) + Y*cos(B)*sin(C)) / ((pow(cos(B), 2) + pow(sin(B), 2))*(pow(cos(C), 2) + pow(sin(C), 2))); //X 
    //bpos[1] = (Y*cos(C) - X*sin(C)) / (pow(cos(C), 2) + pow(sin(C), 2)); //Y 
    //bpos[2] = -(X*cos(C)*sin(B) + Y*sin(B)*sin(C) - Z*cos(B)*pow(cos(C), 2) - Z*cos(B)*pow(sin(C), 2)) / ((pow(cos(B), 2) + pow(sin(B), 2))*(pow(cos(C), 2) + pow(sin(C), 2))); //Z
    bpos[0] = (cpos[2] *sin(cpos[3])*pow(cos(cpos[4]), 2) + cpos[0]*cos(cpos[3])*cos(cpos[4]) + cpos[2] *sin(cpos[3])*pow(sin(cpos[4]), 2) + cpos[1]*cos(cpos[3])*sin(cpos[4])) / ((pow(cos(cpos[3]), 2) + pow(sin(cpos[3]), 2))*(pow(cos(cpos[4]), 2) + pow(sin(cpos[4]), 2))); //X 
    bpos[1] = (cpos[1]*cos(cpos[4]) - cpos[0]*sin(cpos[4])) / (pow(cos(cpos[4]), 2) + pow(sin(cpos[4]), 2)); //Y 
    bpos[2] = -(cpos[0]*cos(cpos[4])*sin(cpos[3]) + cpos[1]*sin(cpos[3])*sin(cpos[4]) - cpos[2]*cos(cpos[3])*pow(cos(cpos[4]), 2) - cpos[2] *cos(cpos[3])*pow(sin(cpos[4]), 2)) / ((pow(cos(cpos[3]), 2) + pow(sin(cpos[3]), 2))*(pow(cos(cpos[4]), 2) + pow(sin(cpos[4]), 2))); //Z

}

double Extruder::CalculateRealDistancePoints(const std::vector&lt;double&gt;&amp; lpos, const std::vector&lt;double&gt;&amp; cpos) {
    std::vector&lt;double&gt; lrpos, crpos;

    CalculateRealPoint(lpos, lrpos);
    CalculateRealPoint(cpos, crpos);

    return sqrt(pow(crpos[0] - lrpos[0], 2) + pow(crpos[1] - lrpos[1], 2) + pow(crpos[2] - lrpos[2], 2));
}

</t>
<t tx="leo.20220407205634.5">class null_sink : public base_sink&lt;Mutex&gt;
{
protected:
    void sink_it_(const details::log_msg &amp;) override {}
{
    auto null_logger = Factory::template create&lt;sinks::null_sink_mt&gt;(logger_name);
    null_logger-&gt;set_level(level::off);
    return null_logger;
}

template&lt;typename Factory = default_factory&gt;
inline std::shared_ptr&lt;logger&gt; null_logger_st(const std::string &amp;logger_name)
{
    auto null_logger = Factory::template create&lt;sinks::null_sink_st&gt;(logger_name);
    null_logger-&gt;set_level(level::off);
    return null_logger;
}

} // namespace spdlog
</t>
<t tx="leo.20220407205634.50">void Extruder::SetFilamentType(int type_id)
{
    switch (type_id) {
    case 6:
        drawobj_mode = (int)sim_drawing_cubepoints;
        break;
    case 7:
        drawobj_mode = (int)sim_drawing_spherepoints;
        break;
    default:
        drawobj_mode = (int)sim_drawing_cubepoints;
        break;
    }
}

</t>
<t tx="leo.20220407205634.51">int Extruder::GetFilamentType()
{
    return drawobj_mode;
}


</t>
<t tx="leo.20220407205634.52">void Extruder::SetFilamentColor(int color_id)
{
    std::lock_guard&lt;std::mutex&gt; lk(mutex_filament);

    if (color_id == 0 || color_id == 1 || color_id == 2)
    {
        std::vector&lt;float&gt; selected_color;

        //Find selected color
        auto search = color_map.find(color_id);
        
        if (search != color_map.end()) {
            selected_color = search-&gt;second;

            std::copy(selected_color.begin(), selected_color.end(), drawobj_color);
        }
    }
}

</t>
<t tx="leo.20220407205634.53">float * Extruder::GetFilamentColor()
{
    std::lock_guard&lt;std::mutex&gt; lk(mutex_filament);
    return drawobj_color;
}

</t>
<t tx="leo.20220407205634.54">void Extruder::SetFilamentSize(float size)
{
    std::lock_guard&lt;std::mutex&gt; lk(mutex_filament);
    drawobj_size = size;
}

</t>
<t tx="leo.20220407205634.55">float Extruder::GetFilamentSize()
{
    std::lock_guard&lt;std::mutex&gt; lk(mutex_filament);
    return drawobj_size;
}

</t>
<t tx="leo.20220407205634.56">void Extruder::SetFilamentResolution(float res)
{
    // Set minimum resolution = 0.5
    filament_resolution = (res &lt; 0.5f ? 0.5f : res);
    // Set maximum resolution = 3.0
    filament_resolution = (res &gt; 3.0f ? 3.0f : res);
}

</t>
<t tx="leo.20220407205634.57">float Extruder::GetFilamentResolution()
{
    return filament_resolution;
}

</t>
<t tx="leo.20220407205634.58">void Extruder::PaintInfo(const int type, std::vector&lt;float&gt;&amp; color, float &amp; size)
{
    color.resize(3);
    if (type == 1000) { //Rapid Move
        color[0] = alternative_color1[0]; //yellow
        color[1] = alternative_color1[1];
        color[2] = alternative_color1[2];

        size = alternative_size1; //4mm
    }
    else {
        std::lock_guard&lt;std::mutex&gt; lk(mutex_filament);
        color[0] = drawobj_color[0];
        color[1] = drawobj_color[1];
        color[2] = drawobj_color[2];
        size = drawobj_size;
    }
}
</t>
<t tx="leo.20220407205634.59">@path ./v-rep_plugin/src/

#include &lt;vector&gt;

#define _USE_MATH_DEFINES
#include &lt;cmath&gt;

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/property_tree/ptree.hpp&gt;
#include &lt;boost/property_tree/json_parser.hpp&gt;

#include "Listener.h"
#include "../simExtFIBR3D.h"

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

template &lt;typename T&gt;
std::vector&lt;T&gt; static as_vector(ptree const&amp; pt, ptree::key_type const&amp; key)
{
    std::vector&lt;T&gt; r;
    for (auto&amp; item : pt.get_child(key))
        r.push_back(item.second.get_value&lt;T&gt;());
    return r;
}

Listener::Listener()
{
    m_last_position.assign(5, 0.0);

    //Get simulation timestep
    double dt = v_repExtGetSimulationTimeStep();

    m_trajectory = std::make_shared&lt;Motion::Trajectory&gt;(dt);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.6">@path ./v-rep_plugin/spdlog/sinks/
//
// Copyright(c) 2015 Gabi Melman.
// Distributed under the MIT License (http://opensource.org/licenses/MIT)
//

#pragma once

#ifndef SPDLOG_H
#error "spdlog.h must be included before this file."
#endif

#include "spdlog/details/null_mutex.h"
#include "spdlog/sinks/base_sink.h"

#include &lt;mutex&gt;
#include &lt;ostream&gt;

namespace spdlog {
namespace sinks {
template&lt;typename Mutex&gt;
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.60">void Listener::Deserialize(std::string JSON_msg)
{
    // Ptree to store information from JSON
    ptree request;
    std::istringstream is(JSON_msg);
    read_json(is, request);

    // Storing information in a package object
    try {
        m_pack.keycode = (KEYCODE)request.get&lt;int&gt;("keycode");
        m_pack.bool1 = request.get&lt;bool&gt;("clkwise");
        m_pack.bool2 = request.get&lt;bool&gt;("interpol");
        m_pack.extrude = request.get&lt;bool&gt;("extrude");
        m_pack.text = request.get&lt;std::string&gt;("text");
        m_pack.int1 = request.get&lt;int&gt;("plane");
        m_pack.coord1 = request.get&lt;double&gt;("aux");
        ptree coord1 = request.get_child("pos1");
        ptree coord2 = request.get_child("pos2");
        ptree vel = request.get_child("vel");
        ptree acc = request.get_child("acc");
        m_pack.line = request.get&lt;int&gt;("line");

        // Storing arrays
        int i = 0, j = 0, k = 0, l = 0;
        //Convert mm to m
        for (ptree::value_type &amp;el : coord1)
        {
            if (i &lt; 3) {
                m_pack.vec1[i] = el.second.get&lt;double&gt;("");
            }
            else {
                m_pack.vec1[i] = el.second.get&lt;double&gt;("");
            }
            i++;
        }
        for (ptree::value_type &amp;el : coord2)
        {
            m_pack.vec2[j] = el.second.get&lt;double&gt;("");
            j++;
        }
        for (ptree::value_type &amp;el : vel)
        {
            m_pack.vel[k] = el.second.get&lt;double&gt;("");
            k++;
        }
        for (ptree::value_type &amp;el : acc)
        {
            m_pack.acc[l] = el.second.get&lt;double&gt;("");
            l++;
        }
    }
    catch (const boost::property_tree::json_parser_error&amp; e1) {
        std::string emsg = "Error reading current sent command: " + e1.message();

        v_repExtPQBarMsgCommunication(emsg);
    }
}

</t>
<t tx="leo.20220407205634.61">void Listener::PushAction()
{
    //TODO: Change motion control to ext_handle different axis acceleration / velocity
    double acc = std::min(m_pack.acc[0], std::min(m_pack.acc[1], m_pack.acc[2]));

    //Relative motion variables
    double rel_origin[5] = { 0.0, 0.0, 0.0, 0.0, 0.0 };
    //double rel_target[3];

    if(m_pack.keycode &lt; 2000) //Motion commands
    {
        //PullCurrentPosition(current_position);
        double current_position[5];
        std::copy(m_last_position.data(), m_last_position.data()+5, current_position);
        //Convert current_position data to mm and deg
        current_position[0] *= 1000;
        current_position[1] *= 1000;
        current_position[2] *= 1000;
        current_position[3] *= (180 / M_PI);
        current_position[4] *= (180 / M_PI);

        switch (m_pack.keycode)
        {
        case RapidMove:
            m_trajectory-&gt;RapidTrajectory(current_position, m_pack.vec1, m_pack.vel, acc);
            break;
        case IncRapidMove:
            m_trajectory-&gt;RapidTrajectory(rel_origin, m_pack.vec1, m_pack.vel, acc);
            break;
        case LinearMove:
            m_trajectory-&gt;LinearTrajectory(current_position, m_pack.vec1, m_pack.vel, acc, m_pack.bool2);
            break;
        case IncLinearMove:
            m_trajectory-&gt;LinearTrajectory(rel_origin, m_pack.vec1, m_pack.vel, acc, m_pack.bool2);
            break;
        case ArcMoveCenter:
            m_trajectory-&gt;ArcTrajectory(current_position, m_pack.vec1, m_pack.vec2, (Motion::Plane)m_pack.int1,
                m_pack.bool1, m_pack.vel, acc, m_pack.bool2);
            break;
        case ArcMoveRadius:
            m_trajectory-&gt;ArcTrajectory(current_position, m_pack.vec1, m_pack.coord1, (Motion::Plane)m_pack.int1,
                m_pack.bool1, m_pack.vel, acc, m_pack.bool2);
            break;
        case CircleMove:
            m_trajectory-&gt;CircleTrajectory(current_position, m_pack.vec2, (Motion::Plane)m_pack.int1,
                m_pack.bool1, m_pack.vel, acc, m_pack.bool2);
            break;
        case IncArcMoveCenter:
            m_trajectory-&gt;ArcTrajectory(rel_origin, m_pack.vec1, m_pack.vec2, (Motion::Plane)m_pack.int1,
                m_pack.bool1, m_pack.vel, acc, m_pack.bool2);
            break;
        case IncArcMoveRadius:
            m_trajectory-&gt;ArcTrajectory(rel_origin, m_pack.vec1, m_pack.coord1, (Motion::Plane)m_pack.int1,
                m_pack.bool1, m_pack.vel, acc, m_pack.bool2);
            break;
        case IncCircleMove:
            m_trajectory-&gt;CircleTrajectory(rel_origin, m_pack.vec2, (Motion::Plane)m_pack.int1,
                m_pack.bool1, m_pack.vel, acc, m_pack.bool2);
            break;
        case Dwell:
            m_trajectory-&gt;Dwell(current_position, m_pack.coord1);
            break;
        }

        //Get joint trajectory 
        std::vector&lt;std::vector&lt;double&gt; &gt; joint_values;
        m_trajectory-&gt;GetTrajectory(joint_values);

        if(!joint_values.empty())
        {
            m_last_position = joint_values.back();

            // Extend extrude to the same length as the number of joint values passed, 
            // so that for each trajectory path point, the simulator thread can pop
            // one joint values set and an extrude set.
            std::pair&lt;bool, int&gt; extrude_pair(m_pack.extrude, m_pack.keycode);
            std::vector&lt; std::pair&lt;bool, int&gt; &gt; extrude_vector(joint_values.size(), extrude_pair);
            // Same thing happens with the line
            std::vector&lt;int&gt; line_vector(joint_values.size(), m_pack.line);
            // Push values to simulator queue
            v_repExtPQSetJointTrajectory(joint_values, extrude_vector, line_vector);
        }
        else {
            // If instruction leads to no new joint values, update the line.
            v_repExtPQAdvanceLine(m_pack.line);
        }
    }
}

</t>
<t tx="leo.20220407205634.62">void Listener::PullCurrentPosition(double * cjp)
{
    std::vector&lt;double&gt; vcp_;
    v_repExtPQGetJointPositions(vcp_);
    std::copy(vcp_.data(), vcp_.data() + 5, cjp);
}

</t>
<t tx="leo.20220407205634.63">void Listener::Interpret(std::string JSON_msg)
{
    Deserialize(JSON_msg);

    PushAction();
}
</t>
<t tx="leo.20220407205634.64">@path ./v-rep_plugin/src/
#define _USE_MATH_DEFINES
#include &lt;cmath&gt;

#include "Path.h"

#include &lt;algorithm&gt;
#include &lt;complex&gt;

using namespace std;

template &lt;typename T&gt; int sgn(T val) {
    return (T(0) &lt; val + std::numeric_limits&lt;T&gt;::epsilon()) - (val &lt; T(0));
}

namespace Motion {

    Path::Path()
    {
        m_tolerance = 1e-6;
    }

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.65">void Path::SetLinearPath(double xi[3], double xf[3])
{
    double path[3];
    path[0] = xf[0] - xi[0];
    path[1] = xf[1] - xi[1];
    path[2] = xf[2] - xi[2];

    m_path_length = sqrt(pow(path[0], 2) + pow(path[1], 2) + pow(path[2], 2));
    if(m_path_length &gt; m_tolerance)
    {
        m_unit_vec[0] = path[0] / m_path_length;
        m_unit_vec[1] = path[1] / m_path_length;
        m_unit_vec[2] = path[2] / m_path_length;
    }
    else {
        m_unit_vec[0] = 0.0;
        m_unit_vec[1] = 0.0;
        m_unit_vec[2] = 0.0;
    }
}

</t>
<t tx="leo.20220407205634.66">void Path::SetArcPath(double start[3], double finish[3], double center[3], Plane plane, bool clkwise)
{
    //copy to member variable
    copy(center, center + 3, m_center);

    double s[2], f[2];
    switch (plane) {
    case XY:
        s[0] = start[0];
        s[1] = start[1];
        f[0] = finish[0];
        f[1] = finish[1];
        break;
    case XZ:
        s[0] = start[0];
        s[1] = start[2];
        f[0] = finish[0];
        f[1] = finish[2];
        break;
    case YZ:
        s[0] = start[1];
        s[1] = start[2];
        f[0] = finish[1];
        f[1] = finish[2];
        break;
    }

    //origin to center
    //origin to center
    double oo[2], ee[2];
    oo[0] = s[0] - center[0];
    oo[1] = s[1] - center[1];
    ee[0] = f[0] - center[0];
    ee[1] = f[1] - center[1];

    //radius
    m_radius = sqrt(pow(oo[0], 2) + pow(oo[1], 2));
    //start angle
    m_alpha = atan2(oo[1], oo[0]);
    //end angle - only required to calculate arc angle
    double beta = atan2(ee[1], ee[0]);

    //m_gamma the arc angle (beta - m_alpha)
    if (m_alpha &lt; 0 &amp;&amp; beta &gt;= 0)
    {
        m_gamma = beta - (m_alpha + 2 * M_PI);
    }
    else if (m_alpha &gt; 0 &amp;&amp; beta &lt;= 0)
    {
        m_gamma = (beta + 2 * M_PI) - m_alpha;
    }
    else
    {
        m_gamma = beta - m_alpha;
    }

    if (clkwise &amp;&amp; m_gamma &gt; 0)
    {
        m_gamma = m_gamma - 2 * M_PI;
    }
    else if (!clkwise &amp;&amp; m_gamma &lt; 0)
    {
        m_gamma = m_gamma + 2 * M_PI;
    }

    //Saving path length
    m_path_length = m_radius * abs(m_gamma);
}

</t>
<t tx="leo.20220407205634.67">void Path::SetArcPath(double start[3], double finish[3], double radius, Plane plane, bool clkwise)
{
    //copy to member variable
    m_radius = std::abs(radius);

    double s[2], f[2];
    switch (plane) {
    case XY:
        s[0] = start[0];
        s[1] = start[1];
        f[0] = finish[0];
        f[1] = finish[1];
        break;
    case XZ:
        s[0] = start[0];
        s[1] = start[2];
        f[0] = finish[0];
        f[1] = finish[2];
        break;
    case YZ:
        s[0] = start[1];
        s[1] = start[2];
        f[0] = finish[1];
        f[1] = finish[2];
        break;
    }

    //Better explanation go to:
    //http://mathforum.org/library/drmath/view/53027.html
    //q = distance between start and end
    double q = sqrt(pow((f[0] - s[0]), 2) + pow((f[1] - s[1]), 2));

    //m = middle point between s and f
    //center = center point of arc
    double m[2], c[2];
    m[0] = (s[0] + f[0]) / 2;
    m[1] = (s[1] + f[1]) / 2;

    double term = (pow(radius, 2) - pow((q / 2), 2) &lt; 0 ? 0.0 : pow(radius, 2) - pow((q / 2), 2));

    if (!clkwise &amp;&amp; radius &gt; 0 || clkwise &amp;&amp; radius &lt; 0)
    {
        c[0] = std::real(m[0] + sqrt(term) * (s[1] - f[1]) / q);
        c[1] = std::real(m[1] + sqrt(term) * (f[0] - s[0]) / q);
    }
    else
    {
        c[0] = std::real(m[0] - sqrt(term) * (s[1] - f[1]) / q);
        c[1] = std::real(m[1] - sqrt(term) * (f[0] - s[0]) / q);
    }

    //origin to center
    double oo[2], ee[2];
    oo[0] = s[0] - c[0];
    oo[1] = s[1] - c[1];
    ee[0] = f[0] - c[0];
    ee[1] = f[1] - c[1];

    //start angle
    m_alpha = atan2(oo[1], oo[0]);
    //end angle - only required to calculate arc angle
    double beta = atan2(ee[1], ee[0]);

    //m_gamma the arc angle (beta - m_alpha)
    if (m_alpha &lt; 0 &amp;&amp; beta &gt;= 0)
    {
        m_gamma = beta - (m_alpha + 2 * M_PI);
    }
    else if (m_alpha &gt;= 0 &amp;&amp; beta &lt; 0)
    {
        m_gamma = (beta + 2 * M_PI) - m_alpha;
    }
    else
    {
        m_gamma = beta - m_alpha;
    }

    if (clkwise &amp;&amp; m_gamma &gt; 0)
    {
        m_gamma = m_gamma - 2 * M_PI;
    }
    else if (!clkwise &amp;&amp; m_gamma &lt; 0)
    {
        m_gamma = m_gamma + 2 * M_PI;
    }

    //Saving path length
    m_path_length = m_radius * abs(m_gamma);

    switch (plane) {
    case XY:
        m_center[0] = c[0];
        m_center[1] = c[1];
        m_center[2] = start[2];
        break;
    case XZ:
        m_center[0] = c[0];
        m_center[1] = start[1];
        m_center[2] = c[1];
        break;
    case YZ:
        m_center[0] = start[0];
        m_center[1] = c[0];
        m_center[2] = c[1];
        break;
    }
}

</t>
<t tx="leo.20220407205634.68">void Path::SetCirclePath(double start[3], double center[3], Plane plane, bool clkwise)
{
    //copy to member variable
    copy(center, center + 3, m_center);

    double s[2];
    switch (plane) {
    case XY:
        s[0] = start[0];
        s[1] = start[1];
        break;
    case XZ:
        s[0] = start[0];
        s[1] = start[2];
        break;
    case YZ:
        s[0] = start[1];
        s[1] = start[2];
        break;
    }

    //origin to center
    //origin to center
    double oo[2];
    oo[0] = s[0] - center[0];
    oo[1] = s[1] - center[1];

    //radius
    m_radius = sqrt(pow(oo[0], 2) + pow(oo[1], 2));
    //start angle
    m_alpha = atan2(oo[1], oo[0]);

    //m_gamma the arc angle (beta - m_alpha) - full circle
    if (!clkwise) 
    {
        m_gamma = 2 * M_PI;
    }
    else
    {
        m_gamma = -2 * M_PI;
    }

    //Saving path length
    m_path_length = m_radius * abs(m_gamma);
}

</t>
<t tx="leo.20220407205634.69">void Path::SetBCPath(double xi[2], double xf[2])
{
    double bc_path[2];
    //B (not cyclic)
    bc_path[0] = xf[0] - xi[0];
    //C (cyclic)
    //Since the joint is cyclic, it turns beyond 360, but it still receives joint angles within -180 and 180.
    //To avoid weird turns, we check the number of turns from the input value and apply it to the final value.
    int turns = std::floor(xi[1] / 360.0);
    xf[1] += turns * 360;
    double corC = xf[1] - xi[1];
    //Since C is cyclic, and the default behavior is to run the shortest distance.
    //E.G If the joint goes from -170 to 170, it should do -20 instead of +340					
    double invC = corC - sgn(corC) * 360;// *2 * M_PI;
    // When both values are too close we select the positive
    if (std::abs(invC) - std::abs(corC) &lt; m_tolerance) {
        bc_path[1] = (corC &gt; invC ? corC : invC);
    }
    else {
        bc_path[1] = (std::abs(invC) &gt; std::abs(corC) ? corC : invC);
    }
    

    m_bc_path_length = sqrt(pow(bc_path[0], 2) + pow(bc_path[1], 2));
    if (m_bc_path_length &lt; m_tolerance) {
        m_unit_bc_vec[0] = 0.0;
        m_unit_bc_vec[1] = 0.0;
    }
    else {
        m_unit_bc_vec[0] = bc_path[0] / m_bc_path_length;
        m_unit_bc_vec[1] = bc_path[1] / m_bc_path_length;
    }
}

</t>
<t tx="leo.20220407205634.7">class ostream_sink final : public base_sink&lt;Mutex&gt;
{
public:
    explicit ostream_sink(std::ostream &amp;os, bool force_flush = false)
        : ostream_(os)
        , force_flush_(force_flush)
    {
    }
    ostream_sink(const ostream_sink &amp;) = delete;
    ostream_sink &amp;operator=(const ostream_sink &amp;) = delete;

protected:
    @others
};

using ostream_sink_mt = ostream_sink&lt;std::mutex&gt;;
using ostream_sink_st = ostream_sink&lt;details::null_mutex&gt;;

} // namespace sinks
} // namespace spdlog
</t>
<t tx="leo.20220407205634.70">double Path::get_path_length()
{
    return m_path_length;
}

</t>
<t tx="leo.20220407205634.71">double Path::get_bc_path_length()
{
    return m_bc_path_length;
}

</t>
<t tx="leo.20220407205634.72">void Path::GetLinearPath(double * u_vec)
{
    copy(m_unit_vec, m_unit_vec + 3, u_vec);
}

</t>
<t tx="leo.20220407205634.73">void Path::GetArcPath(double &amp; gamma, double &amp; alpha, double * center)
{
    gamma = m_gamma;
    alpha = m_alpha;
    copy(m_center, m_center + 3, center);
}

</t>
<t tx="leo.20220407205634.74">void Path::GetArcPath(double &amp; gamma, double &amp; alpha, double &amp; radius)
{
    gamma = m_gamma;
    alpha = m_alpha;
    radius = m_radius;
}
</t>
<t tx="leo.20220407205634.75">    void Path::GetBCPath(double * u_bc_vec)
    {
        copy(m_unit_bc_vec, m_unit_bc_vec + 2, u_bc_vec);
    }
}
</t>
<t tx="leo.20220407205634.76">@path ./v-rep_plugin/src/
#include "Printer.h"

#include "simConst.h"

using namespace std;

Printer::Printer(const std::string &amp;rname, const int pdofs) :
    name(rname),
    dofs(pdofs),
    collisions_enabled(true),
    ready(false)
{
    //Reserve memory for joint target positions and extrude to avoid constant reallocations
        
}

std::vector&lt;double&gt; Printer::get_cur_pos()
{
    std::lock_guard&lt;std::mutex&gt; lk(mutex_cpos);
    return cur_pos;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.77">void Printer::set_cur_pos(const std::vector&lt;double&gt; &amp;pos)
{
    std::lock_guard&lt;std::mutex&gt; lk(mutex_cpos);
    cur_pos = pos;
}
</t>
<t tx="leo.20220407205634.78">@path ./v-rep_plugin/src/
//
// async_tcp_echo_server.cpp
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Copyright (c) 2003-2008 Christopher M. Kohlhoff (chris at kohlhoff dot com)
//
// Distributed under the Boost Software License, Version 1.0. (See accompanying
// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//

#pragma once

#include "Server.h"
#include "../simExtFIBR3D.h"

using boost::asio::ip::tcp;

/****************************************************************************************
                                        ECHO
****************************************************************************************/

SessionEcho::SessionEcho(boost::asio::io_service * io_service) : socket_(*io_service)
{
    m_listener = std::make_unique&lt;Listener&gt;();
}

tcp::socket&amp; SessionEcho::get_socket()
{
    return socket_;
}

//Imediately asks to read and then goes to ext_handle when finished
@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.79">void SessionEcho::start()
{
    socket_.async_read_some(boost::asio::buffer(data_, max_length),
        boost::bind(&amp;SessionEcho::handle_read, this,
            boost::asio::placeholders::error,
            boost::asio::placeholders::bytes_transferred));
}

</t>
<t tx="leo.20220407205634.8">void sink_it_(const details::log_msg &amp;msg) override
{
    fmt::memory_buffer formatted;
    sink::formatter_-&gt;format(msg, formatted);
    ostream_.write(formatted.data(), static_cast&lt;std::streamsize&gt;(formatted.size()));
    if (force_flush_)
    {
        ostream_.flush();
    }
}

</t>
<t tx="leo.20220407205634.80">void SessionEcho::handle_read(const boost::system::error_code &amp; error, size_t bytes_transferred)
{
    if (!error)
    {
        // Send echo reply
        //Client requires echo reply
        boost::asio::async_write(socket_,
            boost::asio::buffer(data_, bytes_transferred),
            boost::bind(&amp;SessionEcho::handle_write, this,
                boost::asio::placeholders::error));

        try
        {
            // Create string from data buffer
            std::string msg(data_, data_ + bytes_transferred);
            
            // Interpret string
            m_listener-&gt;Interpret(msg);
        }
        catch (const std::exception &amp;e)
        {
            v_repExtPQBarMsgCommunication(e.what());
        }
    }
    else
    {
        //SIGNAL SERVER TO DELETE SESSION
        v_repExtPQBoxMsgCommunication("No connection with client.");

        v_repExtPQBarMsgCommunication("Disconnected from client.");
    }
}

</t>
<t tx="leo.20220407205634.81">void SessionEcho::handle_write(const boost::system::error_code &amp; error)
{
    socket_.async_read_some(boost::asio::buffer(data_, max_length),
        boost::bind(&amp;SessionEcho::handle_read, this,
            boost::asio::placeholders::error,
            boost::asio::placeholders::bytes_transferred));
}

/****************************************************************************************
                                        SEND
****************************************************************************************/

SessionSend::SessionSend(boost::asio::io_service * io_service) : socket_(*io_service)
{
    m_speaker = std::make_unique&lt;Speaker&gt;();
}

tcp::socket&amp; SessionSend::get_socket()
{
    return socket_;
}

</t>
<t tx="leo.20220407205634.82">void SessionSend::deliver(int line, bool collision)
{
    //Write new message
    m_speaker-&gt;Formulate(line, collision);

    write();
}

// Imediately writes buffer
</t>
<t tx="leo.20220407205634.83">void SessionSend::write()
{
    if (m_speaker-&gt;NumberMessages() &gt; 0)
    {
        //Get message from queue
        std::string msg = m_speaker-&gt;ReadMessage();
        //Put message in line buffer
        msg.copy(data_, msg.length());

        //Client requires echo reply
        boost::asio::async_write(socket_,
            boost::asio::buffer(data_, msg.length()), 
            boost::asio::transfer_exactly(msg.length()),
            boost::bind(&amp;SessionSend::handle_write, this,
                boost::asio::placeholders::error));
    }
}

</t>
<t tx="leo.20220407205634.84">void SessionSend::handle_write(const boost::system::error_code&amp; error)
{
    if (!error)
    {
        // If there is more numbers in the list
        if (m_speaker-&gt;NumberMessages() &gt; 0)
        {
            //Get message from queue
            std::string msg = m_speaker-&gt;ReadMessage();
            //Put message in line buffer
            msg.copy(data_, msg.length());

            //Client requires echo reply
            boost::asio::async_write(socket_,
                boost::asio::buffer(data_, msg.length()),
                boost::asio::transfer_exactly(msg.length()),
                boost::bind(&amp;SessionSend::handle_write, this,
                    boost::asio::placeholders::error));
        }
    }
    else
    {
        //SIGNAL SERVER TO DELETE SESSION
        v_repExtPQBoxMsgCommunication("No connection with client.");

        v_repExtPQBarMsgCommunication("Disconnected from client.");
    }
}

/****************************************************************************************
                                        SERVER
****************************************************************************************/

Server::Server(boost::asio::io_service* io_service, short port1, short port2) : io_service_(io_service),
    acceptor_echo_(*io_service, tcp::endpoint(tcp::v4(), port1)),
    acceptor_send_(*io_service, tcp::endpoint(tcp::v4(), port2))
{
    start_accept();
}

</t>
<t tx="leo.20220407205634.85">void Server::start_accept()
{
    session_echo = std::make_shared&lt;SessionEcho&gt;(io_service_);
    session_send = std::make_shared&lt;SessionSend&gt;(io_service_);

    acceptor_echo_.async_accept(session_echo-&gt;get_socket(),
        boost::bind(&amp;Server::handle_accept_echo, this,
            boost::asio::placeholders::error));

    acceptor_send_.async_accept(session_send-&gt;get_socket(),
        boost::bind(&amp;Server::handle_accept_send, this,
            boost::asio::placeholders::error));
}

</t>
<t tx="leo.20220407205634.86">void Server::handle_accept_echo(const boost::system::error_code&amp; error)
{
    if (!error)
    {
        session_echo-&gt;start();

        //Send message to simulator
        v_repExtPQBarMsgCommunication("Connected to client...");
    }
    else
    {
        //SIGNAL MANAGER TO DELETE SERVER
    }
}

</t>
<t tx="leo.20220407205634.87">void Server::handle_accept_send(const boost::system::error_code&amp; error)
{
    if (!error)
    {
    }
    else
    {
        //SIGNAL MANAGER TO DELETE SERVER
    }
}

</t>
<t tx="leo.20220407205634.88">void Server::broadcast(int line, bool collision)
{
    session_send-&gt;deliver(line, collision);
}

</t>
<t tx="leo.20220407205634.89">void Server::cancel_sessions()
{
    try {
        boost::system::error_code ec_echo;
        session_echo-&gt;get_socket().shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec_echo);
        session_echo-&gt;get_socket().close();
        
        boost::system::error_code ec_send;
        session_send-&gt;get_socket().shutdown(boost::asio::ip::tcp::socket::shutdown_both, ec_send);
        session_send-&gt;get_socket().close();
        
        acceptor_echo_.cancel();
        acceptor_send_.cancel();
    }
    catch (std::exception &amp;ex)
    {
        v_repExtPQBoxMsgCommunication(ex.what());
    }
}

CommunicationManager::CommunicationManager()
{
}

CommunicationManager::~CommunicationManager()
{
}

std::shared_ptr&lt;Server&gt; CommunicationManager::get_server()
{
    return server;
}

</t>
<t tx="leo.20220407205634.9">void flush_() override
{
    ostream_.flush();
}

std::ostream &amp;ostream_;
bool force_flush_;
</t>
<t tx="leo.20220407205634.90">void CommunicationManager::LaunchServer()
{
    try
    {
        int port1 = 1313;
        int port2 = 1315;

        server = std::make_shared&lt;Server&gt;(&amp;ios, port1, port2);

        //launch io_service in another thread
        bt = std::make_unique&lt;boost::thread&gt;(boost::bind(&amp;boost::asio::io_service::run, &amp;ios));
    }
    catch (std::exception&amp; e)
    {
        //Send message to simulator
        v_repExtPQBarMsgCommunication(e.what());
    }
}

</t>
<t tx="leo.20220407205634.91">void CommunicationManager::StopServer()
{
    try 
    {
        server-&gt;cancel_sessions();

        //ios.stop();
        bt-&gt;join();
    }
    catch (std::exception&amp; e)
    {
        //Send message to simulator
        v_repExtPQBarMsgCommunication(e.what());
    }
}


</t>
<t tx="leo.20220407205634.92">@path ./v-rep_plugin/src/
#include "Speaker.h"

#include &lt;boost/serialization/serialization.hpp&gt;
#include &lt;boost/property_tree/ptree.hpp&gt;
#include &lt;boost/property_tree/json_parser.hpp&gt;

#include &lt;vector&gt;

using boost::property_tree::ptree;
using boost::property_tree::write_json;

Speaker::Speaker()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.93">void Speaker::Formulate(int line, bool collision)
{
    ptree reply;
    reply.put("line", line);
    reply.put("collision", collision);
    std::ostringstream os;
    write_json(os, reply);
    //os &lt;&lt; std::endl;

    //Pushes message into queue
    JSON_scq.push_front(os.str());
}

</t>
<t tx="leo.20220407205634.94">int Speaker::NumberMessages() 
{
    return JSON_scq.size();
}

std::string Speaker::ReadMessage()
{
    std::string msg = "{}";
    if (!JSON_scq.empty()) {
        msg = JSON_scq.consume_back();
    }
    return msg;
}
</t>
<t tx="leo.20220407205634.95">@path ./v-rep_plugin/src/
#include "Trajectory.h"

#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;cmath&gt;

#define _USE_MATH_DEFINES
#include &lt;math.h&gt;

using namespace std;

static double TOLERANCE = 0.00001;

template &lt;typename T&gt; T sgn_tol(T val) {
    return (T(TOLERANCE) &lt; val) - (val &lt; -T(TOLERANCE));
}

template &lt;typename T&gt; bool abs_compare(T a, T b)
{
    return (std::abs(a) &lt; std::abs(b));
}

namespace Motion {

    Trajectory::Trajectory(double dt) : 
        m_dt(dt)
    {
        m_path = make_unique&lt;Path&gt;();
        m_vel_prof = make_unique&lt;VelocityProfile&gt;(dt);
    }

    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20220407205634.96">void Trajectory::RapidTrajectory(double start[5], double finish[5], double vel[3], double acc)
{
    //Since this function combines the path / vel profile part.
    vel[0] = 0.0;
    vel[2] = 0.0;

    //Split path into XYZ and BC
    std::vector&lt;double&gt; dist(5);
    for (size_t i = 0; i &lt; 4; ++i) {
        dist[i] = finish[i] - start[i];
    }

    double 
        xi = start[4], 
        xf = finish[4];
    //C (cyclic)
    //Since the joint is cyclic, it turns beyond 360, but it still receives joint angles within -180 and 180.
    //To avoid weird turns, we check the number of turns from the input value and apply it to the final value.
    int turns = std::floor(xi / 360.0);
    xf += turns * 360;
    double corC = xf - xi;
    //Since C is cyclic, and the default behavior is to run the shortest distance.
    //E.G If the joint goes from -170 to 170, it should do -20 instead of +340					
    double invC = corC - sgn_tol(corC) * 360;// *2 * M_PI;
    dist[4] = (std::abs(invC) &gt; std::abs(corC) ? corC : invC);

    //Finding maximum length
    auto max_it = std::max_element(dist.begin(), dist.end(), abs_compare&lt;double&gt;);
    size_t index = std::distance(dist.begin(), max_it);
    double max_len = std::abs(dist[index]);

    //maximum acceleration allowed with signals
    double a[3];
    a[0] = acc;
    a[1] = 0.0;
    a[2] = -acc;

    //distance, time of each segment
    double
        ds[3] = { 0.0, 0.0, 0.0 },
        ts[3] = { 0.0, 0.0, 0.0 };

    //check what ramps are needed
    if (abs(vel[0] - vel[1]) &gt; TOLERANCE) //start ramp
    {
        ts[0] = abs(vel[1] - vel[0]) / acc;
        ds[0] = vel[0] * ts[0] + 0.5 * a[0] * pow(ts[0], 2);
    }
    if (abs(vel[1] - vel[2]) &gt; TOLERANCE) //end ramp
    {
        ts[2] = abs(vel[2] - vel[1]) / acc;
        ds[2] = vel[1] * ts[2] + 0.5 * a[2] * pow(ts[2], 2);
    }

    //If distance covered in ramps is greater than total distance
    // In this case the actuators do not reach the target velocity,
    // instead the actuators reach an intermediate velocity that 
    // allows it to go from current to the needed velocity and cover
    // the path, respecting the accelerations imposed.
    if (max_len &gt;= ds[0] + ds[2])
    {
        //constant velocity segment length
        ds[1] = max_len - (ds[0] + ds[2]);
        //check time needed at constant speed
        ts[1] = ds[1] / vel[1];
    }
    else
    {
        if (ts[2] &lt; TOLERANCE)
        {
            ts[0] = (2 * max_len) / (vel[2] + vel[0]);
            a[0] = (vel[2] - vel[0]) / ts[0];
            ds[0] = vel[0] * ts[0] + 0.5 * a[0] * pow(ts[0], 2);
            ds[1] = 0.0;
            ds[2] = 0.0;
            ts[1] = 0.0;
            ts[2] = 0.0;
        }
        else if (ts[0] &lt; TOLERANCE)
        {
            ts[2] = (2 * max_len) / (vel[2] + vel[0]);
            a[2] = (vel[2] - vel[0]) / ts[2];
            ds[2] = vel[0] * ts[2] + 0.5 * a[2] * pow(ts[2], 2);
            ds[0] = 0.0;
            ds[1] = 0.0;
            ts[0] = 0.0;
            ts[1] = 0.0;
        }
        else
        {
            //intermediate point in path space
            double p_i = ((pow(vel[2], 2) - pow(vel[0], 2)) - 2 * a[2] * max_len) / (2 * a[0] - 2 * a[2]);
            //polynomial solving coefficients
            double as = 0.5*a[0];
            double bs = vel[0];
            double cs = -p_i;

            double r1, r2;
            if (m_vel_prof-&gt;quadroots(as, bs, cs, r1, r2))
            {
                //Use fastest solution
                // total time1 = ts + tf = ts + (vf - vi)/af = ts + (vf - (vs + as*ts))/af
                double
                    t1 = r1 + (vel[2] - (vel[0] + a[0] * r1)) / a[2],
                    t2 = r2 + (vel[2] - (vel[0] + a[0] * r2)) / a[2];

                double sol = 0.0;
                if (t1 &gt; 0 &amp;&amp; t2 &gt; 0)
                    sol = (t1 &lt;= t2 ? r1 : r2);
                else if (t1 &gt; 0)
                    sol = r1;
                else if (t2 &gt; 0)
                    sol = r2;
                else
                    throw runtime_error("No real roots found when computing Ramp Velocity Profile found");


                vel[1] = vel[0] + a[0] * sol;

                //New times
                ts[0] = sol;
                ts[1] = 0.0;
                ts[2] = (vel[2] - vel[1]) / a[2];

                //New distances
                ds[0] = vel[0] * ts[0] + 0.5 * a[0] * pow(ts[0], 2);
                ds[1] = 0.0;
                ds[2] = vel[1] * ts[2] + 0.5 * a[2] * pow(ts[2], 2);
            }
            else
            {
                throw runtime_error("No real roots found when computing Ramp Velocity Profile found");
            }
        }
    }
    //total time of all segments 
    double tt = ts[0] + ts[1] + ts[2];
    //number of trajectory samples
    int num_samples = ceil(tt / m_dt);

    if (num_samples &gt; 0)
    {
        //Initialize vector of joint coordinates

        m_joints.assign(num_samples, vector&lt;double&gt;(5, 0.0));
        for (size_t j = 0; j &lt; 5; ++j) {
            
            double ratio = dist[j] / max_len;
            double velj[3] = { vel[0] * ratio, vel[1] * ratio , vel[2] * ratio };
            double accj[3] = { a[0] * ratio, a[1] * ratio , a[2] * ratio };


            for (size_t i = 0; i &lt; num_samples-1; i++)
            {
                //Sample time
                //Starts at instant 1 instead of 0
                //Stops at final time but always reaches reference position
                double ti = (i+1) * m_dt;
                if (ti &lt; ts[0])
                {
                    m_joints[i][j] = start[j] + (velj[0] * ti + 0.5 * accj[0] * pow(ti, 2));
                    m_joints[i][j] = (j &lt; 3 ? m_joints[i][j] / 1000 : m_joints[i][j] * (M_PI / 180));
                }
                else if (ti &gt;= ts[0] &amp;&amp; ti &lt; (ts[1] + ts[0]))
                {
                    m_joints[i][j] = start[j] + (ds[0] * ratio + velj[1] * (ti - ts[0]));
                    m_joints[i][j] = (j &lt; 3 ? m_joints[i][j] / 1000 : m_joints[i][j] * (M_PI / 180));
                }
                else
                {
                    double tf = ti - (ts[1] + ts[0]);
                    m_joints[i][j] = start[j] + ((ds[0] + ds[1])*ratio + velj[1] * tf + 0.5 * accj[2] * pow(tf, 2));
                    m_joints[i][j] = (j &lt; 3 ? m_joints[i][j] / 1000 : m_joints[i][j] * (M_PI / 180));
                }
            }
            m_joints[num_samples - 1][j] = finish[j];
            m_joints[num_samples - 1][j] = (j &lt; 3 ? m_joints[num_samples - 1][j] / 1000 : m_joints[num_samples - 1][j] * (M_PI / 180));
        }
    }
}

</t>
<t tx="leo.20220407205634.97">void Trajectory::LinearTrajectory(double start[5], double finish[5], double vel[3], double acc, bool interpolated)
{
    //Split path into XYZ and BC
    double
        start_xyz[3], finish_xyz[3],
        start_bc[2], finish_bc[2];

    vector_split(start, start_xyz, start_bc);
    vector_split(finish, finish_xyz, finish_bc);

    //Set path
    m_path-&gt;SetLinearPath(start_xyz, finish_xyz);
    m_path-&gt;SetBCPath(start_bc, finish_bc);

    double xyz_plen = m_path-&gt;get_path_length();
    double bc_plen = m_path-&gt;get_bc_path_length();
    double combined_plen = sqrt(pow(xyz_plen,2) + pow(bc_plen,2));

    //Set profile
    if (interpolated)
    {
        m_vel_prof-&gt;SetInterpolationProfile(vel[0], vel[1], combined_plen);
    }
    else
    {
        m_vel_prof-&gt;SetRampProfile(vel, acc, combined_plen);
    }

    //Get path vector
    double uvec[3], uvec_bc[2];
    m_path-&gt;GetLinearPath(uvec);
    m_path-&gt;GetBCPath(uvec_bc);

    //Get profile path positions
    double path_time;
    vector&lt;double&gt; path_pos;
    m_vel_prof-&gt;GetProfile(path_time, path_pos);

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_ac / len)
    double xyz_racio = m_path-&gt;get_path_length() / combined_plen;
    double bc_racio = m_path-&gt;get_bc_path_length() / combined_plen;

    //Initialize vector of joint coordinates
    m_joints.assign(path_pos.size(), vector&lt;double&gt;(5, 0.0));
    for (size_t i = 0; i &lt; path_pos.size(); ++i)
    {
        m_joints[i][0] = (uvec[0] * path_pos[i] * xyz_racio + start_xyz[0]) / 1000;
        m_joints[i][1] = (uvec[1] * path_pos[i] * xyz_racio + start_xyz[1]) / 1000;
        m_joints[i][2] = (uvec[2] * path_pos[i] * xyz_racio + start_xyz[2]) / 1000;

        m_joints[i][3] = (uvec_bc[0] * path_pos[i] * bc_racio + start_bc[0]) * (M_PI / 180);
        m_joints[i][4] = (uvec_bc[1] * path_pos[i] * bc_racio + start_bc[1]) * (M_PI / 180);
    }
}

</t>
<t tx="leo.20220407205634.98">void Trajectory::ArcTrajectory(double start[5], double finish[5], double center[5], Plane plane, bool clkwise, double vel[3], double acc, bool interpolation)
{
    //Split path into XYZ and BC
    double
        start_xyz[3], finish_xyz[3], center_xyz[3],
        start_bc[2], finish_bc[2], center_bc[2];

    vector_split(start, start_xyz, start_bc);
    vector_split(finish, finish_xyz, finish_bc);
    vector_split(center, center_xyz, center_bc);

    //Center relative to start point
    center_xyz[0] += start_xyz[0];
    center_xyz[1] += start_xyz[1];
    center_xyz[2] += start_xyz[2];

    //Set path
    m_path-&gt;SetArcPath(start_xyz, finish_xyz, center_xyz, plane, clkwise);
    m_path-&gt;SetBCPath(start_bc, finish_bc);

    double xyz_plen = m_path-&gt;get_path_length();
    double bc_plen = m_path-&gt;get_bc_path_length();
    double combined_plen = sqrt(pow(xyz_plen, 2) + pow(bc_plen, 2));

    //Set velocity profile
    if (interpolation)
    {
        m_vel_prof-&gt;SetInterpolationProfile(vel[0], vel[2], m_path-&gt;get_path_length());
    }
    else
    {
        m_vel_prof-&gt;SetRampProfile(vel, acc, m_path-&gt;get_path_length());
    }

    //Get path information
    double gamma, alpha, radius;
    double uvec_bc[2];
    m_path-&gt;GetArcPath(gamma, alpha, radius);
    m_path-&gt;GetBCPath(uvec_bc);

    //Get profile path positions
    double path_time;
    vector&lt;double&gt; path_pos;
    m_vel_prof-&gt;GetProfile(path_time, path_pos);

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_bc / len)
    //double path_racio = m_path-&gt;get_bc_path_length() / m_path-&gt;get_path_length();

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_bc / len)
    double xyz_racio = m_path-&gt;get_path_length() / combined_plen;
    double bc_racio = m_path-&gt;get_bc_path_length() / combined_plen;

    //Sample path according to the sample times
    vector&lt;double&gt; ti = linspace(0, 1, path_pos.size());

    //Initialize vector of joint coordinates
    m_joints.assign(path_pos.size(), vector&lt;double&gt;(5, 0.0));
    
    int c1, c2, c3;
    switch (plane)
    {
    case Motion::XY:
        c1 = 0; //x
        c2 = 1; //y
        c3 = 2; //z
        break;
    case Motion::XZ:
        c1 = 0; //x
        c2 = 2; //z
        c3 = 1; //y
        break;
    case Motion::YZ:
        c1 = 1; //y
        c2 = 2; //z
        c3 = 0; //x
        break;
    }

    for (size_t i = 0; i &lt; path_pos.size(); ++i)
    {
        double path = alpha + gamma * ti[i];
        m_joints[i][c1] = (radius * cos(path) * xyz_racio + center_xyz[c1]) / 1000;
        m_joints[i][c2] = (radius * sin(path) * xyz_racio + center_xyz[c2]) / 1000;
        m_joints[i][c3] = (start_xyz[c3]) / 1000;

        m_joints[i][3] = (uvec_bc[0] * path_pos[i] * bc_racio + start_bc[0]) * (M_PI / 180);
        m_joints[i][4] = (uvec_bc[1] * path_pos[i] * bc_racio + start_bc[1]) * (M_PI / 180);
    }
}

</t>
<t tx="leo.20220407205634.99">void Trajectory::ArcTrajectory(double start[5], double finish[5], double radius, Plane plane, bool clkwise, double vel[3], double acc, bool interpolation)
{
    //Split path into XYZ and BC
    double
        start_xyz[3], finish_xyz[3],
        start_bc[2], finish_bc[2];

    vector_split(start, start_xyz, start_bc);
    vector_split(finish, finish_xyz, finish_bc);

    //Set path
    m_path-&gt;SetArcPath(start_xyz, finish_xyz, radius, plane, clkwise);
    m_path-&gt;SetBCPath(start_bc, finish_bc);
    //Negative radius case
    radius = std::abs(radius);

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_bc / len)
    double xyz_plen = m_path-&gt;get_path_length();
    double bc_plen = m_path-&gt;get_bc_path_length();
    double combined_plen = sqrt(pow(xyz_plen, 2) + pow(bc_plen, 2));

    //Set velocity profile
    if (interpolation)
    {
        m_vel_prof-&gt;SetInterpolationProfile(vel[0], vel[2], m_path-&gt;get_path_length());
    }
    else
    {
        m_vel_prof-&gt;SetRampProfile(vel, acc, m_path-&gt;get_path_length());
    }

    //Get path information
    double gamma, alpha, center[3];
    double uvec_bc[2];
    m_path-&gt;GetArcPath(gamma, alpha, center);
    m_path-&gt;GetBCPath(uvec_bc);

    //Get profile path positions
    double path_time;
    vector&lt;double&gt; path_pos;
    m_vel_prof-&gt;GetProfile(path_time, path_pos);

    //Relation between bc_path and path -&gt; pos_bc[i] = pos[i] * racio = pos[i] * (len_bc / len)
    double xyz_racio = m_path-&gt;get_path_length() / combined_plen;
    double bc_racio = m_path-&gt;get_bc_path_length() / combined_plen;

    //Sample path according to the sample times
    vector&lt;double&gt; ti = linspace(0, 1, path_pos.size());

    //Initialize vector of joint coordinates
    m_joints.assign(path_pos.size(), vector&lt;double&gt;(5, 0.0));

    int c1, c2, c3;
    switch (plane)
    {
    case Motion::XY:
        c1 = 0; //x
        c2 = 1; //y
        c3 = 2; //z
        break;
    case Motion::XZ:
        c1 = 0; //x
        c2 = 2; //z
        c3 = 1; //y
        break;
    case Motion::YZ:
        c1 = 1; //y
        c2 = 2; //z
        c3 = 0; //x
        break;
    }

    for (size_t i = 0; i &lt; path_pos.size(); ++i)
    {
        double path = alpha + gamma * ti[i];
        m_joints[i][c1] = (radius * cos(path) * xyz_racio + center[c1]) / 1000;
        m_joints[i][c2] = (radius * sin(path) * xyz_racio + center[c2]) / 1000;
        m_joints[i][c3] = (start[c3]) / 1000;

        m_joints[i][3] = (uvec_bc[0] * path_pos[i] * bc_racio + start_bc[0]) * (M_PI / 180);
        m_joints[i][4] = (uvec_bc[1] * path_pos[i] * bc_racio + start_bc[1]) * (M_PI / 180);
    }
}

</t>
</tnodes>
</leo_file>
