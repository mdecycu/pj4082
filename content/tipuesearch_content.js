var tipuesearch = {"pages": [{'title': 'About', 'text': '3d 列印機電模擬系統在 uArm 機械手臂設計流程上的應用 \n The Application of 3D Printing Mechatronic Simulation System in the Design Process of uArm Robotic Arm \n 組員: \n 40823116 40823131 40823152 40823153 \n', 'tags': '', 'url': 'About.html'}, {'title': 'Reference', 'text': '2020_An Engineer’s Guide to Industrial Robot Designs.pdf  ( 簡體中文 ) \n Repository:  https://github.com/mdecourse/pj4082 \n Github Pages:  https://mde.tw/pj4082 \n Heroku:  https://pj4082.herokuapp.com  (以倉儲容量壓縮檔案計算, 若超過 500 MB, 將無法 push 到 Heroku 進行同步) \n Discussion:  https://github.com/mdecourse/pj4082/discussions \n \n 繼平面機構合成與分析套件的開發 ( https://github.com/mdecourse/ps2020 ) 後, Project 4082 希望可以開發用於計算機程式, 網際內容管理, 電腦輔助設計實習與協同產品設計實習課程使用的: \n 機器手臂模擬套件, 也就是 Six-axis Robotic Arm Simulator. \n \n Reference: \n 1999_modeling_of_industrial_robot.pdf \n 2001_Kinematic Calibration Procedure for Serial Robotswith Six Revolute Axes.pdf \n 2002_Forward and Inverse Kinematics Models for a 5-dof Pioneer 2 Robot Arm .pdf \n 2007_On Modeling and Control of FlexibleManipulators.pdf \n 2008_Design Optimization in Industrial Robotics.pdf \n 2010_modeling and Control of FlexibleManipulators.pdf \n 2011_Vision Based 3-D Position Control for a Robot Arm.pdf \n 2011_Development of a Model-Based Control System forthe Gantry-Tau Parallel Kinematic Machine.pdf \n 2012_Concept design of an ultra-lightindustrial robot.pdf \n 2014_Design, Implementation and Control of aRobotic Arm Using PIC 16F877A Microcontroller.pdf \n 2014_Kinematic analysis and simulation of a new-type robotwith special structure.pdf \n 2015_Kinematic Calibration of Six-Axis Robots.pdf \n 2016_Design and Structural Analysis of a Robotic Arm.pdf \n 2018_Robot Racking.pdf \n 2018_The parameter identification model consideringboth geometric parameters and joint stiffness.pfd.pdf \n 2019_Modeling techniques for kinematic analysis of a six-axis robotic arm.pdf \n 2019_Kinematic and Dynamic Analysis of an IndustrialSix-Axis Robotic Manipulator.pdf \n 2019_Milling accuracy improvement of a 6-axis industrial robot through dynamic analysis.pdf \n /downloads/2019_Modelling, Identification and Controlof a 5-DOF Shotcrete Robot.pdf \n 2020_Design, simulation, and analysis of a 6-axis robot using robot visualization software.pdf \n 2020_Modeling and Control of6-axis Robot Arm.pdf \n 2020_Shape Design Optimization of a Robot Arm Using aSurrogate-Based Evolutionary Approach.pdf \n https://github.com/HbirdJ/RoboND-Kinematics-Project  (DH calculator) \n Kuk kr16 cad files:  https://grabcad.com/library/kuka-kr16-industrial-robotic-arm-1 \n Podcast:  Understanding and solving industrial robot design challenges', 'tags': '', 'url': 'Reference.html'}, {'title': 'Task1', 'text': '從\xa0 https://github.com/mdecourse/RobotSimulator  倉儲開始研究, 配合  Beginning PyQT.pdf , 以及  OpenGL Programming Guide.pdf  電子書整理資料. \n 目標: 重新設定 OpenGL 場景的光影設定, 採用  RoKiSim  Industrial Robot 定義方式, 導入更多 Robots 與 Tools 進行控制模擬. \n', 'tags': '', 'url': 'Task1.html'}, {'title': 'CAD', 'text': 'Solvespace: \n 自行編譯 \n https://github.com/solvespace/solvespace \n \n NX12: \n 可攜套件 (nx12 At mde Gdrive 下載) \n Onshape: \n https://www.onshape.com/en/ \n 利用近端或網際程式 (Heroku) 訂製所需零組件. \n FreeCAD: \n 可利用 Python 產生零組件的自由套件. \n https://www.freecadweb.org/ \n \n', 'tags': '', 'url': 'CAD.html'}, {'title': 'Teach', 'text': 'https://automaticaddison.com/ \n https://automaticaddison.com/about-me/ \n https://medium.com/@kylry/it-s-important-to-teach-problem-solving-or-teach-to-the-problem-and-not-the-tools-musk-says-ffc754f0c05a \n https://elbruno.com/2015/09/14/innovation-teach-to-solve-problems-not-to-use-tools/ \n How to teach the problem but not the tools. \n \n \n', 'tags': '', 'url': 'Teach.html'}, {'title': 'Webots', 'text': 'Webots docs 研究: \n Webots documentation 採用 showdown.js 將 markdown 轉為 html 的過程還利用關鍵字替代置入 html 與 javascript 以 x3d 格式操控網際 Robot 的技術, 可以用來展示相關的 Robotics 設計與控制結果ㄡ \n https://www.cyberbotics.com/doc/guide/web-streaming \n Learning materials: \n https://courses.ideate.cmu.edu/16-375/f2020/text/lectures/index.html \n https://courses.ideate.cmu.edu/16-375/f2019/text/index.html \n 2020_Deepbots_ A Webots-Based DeepReinforcement Learning Frameworkfor Robotics.pdf \n https://github.com/aidudezzz/deepbots \n https://github.com/aidudezzz/deepbots-tutorials \n https://github.com/KelvinYang0320/deepbots-RL-agent \n 在自行建立 Robot simulator 之前, 先熟悉 Webots 架構, 查驗是否可以直接利用 Webots 執行專案. \n Windows 64 位元 lite 可攜版本: \n http://a.kmol.info:88/webots_lite.7z \n Webots user guide: \n https://cyberbotics.com/doc/guide/index \n Webots reference manual: \n https://cyberbotics.com/doc/reference/index \n Webots for automobile: \n https://cyberbotics.com/doc/automobile/index \n 執行下列 inverse_kimatics.wbt 之前必須 pip install ikpy \n Webots\\projects\\robots\\abb\\irb\\worlds\\inverse_kinematics.wbt 使用 shift + 滑鼠左鍵可以移動 Object. \n Webots 容量 \n R2021a 版本 \n doc 目錄 587 MB \n include 目錄 9.73 MB \n lib 目錄 8 MB \n msys64 目錄 701 MB \n projects 目錄 1.03 GB \n resources 目錄 38.4 MB \n scripts 目錄 3.3 KB \n src 目錄 717 KB \n 經刪除 Webots\\doc - 587 MB 以及 Webots\\msys64\\mingw32 - 382 MB等兩個目錄後的 webots_lite 可以從  http://a.kmol.info:88/webots_lite.7z  下載 (873 MB), 解開壓縮後約 1.77 GB, 執行 start_webots.bat 後啟動 Webots, webots_lite 所在位置不可使用中文目錄名稱. \n', 'tags': '', 'url': 'Webots.html'}, {'title': 'Compile Webots', 'text': 'https://github.com/cyberbotics/webots/wiki \n \n \n', 'tags': '', 'url': 'Compile Webots.html'}, {'title': 'X3D', 'text': '應該可以從  https://www.cyberbotics.com/doc/guide/ure  取出 embedded robot. \n 根據  http://mde.tw/webots_R2019a/?book=guide&page=ure  其中的 robot 從 x3d ur10 模型轉為 webgl 後透過 javascript 進行操控. \n https://github.com/mdecourse/webots_docs  專門用於解析  https://mde.tw/webots_docs  中與  https://github.com/showdownjs/showdown ,  https://github.com/x3dom/x3dom  與  https://developer.mozilla.org/zh-TW/docs/Web/API/WebGL_API  之間的關係. \n \n', 'tags': '', 'url': 'X3D.html'}, {'title': 'DH Parameters', 'text': 'Kuka kr16: \n https://wiki.freecadweb.org/Robot_6-Axis \n Denavit-Hartenberg Parameters \n How to Find Denavit-Hartenberg Parameter Tables – Automatic Addison.pdf  ( link ) \n How to Find the Rotation Matrices for Robotic Arms – Automatic Addison.pdf \n Coding Denavit-Hartenberg Tables Using Python – Automatic Addison.pdf \n \n Image file from  https://automaticaddison.com/wp-content/uploads/2020/05/how-robotics-should-be-taught-large-light.jpg \n', 'tags': '', 'url': 'DH Parameters.html'}, {'title': 'Programming', 'text': 'matplotlib, numpy, numpy-stl application \n render stl file: \n from stl import mesh\nfrom mpl_toolkits import mplot3d\nfrom matplotlib import pyplot\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = mplot3d.Axes3D(figure)\n\n# Load the STL files and add the vectors to the plot\nyour_mesh = mesh.Mesh.from_file(\'tests/stl_binary/HalfDonut.stl\')\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(your_mesh.vectors))\n\n# Auto scale to the mesh size\nscale = your_mesh.points.flatten(-1)\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show() \n from stl import mesh\nimport math\nimport numpy\n# pip install numpy-stl\n\'\'\'\nfrom stl import mesh\nnum_triangles=len(fin_list)\ndata = np.zeros(num_triangles, dtype=mesh.Mesh.dtype)\nfor i in range(num_triangles):\n    #I did not know how to use numpy-arrays in this case. This was the major roadblock\n    # assign vertex co-ordinates to variables to write into mesh\n    data["vectors"][i] = np.array([[v1x, v1y, v1z],[v2x, v2y, v2z],[v3x, v3y, v3z]])\nm=mesh.Mesh(data)\nm.save(\'filename.stl\')\n\'\'\'\n\'\'\'\nimport numpy as np\nfrom stl import mesh\n\n# Define the 8 vertices of the cube\nvertices = np.array([\\\n    [-1, -1, -1],\n    [+1, -1, -1],\n    [+1, +1, -1],\n    [-1, +1, -1],\n    [-1, -1, +1],\n    [+1, -1, +1],\n    [+1, +1, +1],\n    [-1, +1, +1]])\n# Define the 12 triangles composing the cube\nfaces = np.array([\\\n    [0,3,1],\n    [1,3,2],\n    [0,4,7],\n    [0,7,3],\n    [4,5,6],\n    [4,6,7],\n    [5,1,2],\n    [5,2,6],\n    [2,3,6],\n    [3,7,6],\n    [0,1,5],\n    [0,5,4]])\n\n# Create the mesh\ncube = mesh.Mesh(np.zeros(faces.shape[0], dtype=mesh.Mesh.dtype))\nfor i, f in enumerate(faces):\n    for j in range(3):\n        cube.vectors[i][j] = vertices[f[j],:]\n\n# Write the mesh to file "cube.stl"\ncube.save(\'cube.stl\')\n\n\'\'\'\n\'\'\'\nimport numpy\nfrom stl import mesh\n\n# Using an existing stl file:\nyour_mesh = mesh.Mesh.from_file(\'some_file.stl\')\n\n# Or creating a new mesh (make sure not to overwrite the `mesh` import by\n# naming it `mesh`):\nVERTICE_COUNT = 100\ndata = numpy.zeros(VERTICE_COUNT, dtype=mesh.Mesh.dtype)\nyour_mesh = mesh.Mesh(data, remove_empty_areas=False)\n\n# The mesh normals (calculated automatically)\nyour_mesh.normals\n# The mesh vectors\nyour_mesh.v0, your_mesh.v1, your_mesh.v2\n# Accessing individual points (concatenation of v0, v1 and v2 in triplets)\nassert (your_mesh.points[0][0:3] == your_mesh.v0[0]).all()\nassert (your_mesh.points[0][3:6] == your_mesh.v1[0]).all()\nassert (your_mesh.points[0][6:9] == your_mesh.v2[0]).all()\nassert (your_mesh.points[1][0:3] == your_mesh.v0[1]).all()\n\nyour_mesh.save(\'new_stl_file.stl\')\n\'\'\'\n\n# Create 3 faces of a cube\ndata = numpy.zeros(6, dtype=mesh.Mesh.dtype)\n\n# Top of the cube\ndata[\'vectors\'][0] = numpy.array([[0, 1, 1],\n                                  [1, 0, 1],\n                                  [0, 0, 1]])\ndata[\'vectors\'][1] = numpy.array([[1, 0, 1],\n                                  [0, 1, 1],\n                                  [1, 1, 1]])\n# Front face\ndata[\'vectors\'][2] = numpy.array([[1, 0, 0],\n                                  [1, 0, 1],\n                                  [1, 1, 0]])\ndata[\'vectors\'][3] = numpy.array([[1, 1, 1],\n                                  [1, 0, 1],\n                                  [1, 1, 0]])\n# Left face\ndata[\'vectors\'][4] = numpy.array([[0, 0, 0],\n                                  [1, 0, 0],\n                                  [1, 0, 1]])\ndata[\'vectors\'][5] = numpy.array([[0, 0, 0],\n                                  [0, 0, 1],\n                                  [1, 0, 1]])\n\n# Since the cube faces are from 0 to 1 we can move it to the middle by\n# substracting .5\ndata[\'vectors\'] -= .5\n\ncube_back = mesh.Mesh(data.copy())\ncube_front = mesh.Mesh(data.copy())\n\n# Rotate 90 degrees over the X axis followed by the Y axis followed by the\n# X axis\ncube_back.rotate([0.5, 0.0, 0.0], math.radians(90))\ncube_back.rotate([0.0, 0.5, 0.0], math.radians(90))\ncube_back.rotate([0.5, 0.0, 0.0], math.radians(90))\n\ncube = mesh.Mesh(numpy.concatenate([\n    cube_back.data.copy(),\n    cube_front.data.copy(),\n]))\n\n# Optionally render the rotated cube faces\nfrom matplotlib import pyplot\nfrom mpl_toolkits import mplot3d\n\n# Create a new plot\nfigure = pyplot.figure()\naxes = mplot3d.Axes3D(figure)\n\n# Render the cube\naxes.add_collection3d(mplot3d.art3d.Poly3DCollection(cube.vectors))\n\n# Auto scale to the mesh size\nscale = cube_back.points.flatten()\naxes.auto_scale_xyz(scale, scale, scale)\n\n# Show the plot to the screen\npyplot.show() \n', 'tags': '', 'url': 'Programming.html'}, {'title': 'Onshape', 'text': 'Onshape to robot: \n onshape_to_robot.pdf \n https://onshape-to-robot.readthedocs.io/en/latest/ \n \n Onshapepy (deprecated, replaced with  https://github.com/onshape-public/onshape-clients  ): \n from onshapepy.part import Configuration\nfrom onshapepy.core.units import u\nimport pytest\n\ndef test_get_part_params(cube):\n    print(cube.params)\n    assert cube.params[\'has_fillet\']\n    assert 100*u.mm == cube.params[\'L\']\n    assert 100*u.mm == cube.params[\'h\']\n    assert \'circular\' == cube.params[\'fillet_type\']\n    assert 100*u.mm == cube.params[\'w\']\n\n\ndef test_set_part_params(cube):\n    altered = {\'h\': 200 * u.mm, \'L\': 400*u.mm, \'w\': 100*u.mm, \'has_fillet\': False, \'fillet_type\': "circular"}\n    standard = {\'h\': 100 * u.mm, \'L\': 100*u.mm, \'w\': 100*u.mm, \'has_fillet\': True, \'fillet_type\': "circular"}\n    cube.params = altered\n    assert cube.params == altered\n    # reset to original\n    cube.params = standard\n    assert cube.params == standard\n\ndef test_get_measurements(cube):\n    assert cube.measurements == {\'diagonal\': 0.1414213562373095*u.meter, \'diagonal_3d\': 0.1567516118317942*u.meter}\n \n \n Onshape API key: \n https://dev-portal.onshape.com/keys \n \n Reference: \n https://forum.onshape.com/discussion/13683/help-getting-started-with-api \n https://github.com/onshape-public/apikey \xa0 \n https://onshape-public.github.io/docs/ \n https://github.com/onshape-public/app-gltf-viewer \n \n', 'tags': '', 'url': 'Onshape.html'}, {'title': 'Packages install', 'text': '', 'tags': '', 'url': 'Packages install.html'}, {'title': 'PyGObject on Windows', 'text': 'Install PyGObject with msys2 \n 1.Run mingw64.exe from msys2 \n 2.Execute Pacman -Suy \n 3.Execute Pacman -S mingw-w64-x86_64-gtk3 mingw-w64-x86_64-python3\xa0mingw-w64-x86_64-python3-gobject \n 4.Copy the wscite502 folder of the Y: drive and rename it to wscite502_msys2 \n 5.Modify line 152-157 of python.properties file in wscite502_msys2 folder to: \n if PLAT_WIN\n\tpython.command=Y:\\msys64_20210419\\mingw64\\bin\\pythonw\nif PLAT_GTK\n\tpython.command=python3\nif PLAT_MAC\n\tpython.command=python \n 6.Try to execute gtk_ex1.py in SciTE \n import gi\n \ngi.require_version("Gtk", "3.0")\nfrom gi.repository import Gtk\n \nwin = Gtk.Window()\nwin.connect("destroy", Gtk.main_quit)\nwin.show_all()\nGtk.main() \n \n 7.Finish installation', 'tags': '', 'url': 'PyGObject on Windows.html'}]};